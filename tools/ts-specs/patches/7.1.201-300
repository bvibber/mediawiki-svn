To: vim-dev@vim.org
Subject: Patch 7.1.201
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.201
Problem:    When reading stdin 'fenc' and 'ff are not set.
Solution:   Set the options after reading stdin. (Ben Schmidt)
Files:	    src/fileio.c


*** ../vim-7.1.200/src/fileio.c	Wed Jan  2 21:07:32 2008
--- src/fileio.c	Fri Jan  4 16:18:27 2008
***************
*** 221,231 ****
  {
      int		fd = 0;
      int		newfile = (flags & READ_NEW);
-     int		set_options = newfile || (eap != NULL && eap->read_edit);
      int		check_readonly;
      int		filtering = (flags & READ_FILTER);
      int		read_stdin = (flags & READ_STDIN);
      int		read_buffer = (flags & READ_BUFFER);
      linenr_T	read_buf_lnum = 1;	/* next line to read from curbuf */
      colnr_T	read_buf_col = 0;	/* next char to read from this line */
      char_u	c;
--- 221,232 ----
  {
      int		fd = 0;
      int		newfile = (flags & READ_NEW);
      int		check_readonly;
      int		filtering = (flags & READ_FILTER);
      int		read_stdin = (flags & READ_STDIN);
      int		read_buffer = (flags & READ_BUFFER);
+     int		set_options = newfile || read_buffer
+ 					   || (eap != NULL && eap->read_edit);
      linenr_T	read_buf_lnum = 1;	/* next line to read from curbuf */
      colnr_T	read_buf_col = 0;	/* next char to read from this line */
      char_u	c;
***************
*** 650,657 ****
  
      if (set_options)
      {
! 	curbuf->b_p_eol = TRUE;
! 	curbuf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
  	curbuf->b_p_bomb = FALSE;
  	curbuf->b_start_bomb = FALSE;
--- 651,663 ----
  
      if (set_options)
      {
! 	/* Don't change 'eol' if reading from buffer as it will already be
! 	 * correctly set when reading stdin. */
! 	if (!read_buffer)
! 	{
! 	    curbuf->b_p_eol = TRUE;
! 	    curbuf->b_start_eol = TRUE;
! 	}
  #ifdef FEAT_MBYTE
  	curbuf->b_p_bomb = FALSE;
  	curbuf->b_start_bomb = FALSE;
*** ../vim-7.1.200/src/version.c	Fri Jan  4 16:00:10 2008
--- src/version.c	Fri Jan  4 16:27:01 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     201,
  /**/

-- 
A mathematician is a device for turning coffee into theorems.
					Paul Erdos
A computer programmer is a device for turning coffee into bugs.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.202
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.202
Problem:    Incomplete utf-8 byte sequence is not checked for validity.
Solution:   Check the bytes that are present for being valid. (Ben Schmidt)
Files:	    src/mbyte.c


*** ../vim-7.1.201/src/mbyte.c	Thu Aug 30 13:51:52 2007
--- src/mbyte.c	Fri Jan  4 17:30:16 2008
***************
*** 1642,1648 ****
   * Get the length of UTF-8 byte sequence "p[size]".  Does not include any
   * following composing characters.
   * Returns 1 for "".
!  * Returns 1 for an illegal byte sequence.
   * Returns number > "size" for an incomplete byte sequence.
   */
      int
--- 1642,1648 ----
   * Get the length of UTF-8 byte sequence "p[size]".  Does not include any
   * following composing characters.
   * Returns 1 for "".
!  * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
   * Returns number > "size" for an incomplete byte sequence.
   */
      int
***************
*** 1652,1664 ****
  {
      int		len;
      int		i;
  
      if (*p == NUL)
  	return 1;
!     len = utf8len_tab[*p];
      if (len > size)
! 	return len;	/* incomplete byte sequence. */
!     for (i = 1; i < len; ++i)
  	if ((p[i] & 0xc0) != 0x80)
  	    return 1;
      return len;
--- 1652,1665 ----
  {
      int		len;
      int		i;
+     int		m;
  
      if (*p == NUL)
  	return 1;
!     m = len = utf8len_tab[*p];
      if (len > size)
! 	m = size;	/* incomplete byte sequence. */
!     for (i = 1; i < m; ++i)
  	if ((p[i] & 0xc0) != 0x80)
  	    return 1;
      return len;
*** ../vim-7.1.201/src/version.c	Fri Jan  4 16:30:40 2008
--- src/version.c	Fri Jan  4 17:45:33 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     202,
  /**/

-- 
A computer programmer is a device for turning requirements into
undocumented features.  It runs on cola, pizza and Dilbert cartoons.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.203
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.203
Problem:    When 'virtualedit' is "onemore" then "99|" works but ":normal 99|"
	    doesn't.  (Andy Wokula)
Solution:   Check for "onemore" flag in check_cursor_col().
Files:	    src/misc2.c


*** ../vim-7.1.202/src/misc2.c	Sat Nov 24 21:27:33 2007
--- src/misc2.c	Fri Jan  4 21:24:46 2008
***************
*** 507,517 ****
  	curwin->w_cursor.col = 0;
      else if (curwin->w_cursor.col >= len)
      {
! 	/* Allow cursor past end-of-line in Insert mode, restarting Insert
! 	 * mode or when in Visual mode and 'selection' isn't "old" */
  	if ((State & INSERT) || restart_edit
  #ifdef FEAT_VISUAL
  		|| (VIsual_active && *p_sel != 'o')
  #endif
  		|| virtual_active())
  	    curwin->w_cursor.col = len;
--- 508,523 ----
  	curwin->w_cursor.col = 0;
      else if (curwin->w_cursor.col >= len)
      {
! 	/* Allow cursor past end-of-line when:
! 	 * - in Insert mode or restarting Insert mode
! 	 * - in Visual mode and 'selection' isn't "old"
! 	 * - 'virtualedit' is set */
  	if ((State & INSERT) || restart_edit
  #ifdef FEAT_VISUAL
  		|| (VIsual_active && *p_sel != 'o')
+ #endif
+ #ifdef FEAT_VIRTUALEDIT
+ 		|| (ve_flags & VE_ONEMORE)
  #endif
  		|| virtual_active())
  	    curwin->w_cursor.col = len;
*** ../vim-7.1.202/src/version.c	Fri Jan  4 17:46:46 2008
--- src/version.c	Fri Jan  4 21:22:29 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     203,
  /**/

-- 
`When any government, or any church for that matter, undertakes to say to
 its subjects, "This you may not read, this you must not see, this you are
 forbidden to know," the end result is tyranny and oppression no matter how
 holy the motives' -- Robert A Heinlein, "If this goes on --"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.204 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.204 (extra)
Problem:    Win32: Using the example at 'balloonexpr' the balloon disappears
	    after four seconds and then comes back again.  Also moves the
	    mouse pointer a little bit.  (Yongwei Wu)
Solution:   Set the autopop time to 30 seconds (the max value).  (Sergey
	    Khorev)  Move the mouse two pixels forward and one back to end up
	    in the same position (really!).
Files:	    src/gui_w32.c



*** ../vim-7.1.203/src/gui_w32.c	Thu Jan  3 20:44:35 2008
--- src/gui_w32.c	Sat Jan  5 13:09:56 2008
***************
*** 4575,4585 ****
      SendMessage(beval->balloon, TTM_ADDTOOL, 0, (LPARAM)pti);
      /* Make tooltip appear sooner */
      SendMessage(beval->balloon, TTM_SETDELAYTIME, TTDT_INITIAL, 10);
      /*
       * HACK: force tooltip to appear, because it'll not appear until
       * first mouse move. D*mn M$
       */
!     mouse_event(MOUSEEVENTF_MOVE, 1, 1, 0, 0);
      mouse_event(MOUSEEVENTF_MOVE, (DWORD)-1, (DWORD)-1, 0, 0);
      vim_free(pti);
  }
--- 4575,4589 ----
      SendMessage(beval->balloon, TTM_ADDTOOL, 0, (LPARAM)pti);
      /* Make tooltip appear sooner */
      SendMessage(beval->balloon, TTM_SETDELAYTIME, TTDT_INITIAL, 10);
+     /* I've performed some tests and it seems the longest possible life time
+      * of tooltip is 30 seconds */
+     SendMessage(beval->balloon, TTM_SETDELAYTIME, TTDT_AUTOPOP, 30000);
      /*
       * HACK: force tooltip to appear, because it'll not appear until
       * first mouse move. D*mn M$
+      * Amazingly moving (2, 2) and then (-1, -1) the mouse doesn't move.
       */
!     mouse_event(MOUSEEVENTF_MOVE, 2, 2, 0, 0);
      mouse_event(MOUSEEVENTF_MOVE, (DWORD)-1, (DWORD)-1, 0, 0);
      vim_free(pti);
  }
*** ../vim-7.1.203/src/version.c	Fri Jan  4 21:25:01 2008
--- src/version.c	Sat Jan  5 13:12:22 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     204,
  /**/

-- 
WOMAN:   I didn't know we had a king. I thought we were an autonomous
         collective.
DENNIS:  You're fooling yourself.  We're living in a dictatorship.  A
         self-perpetuating autocracy in which the working classes--
WOMAN:   Oh there you go, bringing class into it again.
DENNIS:  That's what it's all about if only people would--
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.205
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.205
Problem:    Can't get the operator in an ":omap".
Solution:   Add the "v:operator" variable. (Ben Schmidt)
Files:	    runtime/doc/eval.txt, src/eval.c, src/normal.c, src/vim.h


*** ../vim-7.1.204/runtime/doc/eval.txt	Tue Sep 25 17:54:41 2007
--- runtime/doc/eval.txt	Fri Jan  4 20:38:55 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Sep 25
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 04
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1401,1410 ****
  		This is the screen column number, like with |virtcol()|.  The
  		value is zero when there was no mouse button click.
  
  					*v:prevcount* *prevcount-variable*
  v:prevcount	The count given for the last but one Normal mode command.
  		This is the v:count value of the previous command.  Useful if
! 		you want to cancel Visual mode and then use the count. >
  			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
  <		Read-only.
  
--- 1401,1424 ----
  		This is the screen column number, like with |virtcol()|.  The
  		value is zero when there was no mouse button click.
  
+ 					*v:operator* *operator-variable*
+ v:operator	The last operator given in Normal mode.  This is a single
+ 		character except for commands starting with <g> or <z>,
+ 		in which case it is two characters.  Best used alongside
+ 		|v:prevcount| and |v:register|.  Useful if you want to cancel
+ 		Operator-pending mode and then use the operator, e.g.: >
+ 			:omap O <Esc>:call MyMotion(v:operator)<CR>
+ <		The value remains set until another operator is entered, thus
+ 		don't expect it to be empty.
+ 		v:operator is not set for |:delete|, |:yank| or other Ex
+ 		commands.
+ 		Read-only.
+ 
  					*v:prevcount* *prevcount-variable*
  v:prevcount	The count given for the last but one Normal mode command.
  		This is the v:count value of the previous command.  Useful if
! 		you want to cancel Visual or Operator-pending mode and then
! 		use the count, e.g.: >
  			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
  <		Read-only.
  
*** ../vim-7.1.204/src/eval.c	Fri Dec  7 17:08:35 2007
--- src/eval.c	Sat Jan  5 13:22:52 2008
***************
*** 345,350 ****
--- 345,351 ----
      {VV_NAME("mouse_win",	 VAR_NUMBER), 0},
      {VV_NAME("mouse_lnum",	 VAR_NUMBER), 0},
      {VV_NAME("mouse_col",	 VAR_NUMBER), 0},
+     {VV_NAME("operator",	 VAR_STRING), VV_RO},
  };
  
  /* shorthand */
*** ../vim-7.1.204/src/normal.c	Thu Jan  3 13:19:50 2008
--- src/normal.c	Fri Jan  4 20:53:43 2008
***************
*** 141,146 ****
--- 141,149 ----
  static void	nv_Undo __ARGS((cmdarg_T *cap));
  static void	nv_tilde __ARGS((cmdarg_T *cap));
  static void	nv_operator __ARGS((cmdarg_T *cap));
+ #ifdef FEAT_EVAL
+ static void	set_op_var __ARGS((int optype));
+ #endif
  static void	nv_lineop __ARGS((cmdarg_T *cap));
  static void	nv_home __ARGS((cmdarg_T *cap));
  static void	nv_pipe __ARGS((cmdarg_T *cap));
***************
*** 7180,7185 ****
--- 7183,7191 ----
  	{
  	    cap->oap->start = curwin->w_cursor;
  	    cap->oap->op_type = OP_DELETE;
+ #ifdef FEAT_EVAL
+ 	    set_op_var(OP_DELETE);
+ #endif
  	    cap->count1 = 1;
  	    nv_dollar(cap);
  	    finish_op = TRUE;
***************
*** 8219,8226 ****
--- 8225,8257 ----
      {
  	cap->oap->start = curwin->w_cursor;
  	cap->oap->op_type = op_type;
+ #ifdef FEAT_EVAL
+ 	set_op_var(op_type);
+ #endif
+     }
+ }
+ 
+ #ifdef FEAT_EVAL
+ /*
+  * Set v:operator to the characters for "optype".
+  */
+     static void
+ set_op_var(optype)
+     int optype;
+ {
+     char_u	opchars[3];
+ 
+     if (optype == OP_NOP)
+ 	set_vim_var_string(VV_OP, NULL, 0);
+     else
+     {
+ 	opchars[0] = get_op_char(optype);
+ 	opchars[1] = get_extra_op_char(optype);
+ 	opchars[2] = NUL;
+ 	set_vim_var_string(VV_OP, opchars, -1);
      }
  }
+ #endif
  
  /*
   * Handle linewise operator "dd", "yy", etc.
*** ../vim-7.1.204/src/vim.h	Sat Aug 11 13:57:31 2007
--- src/vim.h	Fri Jan  4 19:11:31 2008
***************
*** 1688,1694 ****
  #define VV_MOUSE_WIN	49
  #define VV_MOUSE_LNUM   50
  #define VV_MOUSE_COL	51
! #define VV_LEN		52	/* number of v: vars */
  
  #ifdef FEAT_CLIPBOARD
  
--- 1688,1695 ----
  #define VV_MOUSE_WIN	49
  #define VV_MOUSE_LNUM   50
  #define VV_MOUSE_COL	51
! #define VV_OP		52
! #define VV_LEN		53	/* number of v: vars */
  
  #ifdef FEAT_CLIPBOARD
  
*** ../vim-7.1.204/src/version.c	Sat Jan  5 13:15:08 2008
--- src/version.c	Sat Jan  5 13:31:49 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     205,
  /**/

-- 
ARTHUR:  Then who is your lord?
WOMAN:   We don't have a lord.
ARTHUR:  What?
DENNIS:  I told you.  We're an anarcho-syndicalist commune.  We take it in
         turns to act as a sort of executive officer for the week.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.206
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.206
Problem:    Compiler warnings when using MODIFIED_BY.
Solution:   Add type casts. (Ben Schmidt)
Files:	    src/version.c


*** ../vim-7.1.205/src/version.c	Sat Jan  5 13:34:01 2008
--- src/version.c	Sat Jan  5 13:56:55 2008
***************
*** 1587,1595 ****
  
      if (*mesg == ' ')
      {
! 	vim_strncpy(modby, _("Modified by "), MODBY_LEN - 1);
  	l = STRLEN(modby);
! 	vim_strncpy(modby + l, MODIFIED_BY, MODBY_LEN - l - 1);
  	mesg = modby;
      }
  #endif
--- 1589,1597 ----
  
      if (*mesg == ' ')
      {
! 	vim_strncpy(modby, (char_u *)_("Modified by "), MODBY_LEN - 1);
  	l = STRLEN(modby);
! 	vim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);
  	mesg = modby;
      }
  #endif
*** ../vim-7.1.205/src/version.c	Sat Jan  5 13:34:01 2008
--- src/version.c	Sat Jan  5 13:56:55 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     206,
  /**/

-- 
ARTHUR:  I am your king!
WOMAN:   Well, I didn't vote for you.
ARTHUR:  You don't vote for kings.
WOMAN:   Well, 'ow did you become king then?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.207
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.207
Problem:    Netbeans: "remove" cannot delete one line. 
Solution:   Remove partial lines and whole lines properly.  Avoid a memory
	    leak.  (Xavier de Gaye)
Files:	    src/netbeans.c


*** ../vim-7.1.206/src/netbeans.c	Thu May 10 18:40:48 2007
--- src/netbeans.c	Sat Jan  5 18:03:24 2008
***************
*** 1204,1209 ****
--- 1204,1257 ----
      return result;
  }
  
+ /*
+  * Remove from "first" byte to "last" byte (inclusive), at line "lnum" of the
+  * current buffer.  Remove to end of line when "last" is MAXCOL.
+  */
+     static void
+ nb_partialremove(linenr_T lnum, colnr_T first, colnr_T last)
+ {
+     char_u *oldtext, *newtext;
+     int oldlen;
+     int lastbyte = last;
+ 
+     oldtext = ml_get(lnum);
+     oldlen = STRLEN(oldtext);
+     if (first >= oldlen || oldlen == 0)  /* just in case */
+ 	return;
+     if (lastbyte >= oldlen)
+ 	lastbyte = oldlen - 1;
+     newtext = alloc(oldlen - (int)(lastbyte - first));
+     if (newtext != NULL)
+     {
+ 	mch_memmove(newtext, oldtext, first);
+ 	mch_memmove(newtext + first, oldtext + lastbyte + 1, STRLEN(oldtext + lastbyte + 1) + 1);
+ 	nbdebug(("    NEW LINE %d: %s\n", lnum, newtext));
+ 	ml_replace(lnum, newtext, FALSE);
+     }
+ }
+ 
+ /*
+  * Replace the "first" line with the concatenation of the "first" and
+  * the "other" line. The "other" line is not removed.
+  */
+     static void
+ nb_joinlines(linenr_T first, linenr_T other)
+ {
+     int len_first, len_other;
+     char_u *p;
+ 
+     len_first = STRLEN(ml_get(first));
+     len_other = STRLEN(ml_get(other));
+     p = alloc((unsigned)(len_first + len_other + 1));
+     if (p != NULL)
+     {
+       mch_memmove(p, ml_get(first), len_first);
+       mch_memmove(p + len_first, ml_get(other), len_other + 1);
+       ml_replace(first, p, FALSE);
+     }
+ }
+ 
  #define SKIP_STOP 2
  #define streq(a,b) (strcmp(a,b) == 0)
  static int needupdate = 0;
***************
*** 1371,1376 ****
--- 1419,1426 ----
  	    long count;
  	    pos_T first, last;
  	    pos_T *pos;
+ 	    pos_T *next;
+ 	    linenr_T del_from_lnum, del_to_lnum;  /* lines to be deleted as a whole */
  	    int oldFire = netbeansFireChanges;
  	    int oldSuppress = netbeansSuppressNoLines;
  	    int wasChanged;
***************
*** 1420,1444 ****
  		}
  		last = *pos;
  		nbdebug(("    LAST POS: line %d, col %d\n", last.lnum, last.col));
! 		curwin->w_cursor = first;
  		doupdate = 1;
  
! 		/* keep part of first line */
! 		if (first.lnum == last.lnum && first.col != last.col)
  		{
! 		    /* deletion is within one line */
! 		    char_u *p = ml_get(first.lnum);
! 		    mch_memmove(p + first.col, p + last.col + 1, STRLEN(p + last.col) + 1);
! 		    nbdebug(("    NEW LINE %d: %s\n", first.lnum, p));
! 		    ml_replace(first.lnum, p, TRUE);
  		}
  
! 		if (first.lnum < last.lnum)
  		{
  		    int i;
  
  		    /* delete signs from the lines being deleted */
! 		    for (i = first.lnum; i <= last.lnum; i++)
  		    {
  			int id = buf_findsign_id(buf->bufp, (linenr_T)i);
  			if (id > 0)
--- 1470,1544 ----
  		}
  		last = *pos;
  		nbdebug(("    LAST POS: line %d, col %d\n", last.lnum, last.col));
! 		del_from_lnum = first.lnum;
! 		del_to_lnum = last.lnum;
  		doupdate = 1;
  
! 		/* Get the position of the first byte after the deleted
! 		 * section.  "next" is NULL when deleting to the end of the
! 		 * file. */
! 		next = off2pos(buf->bufp, off + count);
! 
! 		/* Remove part of the first line. */
! 		if (first.col != 0 || (next != NULL && first.lnum == next->lnum))
  		{
! 		    if (first.lnum != last.lnum
! 			    || (next != NULL && first.lnum != next->lnum))
! 		    {
! 			/* remove to the end of the first line */
! 			nb_partialremove(first.lnum, first.col,
! 							     (colnr_T)MAXCOL);
! 			if (first.lnum == last.lnum)
! 			{
! 			    /* Partial line to remove includes the end of
! 			     * line.  Join the line with the next one, have
! 			     * the next line deleted below. */
! 			    nb_joinlines(first.lnum, next->lnum);
! 			    del_to_lnum = next->lnum;
! 			}
! 		    }
! 		    else
! 		    {
! 			/* remove within one line */
! 			nb_partialremove(first.lnum, first.col, last.col);
! 		    }
! 		    ++del_from_lnum;  /* don't delete the first line */
! 		}
! 
! 		/* Remove part of the last line. */
! 		if (first.lnum != last.lnum && next != NULL
! 			&& next->col != 0 && last.lnum == next->lnum)
! 		{
! 		    nb_partialremove(last.lnum, 0, last.col);
! 		    if (del_from_lnum > first.lnum)
! 		    {
! 			/* Join end of last line to start of first line; last
! 			 * line is deleted below. */
! 			nb_joinlines(first.lnum, last.lnum);
! 		    }
! 		    else
! 			/* First line is deleted as a whole, keep the last
! 			 * line. */
! 			--del_to_lnum;
  		}
  
! 		/* First is partial line; last line to remove includes
! 		 * the end of line; join first line to line following last
! 		 * line; line following last line is deleted below. */
! 		if (first.lnum != last.lnum && del_from_lnum > first.lnum
! 			&& next != NULL && last.lnum != next->lnum)
! 		{
! 		    nb_joinlines(first.lnum, next->lnum);
! 		    del_to_lnum = next->lnum;
! 		}
! 
! 		/* Delete whole lines if there are any. */
! 		if (del_to_lnum >= del_from_lnum)
  		{
  		    int i;
  
  		    /* delete signs from the lines being deleted */
! 		    for (i = del_from_lnum; i <= del_to_lnum; i++)
  		    {
  			int id = buf_findsign_id(buf->bufp, (linenr_T)i);
  			if (id > 0)
***************
*** 1450,1459 ****
  			    nbdebug(("    No sign on line %d\n", i));
  		    }
  
! 		    /* delete whole lines */
! 		    nbdebug(("    Deleting lines %d through %d\n", first.lnum, last.lnum));
! 		    del_lines(last.lnum - first.lnum + 1, FALSE);
  		}
  		buf->bufp->b_changed = wasChanged; /* logically unchanged */
  		netbeansFireChanges = oldFire;
  		netbeansSuppressNoLines = oldSuppress;
--- 1550,1564 ----
  			    nbdebug(("    No sign on line %d\n", i));
  		    }
  
! 		    nbdebug(("    Deleting lines %d through %d\n", del_from_lnum, del_to_lnum));
! 		    curwin->w_cursor.lnum = del_from_lnum;
! 		    curwin->w_cursor.col = 0;
! 		    del_lines(del_to_lnum - del_from_lnum + 1, FALSE);
  		}
+ 
+ 		/* Leave cursor at first deleted byte. */
+ 		curwin->w_cursor = first;
+ 		check_cursor_lnum();
  		buf->bufp->b_changed = wasChanged; /* logically unchanged */
  		netbeansFireChanges = oldFire;
  		netbeansSuppressNoLines = oldSuppress;
***************
*** 2374,2381 ****
   * the current buffer as "buf".
   */
      static void
! nb_set_curbuf(buf)
!     buf_T *buf;
  {
      if (curbuf != buf && buf_jump_open_win(buf) == NULL)
  	set_curbuf(buf, DOBUF_GOTO);
--- 2479,2485 ----
   * the current buffer as "buf".
   */
      static void
! nb_set_curbuf(buf_T *buf)
  {
      if (curbuf != buf && buf_jump_open_win(buf) == NULL)
  	set_curbuf(buf, DOBUF_GOTO);
*** ../vim-7.1.206/src/version.c	Sat Jan  5 13:58:48 2008
--- src/version.c	Sat Jan  5 18:06:04 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     207,
  /**/

-- 
Q:   How many hardware engineers does it take to change a lightbulb?
A:   None.  We'll fix it in software.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.208
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.208
Problem:    On Alpha get an unaligned access error.
Solution:   Store the dictitem pointer before using it. (Matthew Luckie)
Files:	    src/eval.c


*** ../vim-7.1.207/src/eval.c	Sat Jan  5 13:34:01 2008
--- src/eval.c	Sat Jan  5 13:22:52 2008
***************
*** 3407,3412 ****
--- 3407,3413 ----
      hashtab_T	*ht;
      hashitem_T	*hi;
      char_u	*varname;
+     dictitem_T	*di;
  
      ht = find_var_ht(name, &varname);
      if (ht != NULL && *varname != NUL)
***************
*** 3414,3422 ****
  	hi = hash_find(ht, varname);
  	if (!HASHITEM_EMPTY(hi))
  	{
! 	    if (var_check_fixed(HI2DI(hi)->di_flags, name))
! 		return FAIL;
! 	    if (var_check_ro(HI2DI(hi)->di_flags, name))
  		return FAIL;
  	    delete_var(ht, hi);
  	    return OK;
--- 3415,3423 ----
  	hi = hash_find(ht, varname);
  	if (!HASHITEM_EMPTY(hi))
  	{
! 	    di = HI2DI(hi);
! 	    if (var_check_fixed(di->di_flags, name)
! 		    || var_check_ro(di->di_flags, name))
  		return FAIL;
  	    delete_var(ht, hi);
  	    return OK;
*** ../vim-7.1.207/src/version.c	Sat Jan  5 18:06:33 2008
--- src/version.c	Sat Jan  5 22:14:17 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     208,
  /**/

-- 
ARTHUR:  Bloody peasant!
DENNIS:  Oh, what a give away.  Did you here that, did you here that, eh?
         That's what I'm on about -- did you see him repressing me, you saw it
         didn't you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.209
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.209
Problem:    GTK: When using the netrw plugin and doing ":gui" Vim hangs.
Solution:   Stop getting a selection after three seconds.  This is a hack.
Files:	    src/gui_gtk_x11.c


*** ../vim-7.1.208/src/gui_gtk_x11.c	Fri Oct 19 14:32:50 2007
--- src/gui_gtk_x11.c	Sun Jan  6 15:15:52 2008
***************
*** 6660,6665 ****
--- 6660,6666 ----
      unsigned	i;
      int		nbytes;
      char_u	*buffer;
+     time_t	start;
  
      for (i = 0; i < N_SELECTION_TARGETS; ++i)
      {
***************
*** 6670,6676 ****
  			      cbd->gtk_sel_atom, target,
  			      (guint32)GDK_CURRENT_TIME);
  
! 	while (received_selection == RS_NONE)
  	    gtk_main();	/* wait for selection_received_cb */
  
  	if (received_selection != RS_FAIL)
--- 6671,6681 ----
  			      cbd->gtk_sel_atom, target,
  			      (guint32)GDK_CURRENT_TIME);
  
! 	/* Hack: Wait up to three seconds for the selection.  A hang was
! 	 * noticed here when using the netrw plugin combined with ":gui"
! 	 * during the FocusGained event. */
! 	start = time(NULL);
! 	while (received_selection == RS_NONE && time(NULL) < start + 3)
  	    gtk_main();	/* wait for selection_received_cb */
  
  	if (received_selection != RS_FAIL)
*** ../vim-7.1.208/src/version.c	Sat Jan  5 22:15:21 2008
--- src/version.c	Sun Jan  6 15:14:48 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     209,
  /**/

-- 
BLACK KNIGHT:  I move for no man.
ARTHUR:        So be it!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's left arm off]
ARTHUR:        Now stand aside, worthy adversary.
BLACK KNIGHT:  'Tis but a scratch.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.210
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.210
Problem:    Listing mapping for 0xdb fails when 'encoding' is utf-8. (Tony
	    Mechelynck)
Solution:   Recognize K_SPECIAL KS_EXTRA KE_CSI as a CSI byte.
Files:	    src/mbyte.c


*** ../vim-7.1.209/src/mbyte.c	Fri Jan  4 17:46:46 2008
--- src/mbyte.c	Sun Jan  6 17:13:51 2008
***************
*** 2863,2877 ****
  	    buf[m++] = K_SPECIAL;
  	    n += 2;
  	}
  # ifdef FEAT_GUI
! 	else if (str[n] == CSI
  		&& str[n + 1] == KS_EXTRA
  		&& str[n + 2] == (int)KE_CSI)
  	{
  	    buf[m++] = CSI;
  	    n += 2;
  	}
- # endif
  	else if (str[n] == K_SPECIAL
  # ifdef FEAT_GUI
  		|| str[n] == CSI
--- 2882,2898 ----
  	    buf[m++] = K_SPECIAL;
  	    n += 2;
  	}
+ 	else if ((str[n] == K_SPECIAL
  # ifdef FEAT_GUI
! 		    || str[n] == CSI
! # endif
! 		 )
  		&& str[n + 1] == KS_EXTRA
  		&& str[n + 2] == (int)KE_CSI)
  	{
  	    buf[m++] = CSI;
  	    n += 2;
  	}
  	else if (str[n] == K_SPECIAL
  # ifdef FEAT_GUI
  		|| str[n] == CSI
*** ../vim-7.1.209/src/version.c	Sun Jan  6 15:16:12 2008
--- src/version.c	Sun Jan  6 17:17:25 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     210,
  /**/

-- 
ARTHUR:        A scratch?  Your arm's off!
BLACK KNIGHT:  No, it isn't.
ARTHUR:        Well, what's that then?
BLACK KNIGHT:  I've had worse.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.211
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.211
Problem:    The matchparen plugin may take an unexpected amount of time, so
	    that it looks like Vim hangs.
Solution:   Add a timeout to searchpair(), searchpairpos(), search() and
	    searchpos().  Use half a second timeout in the plugin.
Files:	    runtime/doc/eval.txt, runtime/plugin/matchparen.vim, src/edit.c,
	    src/eval.c, src/ex_cmds2.c, src/ex_docmd.c, src/normal.c,
	    src/proto/eval.pro, src/proto/ex_cmds2.pro, src/proto/search.pro,
	    src/search.c


*** ../vim-7.1.210/runtime/doc/eval.txt	Sat Jan  5 13:34:01 2008
--- runtime/doc/eval.txt	Sun Jan  6 16:27:33 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 04
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 06
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1733,1746 ****
  repeat( {expr}, {count})	String	repeat {expr} {count} times
  resolve( {filename})		String	get filename a shortcut points to
  reverse( {list})		List	reverse {list} in-place
! search( {pattern} [, {flags}])	Number	search for {pattern}
  searchdecl({name} [, {global} [, {thisblock}]])
  				Number  search for variable declaration
! searchpair( {start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
  				Number	search for other end of start/end pair
! searchpairpos( {start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
  				List	search for other end of start/end pair
! searchpos( {pattern} [, {flags} [, {stopline}]])
  				List	search for {pattern}
  server2client( {clientid}, {string})
  				Number	send reply string
--- 1733,1747 ----
  repeat( {expr}, {count})	String	repeat {expr} {count} times
  resolve( {filename})		String	get filename a shortcut points to
  reverse( {list})		List	reverse {list} in-place
! search( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
! 				Number	search for {pattern}
  searchdecl({name} [, {global} [, {thisblock}]])
  				Number  search for variable declaration
! searchpair( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
  				Number	search for other end of start/end pair
! searchpairpos( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
  				List	search for other end of start/end pair
! searchpos( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
  				List	search for {pattern}
  server2client( {clientid}, {string})
  				Number	send reply string
***************
*** 4212,4218 ****
  		If you want a list to remain unmodified make a copy first: >
  			:let revlist = reverse(copy(mylist))
  
! search({pattern} [, {flags} [, {stopline}]])			*search()*
  		Search for regexp pattern {pattern}.  The search starts at the
  		cursor position (you can use |cursor()| to set it).
  
--- 4216,4222 ----
  		If you want a list to remain unmodified make a copy first: >
  			:let revlist = reverse(copy(mylist))
  
! search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
  		Search for regexp pattern {pattern}.  The search starts at the
  		cursor position (you can use |cursor()| to set it).
  
***************
*** 4240,4245 ****
--- 4244,4257 ----
  			let end = search('END', '', line("w$"))
  <		When {stopline} is used and it is not zero this also implies
  		that the search does not wrap around the end of the file.
+ 		A zero value is equal to not giving the argument.
+ 
+ 		When the {timeout} argument is given the search stops when
+ 		more than this many milli seconds have passed.  Thus when
+ 		{timeout} is 500 the search stops after half a second.
+ 		The value must not be negative.  A zero value is like not
+ 		giving the argument.
+ 		{only available when compiled with the +reltime feature}
  
  		If there is no match a 0 is returned and the cursor doesn't
  		move.  No error message is given.
***************
*** 4302,4308 ****
  			endif
  <
  							*searchpair()*
! searchpair({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
  		Search for the match of a nested start-end pair.  This can be
  		used to find the "endif" that matches an "if", while other
  		if/endif pairs in between are ignored.
--- 4314,4321 ----
  			endif
  <
  							*searchpair()*
! searchpair({start}, {middle}, {end} [, {flags} [, {skip}
! 				[, {stopline} [, {timeout}]]]])
  		Search for the match of a nested start-end pair.  This can be
  		used to find the "endif" that matches an "if", while other
  		if/endif pairs in between are ignored.
***************
*** 4337,4343 ****
  		When evaluating {skip} causes an error the search is aborted
  		and -1 returned.
  
! 		For {stopline} see |search()|.
  
  		The value of 'ignorecase' is used.  'magic' is ignored, the
  		patterns are used like it's on.
--- 4350,4356 ----
  		When evaluating {skip} causes an error the search is aborted
  		and -1 returned.
  
! 		For {stopline} and {timeout} see |search()|.
  
  		The value of 'ignorecase' is used.  'magic' is ignored, the
  		patterns are used like it's on.
***************
*** 4383,4389 ****
  	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
  <
  							*searchpairpos()*
! searchpairpos({start}, {middle}, {end} [, {flags} [, {skip} [, {stopline}]]])
  		Same as searchpair(), but returns a |List| with the line and
  		column position of the match. The first element of the |List|
  		is the line number and the second element is the byte index of
--- 4396,4403 ----
  	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
  <
  							*searchpairpos()*
! searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
! 				[, {stopline} [, {timeout}]]]])
  		Same as searchpair(), but returns a |List| with the line and
  		column position of the match. The first element of the |List|
  		is the line number and the second element is the byte index of
***************
*** 4394,4400 ****
  <
  		See |match-parens| for a bigger and more useful example.
  
! searchpos({pattern} [, {flags} [, {stopline}]])		*searchpos()*
  		Same as |search()|, but returns a |List| with the line and
  		column position of the match. The first element of the |List|
  		is the line number and the second element is the byte index of
--- 4408,4414 ----
  <
  		See |match-parens| for a bigger and more useful example.
  
! searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
  		Same as |search()|, but returns a |List| with the line and
  		column position of the match. The first element of the |List|
  		is the line number and the second element is the byte index of
*** ../vim-7.1.210/runtime/plugin/matchparen.vim	Sat Aug 18 18:20:57 2007
--- runtime/plugin/matchparen.vim	Sun Jan  6 16:22:39 2008
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Aug 8
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2008 Jan 06
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 111,117 ****
  	\ '=~?  "string\\|character\\|singlequote\\|comment"'
    execute 'if' s_skip '| let s_skip = 0 | endif'
  
!   let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  
    if before > 0
      call winrestview(save_cursor)
--- 111,122 ----
  	\ '=~?  "string\\|character\\|singlequote\\|comment"'
    execute 'if' s_skip '| let s_skip = 0 | endif'
  
!   try
!     " Limit the search time to 500 msec to avoid a hang on very long lines.
!     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 500)
!   catch /E118/
!     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
!   endtry
  
    if before > 0
      call winrestview(save_cursor)
*** ../vim-7.1.210/src/edit.c	Wed Jan  2 22:08:43 2008
--- src/edit.c	Sun Jan  6 16:08:00 2008
***************
*** 4062,4068 ****
  		    found_new_match = searchit(NULL, ins_buf, pos,
  							      compl_direction,
  				 compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,
! 							RE_LAST, (linenr_T)0);
  		--msg_silent;
  		if (!compl_started)
  		{
--- 4062,4068 ----
  		    found_new_match = searchit(NULL, ins_buf, pos,
  							      compl_direction,
  				 compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,
! 						  RE_LAST, (linenr_T)0, NULL);
  		--msg_silent;
  		if (!compl_started)
  		{
*** ../vim-7.1.210/src/eval.c	Sat Jan  5 22:15:21 2008
--- src/eval.c	Sun Jan  6 16:37:42 2008
***************
*** 7213,7223 ****
      {"repeat",		2, 2, f_repeat},
      {"resolve",		1, 1, f_resolve},
      {"reverse",		1, 1, f_reverse},
!     {"search",		1, 3, f_search},
      {"searchdecl",	1, 3, f_searchdecl},
!     {"searchpair",	3, 6, f_searchpair},
!     {"searchpairpos",	3, 6, f_searchpairpos},
!     {"searchpos",	1, 3, f_searchpos},
      {"server2client",	2, 2, f_server2client},
      {"serverlist",	0, 0, f_serverlist},
      {"setbufvar",	3, 3, f_setbufvar},
--- 7213,7223 ----
      {"repeat",		2, 2, f_repeat},
      {"resolve",		1, 1, f_resolve},
      {"reverse",		1, 1, f_reverse},
!     {"search",		1, 4, f_search},
      {"searchdecl",	1, 3, f_searchdecl},
!     {"searchpair",	3, 7, f_searchpair},
!     {"searchpairpos",	3, 7, f_searchpairpos},
!     {"searchpos",	1, 4, f_searchpos},
      {"server2client",	2, 2, f_server2client},
      {"serverlist",	0, 0, f_serverlist},
      {"setbufvar",	3, 3, f_setbufvar},
***************
*** 14020,14025 ****
--- 14020,14029 ----
      int		dir;
      int		retval = 0;	/* default: FAIL */
      long	lnum_stop = 0;
+     proftime_T	tm;
+ #ifdef FEAT_RELTIME
+     long	time_limit = 0;
+ #endif
      int		options = SEARCH_KEEP;
      int		subpatnum;
  
***************
*** 14033,14047 ****
      if (flags & SP_END)
  	options |= SEARCH_END;
  
!     /* Optional extra argument: line number to stop searching. */
!     if (argvars[1].v_type != VAR_UNKNOWN
! 	    && argvars[2].v_type != VAR_UNKNOWN)
      {
  	lnum_stop = get_tv_number_chk(&argvars[2], NULL);
  	if (lnum_stop < 0)
  	    goto theend;
      }
  
      /*
       * This function does not accept SP_REPEAT and SP_RETCOUNT flags.
       * Check to make sure only those flags are set.
--- 14037,14063 ----
      if (flags & SP_END)
  	options |= SEARCH_END;
  
!     /* Optional arguments: line number to stop searching and timeout. */
!     if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN)
      {
  	lnum_stop = get_tv_number_chk(&argvars[2], NULL);
  	if (lnum_stop < 0)
  	    goto theend;
+ #ifdef FEAT_RELTIME
+ 	if (argvars[3].v_type != VAR_UNKNOWN)
+ 	{
+ 	    time_limit = get_tv_number_chk(&argvars[3], NULL);
+ 	    if (time_limit < 0)
+ 		goto theend;
+ 	}
+ #endif
      }
  
+ #ifdef FEAT_RELTIME
+     /* Set the time limit, if there is one. */
+     profile_setlimit(time_limit, &tm);
+ #endif
+ 
      /*
       * This function does not accept SP_REPEAT and SP_RETCOUNT flags.
       * Check to make sure only those flags are set.
***************
*** 14057,14063 ****
  
      pos = save_cursor = curwin->w_cursor;
      subpatnum = searchit(curwin, curbuf, &pos, dir, pat, 1L,
! 				     options, RE_SEARCH, (linenr_T)lnum_stop);
      if (subpatnum != FAIL)
      {
  	if (flags & SP_SUBPAT)
--- 14073,14079 ----
  
      pos = save_cursor = curwin->w_cursor;
      subpatnum = searchit(curwin, curbuf, &pos, dir, pat, 1L,
! 				options, RE_SEARCH, (linenr_T)lnum_stop, &tm);
      if (subpatnum != FAIL)
      {
  	if (flags & SP_SUBPAT)
***************
*** 14147,14152 ****
--- 14163,14169 ----
      char_u	nbuf3[NUMBUFLEN];
      int		retval = 0;		/* default: FAIL */
      long	lnum_stop = 0;
+     long	time_limit = 0;
  
      /* Get the three pattern arguments: start, middle, end. */
      spat = get_tv_string_chk(&argvars[0]);
***************
*** 14182,14194 ****
  	    lnum_stop = get_tv_number_chk(&argvars[5], NULL);
  	    if (lnum_stop < 0)
  		goto theend;
  	}
      }
      if (skip == NULL)
  	goto theend;	    /* type error */
  
      retval = do_searchpair(spat, mpat, epat, dir, skip, flags,
! 							match_pos, lnum_stop);
  
  theend:
      p_ws = save_p_ws;
--- 14199,14219 ----
  	    lnum_stop = get_tv_number_chk(&argvars[5], NULL);
  	    if (lnum_stop < 0)
  		goto theend;
+ #ifdef FEAT_RELTIME
+ 	    if (argvars[6].v_type != VAR_UNKNOWN)
+ 	    {
+ 		time_limit = get_tv_number_chk(&argvars[6], NULL);
+ 		if (time_limit < 0)
+ 		    goto theend;
+ 	    }
+ #endif
  	}
      }
      if (skip == NULL)
  	goto theend;	    /* type error */
  
      retval = do_searchpair(spat, mpat, epat, dir, skip, flags,
! 					    match_pos, lnum_stop, time_limit);
  
  theend:
      p_ws = save_p_ws;
***************
*** 14240,14246 ****
   * Returns 0 or -1 for no match,
   */
      long
! do_searchpair(spat, mpat, epat, dir, skip, flags, match_pos, lnum_stop)
      char_u	*spat;	    /* start pattern */
      char_u	*mpat;	    /* middle pattern */
      char_u	*epat;	    /* end pattern */
--- 14265,14272 ----
   * Returns 0 or -1 for no match,
   */
      long
! do_searchpair(spat, mpat, epat, dir, skip, flags, match_pos,
! 							lnum_stop, time_limit)
      char_u	*spat;	    /* start pattern */
      char_u	*mpat;	    /* middle pattern */
      char_u	*epat;	    /* end pattern */
***************
*** 14249,14254 ****
--- 14275,14281 ----
      int		flags;	    /* SP_SETPCMARK and other SP_ values */
      pos_T	*match_pos;
      linenr_T	lnum_stop;  /* stop at this line if not zero */
+     long	time_limit; /* stop after this many msec */
  {
      char_u	*save_cpo;
      char_u	*pat, *pat2 = NULL, *pat3 = NULL;
***************
*** 14263,14273 ****
--- 14290,14306 ----
      int		nest = 1;
      int		err;
      int		options = SEARCH_KEEP;
+     proftime_T	tm;
  
      /* Make 'cpoptions' empty, the 'l' flag should not be used here. */
      save_cpo = p_cpo;
      p_cpo = (char_u *)"";
  
+ #ifdef FEAT_RELTIME
+     /* Set the time limit, if there is one. */
+     profile_setlimit(time_limit, &tm);
+ #endif
+ 
      /* Make two search patterns: start/end (pat2, for in nested pairs) and
       * start/middle/end (pat3, for the top pair). */
      pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
***************
*** 14291,14297 ****
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
! 					       options, RE_SEARCH, lnum_stop);
  	if (n == FAIL || (firstpos.lnum != 0 && equalpos(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
--- 14324,14330 ----
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
! 					   options, RE_SEARCH, lnum_stop, &tm);
  	if (n == FAIL || (firstpos.lnum != 0 && equalpos(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
*** ../vim-7.1.210/src/ex_cmds2.c	Fri Jan  4 16:00:10 2008
--- src/ex_cmds2.c	Sun Jan  6 18:22:28 2008
***************
*** 895,913 ****
      sprintf(buf, "%10.6lf", (double)tm->QuadPart / (double)fr.QuadPart);
  # else
      sprintf(buf, "%3ld.%06ld", (long)tm->tv_sec, (long)tm->tv_usec);
! #endif
      return buf;
  }
  
! # endif  /* FEAT_PROFILE || FEAT_RELTIME */
  
- # if defined(FEAT_PROFILE) || defined(PROTO)
  /*
!  * Functions for profiling.
   */
! static void script_do_profile __ARGS((scriptitem_T *si));
! static void script_dump_profile __ARGS((FILE *fd));
! static proftime_T prof_wait_time;
  
  /*
   * Set the time in "tm" to zero.
--- 895,955 ----
      sprintf(buf, "%10.6lf", (double)tm->QuadPart / (double)fr.QuadPart);
  # else
      sprintf(buf, "%3ld.%06ld", (long)tm->tv_sec, (long)tm->tv_usec);
! # endif
      return buf;
  }
  
! /*
!  * Put the time "msec" past now in "tm".
!  */
!     void
! profile_setlimit(msec, tm)
!     long	msec;
!     proftime_T	*tm;
! {
!     if (msec <= 0)   /* no limit */
! 	profile_zero(tm);
!     else
!     {
! # ifdef WIN3264
! 	LARGE_INTEGER   fr;
! 
! 	QueryPerformanceCounter(tm);
! 	QueryPerformanceFrequency(&fr);
! 	tm->QuadPart +=  (double)msec / 1000.0 * (double)fr.QuadPart;
! # else
! 	long	    usec;
! 
! 	gettimeofday(tm, NULL);
! 	usec = (long)tm->tv_usec + (long)msec * 1000;
! 	tm->tv_usec = usec % 1000000L;
! 	tm->tv_sec += usec / 1000000L;
! # endif
!     }
! }
  
  /*
!  * Return TRUE if the current time is past "tm".
   */
!     int
! profile_passed_limit(tm)
!     proftime_T	*tm;
! {
!     proftime_T	now;
! 
! # ifdef WIN3264
!     if (tm->QuadPart == 0)  /* timer was not set */
! 	return FALSE;
!     QueryPerformanceCounter(&now);
!     return (now.QuadPart > tm->QuadPart);
! # else
!     if (tm->tv_sec == 0)    /* timer was not set */
! 	return FALSE;
!     gettimeofday(&now, NULL);
!     return (now.tv_sec > tm->tv_sec
! 	    || (now.tv_sec == tm->tv_sec && now.tv_usec > tm->tv_usec));
! # endif
! }
  
  /*
   * Set the time in "tm" to zero.
***************
*** 923,928 ****
--- 965,980 ----
      tm->tv_sec = 0;
  # endif
  }
+ 
+ # endif  /* FEAT_PROFILE || FEAT_RELTIME */
+ 
+ # if defined(FEAT_PROFILE) || defined(PROTO)
+ /*
+  * Functions for profiling.
+  */
+ static void script_do_profile __ARGS((scriptitem_T *si));
+ static void script_dump_profile __ARGS((FILE *fd));
+ static proftime_T prof_wait_time;
  
  /*
   * Add the time "tm2" to "tm".
*** ../vim-7.1.210/src/ex_docmd.c	Fri Jan  4 16:00:10 2008
--- src/ex_docmd.c	Sun Jan  6 16:08:29 2008
***************
*** 3979,3985 ****
  					*cmd == '?' ? BACKWARD : FORWARD,
  					(char_u *)"", 1L,
  					SEARCH_MSG + SEARCH_START,
! 						      i, (linenr_T)0) != FAIL)
  				lnum = pos.lnum;
  			    else
  			    {
--- 3980,3986 ----
  					*cmd == '?' ? BACKWARD : FORWARD,
  					(char_u *)"", 1L,
  					SEARCH_MSG + SEARCH_START,
! 						i, (linenr_T)0, NULL) != FAIL)
  				lnum = pos.lnum;
  			    else
  			    {
*** ../vim-7.1.210/src/normal.c	Sat Jan  5 13:34:01 2008
--- src/normal.c	Sun Jan  6 16:08:54 2008
***************
*** 4194,4200 ****
      for (;;)
      {
  	t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD,
! 				  pat, 1L, searchflags, RE_LAST, (linenr_T)0);
  	if (curwin->w_cursor.lnum >= old_pos.lnum)
  	    t = FAIL;	/* match after start is failure too */
  
--- 4194,4200 ----
      for (;;)
      {
  	t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD,
! 			    pat, 1L, searchflags, RE_LAST, (linenr_T)0, NULL);
  	if (curwin->w_cursor.lnum >= old_pos.lnum)
  	    t = FAIL;	/* match after start is failure too */
  
*** ../vim-7.1.210/src/proto/eval.pro	Sun May  6 15:18:09 2007
--- src/proto/eval.pro	Sun Jan  6 15:55:47 2008
***************
*** 54,60 ****
  long get_dict_number __ARGS((dict_T *d, char_u *key));
  char_u *get_function_name __ARGS((expand_T *xp, int idx));
  char_u *get_expr_name __ARGS((expand_T *xp, int idx));
! long do_searchpair __ARGS((char_u *spat, char_u *mpat, char_u *epat, int dir, char_u *skip, int flags, pos_T *match_pos, linenr_T lnum_stop));
  void set_vim_var_nr __ARGS((int idx, long val));
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
--- 54,60 ----
  long get_dict_number __ARGS((dict_T *d, char_u *key));
  char_u *get_function_name __ARGS((expand_T *xp, int idx));
  char_u *get_expr_name __ARGS((expand_T *xp, int idx));
! long do_searchpair __ARGS((char_u *spat, char_u *mpat, char_u *epat, int dir, char_u *skip, int flags, pos_T *match_pos, linenr_T lnum_stop, long time_limit));
  void set_vim_var_nr __ARGS((int idx, long val));
  long get_vim_var_nr __ARGS((int idx));
  char_u *get_vim_var_str __ARGS((int idx));
*** ../vim-7.1.210/src/proto/ex_cmds2.pro	Sat May  5 20:21:13 2007
--- src/proto/ex_cmds2.pro	Sun Jan  6 16:42:24 2008
***************
*** 14,19 ****
--- 14,21 ----
  void profile_end __ARGS((proftime_T *tm));
  void profile_sub __ARGS((proftime_T *tm, proftime_T *tm2));
  char *profile_msg __ARGS((proftime_T *tm));
+ void profile_setlimit __ARGS((long msec, proftime_T *tm));
+ int profile_passed_limit __ARGS((proftime_T *tm));
  void profile_zero __ARGS((proftime_T *tm));
  void profile_add __ARGS((proftime_T *tm, proftime_T *tm2));
  void profile_self __ARGS((proftime_T *self, proftime_T *total, proftime_T *children));
*** ../vim-7.1.210/src/proto/search.pro	Wed Aug  8 22:48:16 2007
--- src/proto/search.pro	Sun Jan  6 16:11:53 2008
***************
*** 10,16 ****
  void reset_search_dir __ARGS((void));
  void set_last_search_pat __ARGS((char_u *s, int idx, int magic, int setlast));
  void last_pat_prog __ARGS((regmmatch_T *regmatch));
! int searchit __ARGS((win_T *win, buf_T *buf, pos_T *pos, int dir, char_u *pat, long count, int options, int pat_use, linenr_T stop_lnum));
  int do_search __ARGS((oparg_T *oap, int dirc, char_u *pat, long count, int options));
  int search_for_exact_line __ARGS((buf_T *buf, pos_T *pos, int dir, char_u *pat));
  int searchc __ARGS((cmdarg_T *cap, int t_cmd));
--- 10,16 ----
  void reset_search_dir __ARGS((void));
  void set_last_search_pat __ARGS((char_u *s, int idx, int magic, int setlast));
  void last_pat_prog __ARGS((regmmatch_T *regmatch));
! int searchit __ARGS((win_T *win, buf_T *buf, pos_T *pos, int dir, char_u *pat, long count, int options, int pat_use, linenr_T stop_lnum, proftime_T *tm));
  int do_search __ARGS((oparg_T *oap, int dirc, char_u *pat, long count, int options));
  int search_for_exact_line __ARGS((buf_T *buf, pos_T *pos, int dir, char_u *pat));
  int searchc __ARGS((cmdarg_T *cap, int t_cmd));
*** ../vim-7.1.210/src/search.c	Tue Jan  1 15:42:45 2008
--- src/search.c	Sun Jan  6 18:23:37 2008
***************
*** 494,501 ****
   * When FEAT_EVAL is defined, returns the index of the first matching
   * subpattern plus one; one if there was none.
   */
      int
! searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum)
      win_T	*win;		/* window to search in; can be NULL for a
  				   buffer without a window! */
      buf_T	*buf;
--- 494,502 ----
   * When FEAT_EVAL is defined, returns the index of the first matching
   * subpattern plus one; one if there was none.
   */
+ /*ARGSUSED*/
      int
! searchit(win, buf, pos, dir, pat, count, options, pat_use, stop_lnum, tm)
      win_T	*win;		/* window to search in; can be NULL for a
  				   buffer without a window! */
      buf_T	*buf;
***************
*** 506,511 ****
--- 507,513 ----
      int		options;
      int		pat_use;	/* which pattern to use when "pat" is empty */
      linenr_T	stop_lnum;	/* stop after this line number when != 0 */
+     proftime_T	*tm;		/* timeout limit or NULL */
  {
      int		found;
      linenr_T	lnum;		/* no init to shut up Apollo cc */
***************
*** 594,599 ****
--- 596,606 ----
  		if (stop_lnum != 0 && (dir == FORWARD
  				       ? lnum > stop_lnum : lnum < stop_lnum))
  		    break;
+ #ifdef FEAT_RELTIME
+ 		/* Stop after passing the "tm" time limit. */
+ 		if (tm != NULL && profile_passed_limit(tm))
+ 		    break;
+ #endif
  
  		/*
  		 * Look for a match somewhere in line "lnum".
***************
*** 1249,1255 ****
  		       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS
  			+ SEARCH_MSG + SEARCH_START
  			+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),
! 		RE_LAST, (linenr_T)0);
  
  	if (dircp != NULL)
  	    *dircp = dirc;	/* restore second '/' or '?' for normal_cmd() */
--- 1256,1262 ----
  		       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS
  			+ SEARCH_MSG + SEARCH_START
  			+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),
! 		RE_LAST, (linenr_T)0, NULL);
  
  	if (dircp != NULL)
  	    *dircp = dirc;	/* restore second '/' or '?' for normal_cmd() */
***************
*** 3780,3786 ****
  	if (do_searchpair((char_u *)"<[^ \t>/!]\\+\\%(\\_s\\_[^>]\\{-}[^/]>\\|$\\|\\_s\\=>\\)",
  		    (char_u *)"",
  		    (char_u *)"</[^>]*>", BACKWARD, (char_u *)"", 0,
! 						      NULL, (linenr_T)0) <= 0)
  	{
  	    curwin->w_cursor = old_pos;
  	    goto theend;
--- 3787,3793 ----
  	if (do_searchpair((char_u *)"<[^ \t>/!]\\+\\%(\\_s\\_[^>]\\{-}[^/]>\\|$\\|\\_s\\=>\\)",
  		    (char_u *)"",
  		    (char_u *)"</[^>]*>", BACKWARD, (char_u *)"", 0,
! 						  NULL, (linenr_T)0, 0L) <= 0)
  	{
  	    curwin->w_cursor = old_pos;
  	    goto theend;
***************
*** 3814,3820 ****
      sprintf((char *)epat, "</%.*s>\\c", len, p);
  
      r = do_searchpair(spat, (char_u *)"", epat, FORWARD, (char_u *)"",
! 						       0, NULL, (linenr_T)0);
  
      vim_free(spat);
      vim_free(epat);
--- 3821,3827 ----
      sprintf((char *)epat, "</%.*s>\\c", len, p);
  
      r = do_searchpair(spat, (char_u *)"", epat, FORWARD, (char_u *)"",
! 						    0, NULL, (linenr_T)0, 0L);
  
      vim_free(spat);
      vim_free(epat);
*** ../vim-7.1.210/src/version.c	Sun Jan  6 17:18:16 2008
--- src/version.c	Sun Jan  6 20:00:03 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     211,
  /**/

-- 
No letters of the alphabet were harmed in the creation of this message.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.212
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.212
Problem:    Accessing a byte before a line.
Solution:   Check that the column is 1 or more. (Dominuque Pelle)
Files:	    src/edit.c


*** ../vim-7.1.211/src/edit.c	Sun Jan  6 20:05:36 2008
--- src/edit.c	Mon Jan  7 22:31:36 2008
***************
*** 8452,8457 ****
--- 8452,8458 ----
  	if (	   mode == BACKSPACE_CHAR
  		&& ((p_sta && in_indent)
  		    || (curbuf->b_p_sts != 0
+ 			&& curwin->w_cursor.col > 0
  			&& (*(ml_get_cursor() - 1) == TAB
  			    || (*(ml_get_cursor() - 1) == ' '
  				&& (!*inserted_space_p
*** ../vim-7.1.211/src/version.c	Sun Jan  6 20:05:36 2008
--- src/version.c	Wed Jan  9 10:11:49 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     212,
  /**/

-- 
CRONE:  Who sent you?
ARTHUR: The Knights Who Say Ni!
CRONE:  Aaaagh!  (she looks around in rear) No!  We have no shrubberies here.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.213
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.213
Problem:    A ":tabedit" command that results in the "swap file exists" dialog
	    and selecting "abort" doesn't close the new tab. (Al Budden)
Solution:   Pass "old_curwin" to do_exedit().
Files:	    src/ex_docmd.c


*** ../vim-7.1.212/src/ex_docmd.c	Sun Jan  6 20:05:36 2008
--- src/ex_docmd.c	Wed Jan  9 20:11:13 2008
***************
*** 7126,7132 ****
  			 : eap->addr_count == 0 ? 0
  					       : (int)eap->line2 + 1) != FAIL)
  	{
! 	    do_exedit(eap, NULL);
  
  	    /* set the alternate buffer for the window we came from */
  	    if (curwin != old_curwin
--- 7127,7133 ----
  			 : eap->addr_count == 0 ? 0
  					       : (int)eap->line2 + 1) != FAIL)
  	{
! 	    do_exedit(eap, old_curwin);
  
  	    /* set the alternate buffer for the window we came from */
  	    if (curwin != old_curwin
*** ../vim-7.1.212/src/version.c	Wed Jan  9 10:13:24 2008
--- src/version.c	Wed Jan  9 20:29:09 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     213,
  /**/

-- 
Q: What do you call a fish without an eye?
A: fsh!
Q: What do you call a deer with no eyes?
A: no eye deer.
Q: What do you call a deer with no eyes and no legs?
A: still no eye deer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.214
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.214
Problem:    ":1s/g\n\zs1//" deletes characters from the first line. (A Politz)
Solution:   Start replacing in the line where the match starts.
Files:	    src/ex_cmds.c


*** ../vim-7.1.213/src/ex_cmds.c	Fri Jan  4 14:52:14 2008
--- src/ex_cmds.c	Wed Jan  9 22:32:26 2008
***************
*** 4200,4206 ****
      linenr_T	old_line_count = curbuf->b_ml.ml_line_count;
      linenr_T	line2;
      long	nmatch;			/* number of lines in match */
-     linenr_T	sub_firstlnum;		/* nr of first sub line */
      char_u	*sub_firstline;		/* allocated copy of first sub line */
      int		endcolumn = FALSE;	/* cursor in last column when done */
      pos_T	old_cursor = curwin->w_cursor;
--- 4200,4205 ----
***************
*** 4447,4453 ****
  #endif
  		); ++lnum)
      {
- 	sub_firstlnum = lnum;
  	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum, (colnr_T)0);
  	if (nmatch)
  	{
--- 4446,4451 ----
***************
*** 4463,4468 ****
--- 4461,4467 ----
  	    long	nmatch_tl = 0;	/* nr of lines matched below lnum */
  	    int		do_again;	/* do it again after joining lines */
  	    int		skip_match = FALSE;
+ 	    linenr_T	sub_firstlnum;	/* nr of first sub line */
  
  	    /*
  	     * The new text is build up step by step, to avoid too much
***************
*** 4482,4489 ****
  	     *			far.
  	     * new_end		The new text, where to append new text.
  	     *
! 	     * lnum		The line number where we were looking for the
! 	     *			first match in the old line.
  	     * sub_firstlnum	The line number in the buffer where to look
  	     *			for a match.  Can be different from "lnum"
  	     *			when the pattern or substitute string contains
--- 4481,4490 ----
  	     *			far.
  	     * new_end		The new text, where to append new text.
  	     *
! 	     * lnum		The line number where we found the start of
! 	     *			the match.  Can be below the line we searched
! 	     *			when there is a \n before a \zs in the
! 	     *			pattern.
  	     * sub_firstlnum	The line number in the buffer where to look
  	     *			for a match.  Can be different from "lnum"
  	     *			when the pattern or substitute string contains
***************
*** 4507,4518 ****
  	     * updating the screen or handling a multi-line match.  The "old_"
  	     * pointers point into this copy.
  	     */
! 	    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
! 	    if (sub_firstline == NULL)
! 	    {
! 		vim_free(new_start);
! 		goto outofmem;
! 	    }
  	    copycol = 0;
  	    matchcol = 0;
  
--- 4508,4514 ----
  	     * updating the screen or handling a multi-line match.  The "old_"
  	     * pointers point into this copy.
  	     */
! 	    sub_firstlnum = lnum;
  	    copycol = 0;
  	    matchcol = 0;
  
***************
*** 4533,4538 ****
--- 4529,4556 ----
  	     */
  	    for (;;)
  	    {
+ 		/* Advance "lnum" to the line where the match starts.  The
+ 		 * match does not start in the first line when there is a line
+ 		 * break before \zs. */
+ 		if (regmatch.startpos[0].lnum > 0)
+ 		{
+ 		    lnum += regmatch.startpos[0].lnum;
+ 		    sub_firstlnum += regmatch.startpos[0].lnum;
+ 		    nmatch -= regmatch.startpos[0].lnum;
+ 		    vim_free(sub_firstline);
+ 		    sub_firstline = NULL;
+ 		}
+ 
+ 		if (sub_firstline == NULL)
+ 		{
+ 		    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
+ 		    if (sub_firstline == NULL)
+ 		    {
+ 			vim_free(new_start);
+ 			goto outofmem;
+ 		    }
+ 		}
+ 
  		/* Save the line number of the last change for the final
  		 * cursor position (just like Vi). */
  		curwin->w_cursor.lnum = lnum;
***************
*** 4638,4644 ****
  			    temp = RedrawingDisabled;
  			    RedrawingDisabled = 0;
  
! 			    search_match_lines = regmatch.endpos[0].lnum;
  			    search_match_endcol = regmatch.endpos[0].col;
  			    highlight_match = TRUE;
  
--- 4656,4663 ----
  			    temp = RedrawingDisabled;
  			    RedrawingDisabled = 0;
  
! 			    search_match_lines = regmatch.endpos[0].lnum
! 						  - regmatch.startpos[0].lnum;
  			    search_match_endcol = regmatch.endpos[0].col;
  			    highlight_match = TRUE;
  
***************
*** 4749,4755 ****
  		 * 3. substitute the string.
  		 */
  		/* get length of substitution part */
! 		sublen = vim_regsub_multi(&regmatch, sub_firstlnum,
  				    sub, sub_firstline, FALSE, p_magic, TRUE);
  
  		/* When the match included the "$" of the last line it may
--- 4768,4775 ----
  		 * 3. substitute the string.
  		 */
  		/* get length of substitution part */
! 		sublen = vim_regsub_multi(&regmatch,
! 				    sub_firstlnum - regmatch.startpos[0].lnum,
  				    sub, sub_firstline, FALSE, p_magic, TRUE);
  
  		/* When the match included the "$" of the last line it may
***************
*** 4819,4825 ****
  		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
  		new_end += i;
  
! 		(void)vim_regsub_multi(&regmatch, sub_firstlnum,
  					   sub, new_end, TRUE, p_magic, TRUE);
  		sub_nsubs++;
  		did_sub = TRUE;
--- 4839,4846 ----
  		mch_memmove(new_end, sub_firstline + copycol, (size_t)i);
  		new_end += i;
  
! 		(void)vim_regsub_multi(&regmatch,
! 				    sub_firstlnum - regmatch.startpos[0].lnum,
  					   sub, new_end, TRUE, p_magic, TRUE);
  		sub_nsubs++;
  		did_sub = TRUE;
***************
*** 4908,4917 ****
  skip:
  		/* We already know that we did the last subst when we are at
  		 * the end of the line, except that a pattern like
! 		 * "bar\|\nfoo" may match at the NUL. */
  		lastone = (skip_match
  			|| got_int
  			|| got_quit
  			|| !(do_all || do_again)
  			|| (sub_firstline[matchcol] == NUL && nmatch <= 1
  					 && !re_multiline(regmatch.regprog)));
--- 4929,4941 ----
  skip:
  		/* We already know that we did the last subst when we are at
  		 * the end of the line, except that a pattern like
! 		 * "bar\|\nfoo" may match at the NUL.  "lnum" can be below
! 		 * "line2" when there is a \zs in the pattern after a line
! 		 * break. */
  		lastone = (skip_match
  			|| got_int
  			|| got_quit
+ 			|| lnum > line2
  			|| !(do_all || do_again)
  			|| (sub_firstline[matchcol] == NUL && nmatch <= 1
  					 && !re_multiline(regmatch.regprog)));
***************
*** 4926,4937 ****
  		 * When asking the user we like to show the already replaced
  		 * text, but don't do it when "\<@=" or "\<@!" is used, it
  		 * changes what matches.
  		 */
  		if (lastone
  			|| (do_ask && !re_lookbehind(regmatch.regprog))
  			|| nmatch_tl > 0
  			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
! 				       curbuf, sub_firstlnum, matchcol)) == 0)
  		{
  		    if (new_start != NULL)
  		    {
--- 4950,4964 ----
  		 * When asking the user we like to show the already replaced
  		 * text, but don't do it when "\<@=" or "\<@!" is used, it
  		 * changes what matches.
+ 		 * When the match starts below where we start searching also
+ 		 * need to replace the line first (using \zs after \n).
  		 */
  		if (lastone
  			|| (do_ask && !re_lookbehind(regmatch.regprog))
  			|| nmatch_tl > 0
  			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
! 				       curbuf, sub_firstlnum, matchcol)) == 0
! 			|| regmatch.startpos[0].lnum > 0)
  		{
  		    if (new_start != NULL)
  		    {
***************
*** 5001,5007 ****
--- 5028,5041 ----
  		     * 5. break if there isn't another match in this line
  		     */
  		    if (nmatch <= 0)
+ 		    {
+ 			/* If the match found didn't start where we were
+ 			 * searching, do the next search in the line where we
+ 			 * found the match. */
+ 			if (nmatch == -1)
+ 			    lnum -= regmatch.startpos[0].lnum;
  			break;
+ 		    }
  		}
  
  		line_breakcheck();
*** ../vim-7.1.213/src/version.c	Wed Jan  9 20:29:51 2008
--- src/version.c	Wed Jan  9 22:37:47 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     214,
  /**/

-- 
Q: What's orange and sounds like a parrot?
A: A carrot

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.215
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.215
Problem:    It is difficult to figure out what syntax items are nested at a
	    certain position.
Solution:   Add the synstack() function.
Files:	    runtime/doc/eval.txt, src/eval.c, src/proto/syntax.pro,
	    src/syntax.c


*** ../vim-7.1.214/runtime/doc/eval.txt	Sun Jan  6 20:05:36 2008
--- runtime/doc/eval.txt	Thu Jan 10 22:20:31 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 06
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 10
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1786,1791 ****
--- 1786,1792 ----
  synIDattr( {synID}, {what} [, {mode}])
  				String	attribute {what} of syntax ID {synID}
  synIDtrans( {synID})		Number	translated syntax ID of {synID}
+ synstack({lnum}, {col})		List    stack of syntax IDs at {lnum} and {col}
  system( {expr} [, {input}])	String	output of shell command/filter {expr}
  tabpagebuflist( [{arg}])	List	list of buffer numbers in tab page
  tabpagenr( [{arg}])		Number	number of current or last tab page
***************
*** 4962,4967 ****
--- 4966,4989 ----
  		highlight the character.  Highlight links given with
  		":highlight link" are followed.
  
+ synstack({lnum}, {col})					*synstack()*
+ 		Return a |List|, which is the stack of syntax items at the
+ 		position {lnum} and {col} in the current window.  Each item in
+ 		the List is an ID like what |synID()| returns.
+ 		The stack is the situation in between the character at "col"
+ 		and the next character.  Note that a region of only one
+ 		character will not show up, it only exists inside that
+ 		character, not in between characters.
+ 		The first item in the List is the outer region, following are
+ 		items contained in that one.  The last one is what |synID()|
+ 		returns, unless not the whole item is highlighted or it is a
+ 		transparent item.
+ 		This function is useful for debugging a syntax file.
+ 		Example that shows the syntax stack under the cursor: >
+ 			for id in synstack(line("."), col("."))
+ 			   echo synIDattr(id, "name")
+ 			endfor
+ 
  system({expr} [, {input}])				*system()* *E677*
  		Get the output of the shell command {expr}.
  		When {input} is given, this string is written to a file and
*** ../vim-7.1.214/src/eval.c	Sun Jan  6 20:05:36 2008
--- src/eval.c	Wed Jan  9 13:42:56 2008
***************
*** 651,656 ****
--- 651,657 ----
  static void f_synID __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_synIDattr __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_synIDtrans __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_synstack __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_system __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_tabpagebuflist __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_tabpagenr __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 7252,7257 ****
--- 7253,7259 ----
      {"synID",		3, 3, f_synID},
      {"synIDattr",	2, 3, f_synIDattr},
      {"synIDtrans",	1, 1, f_synIDtrans},
+     {"synstack",	2, 2, f_synstack},
      {"system",		1, 2, f_system},
      {"tabpagebuflist",	0, 1, f_tabpagebuflist},
      {"tabpagenr",	0, 1, f_tabpagenr},
***************
*** 15843,15848 ****
--- 15845,15890 ----
  	id = 0;
  
      rettv->vval.v_number = id;
+ }
+ 
+ /*
+  * "synstack(lnum, col)" function
+  */
+ /*ARGSUSED*/
+     static void
+ f_synstack(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SYN_HL
+     long	lnum;
+     long	col;
+     int		i;
+     int		id;
+ #endif
+ 
+     rettv->v_type = VAR_LIST;
+     rettv->vval.v_list = NULL;
+ 
+ #ifdef FEAT_SYN_HL
+     lnum = get_tv_lnum(argvars);		/* -1 on type error */
+     col = get_tv_number(&argvars[1]) - 1;	/* -1 on type error */
+ 
+     if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
+ 	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
+ 	    && rettv_list_alloc(rettv) != FAIL)
+     {
+ 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL);
+ 	for (i = 0; ; ++i)
+ 	{
+ 	    id = syn_get_stack_item(i);
+ 	    if (id < 0)
+ 		break;
+ 	    if (list_append_number(rettv->vval.v_list, id) == FAIL)
+ 		break;
+ 	}
+     }
+ #endif
  }
  
  /*
*** ../vim-7.1.214/src/proto/syntax.pro	Tue Jul 24 14:32:44 2007
--- src/proto/syntax.pro	Wed Jan  9 13:38:20 2008
***************
*** 13,18 ****
--- 13,19 ----
  void set_context_in_syntax_cmd __ARGS((expand_T *xp, char_u *arg));
  char_u *get_syntax_name __ARGS((expand_T *xp, int idx));
  int syn_get_id __ARGS((win_T *wp, long lnum, colnr_T col, int trans, int *spellp));
+ int syn_get_stack_item __ARGS((int i));
  int syn_get_foldlevel __ARGS((win_T *wp, long lnum));
  void init_highlight __ARGS((int both, int reset));
  int load_colors __ARGS((char_u *name));
*** ../vim-7.1.214/src/syntax.c	Sun Oct  7 15:21:31 2007
--- src/syntax.c	Wed Jan  9 15:17:47 2008
***************
*** 6104,6109 ****
--- 6102,6123 ----
  
      return (trans ? current_trans_id : current_id);
  }
+ 
+ #if defined(FEAT_EVAL) || defined(PROTO)
+ /*
+  * Return the syntax ID at position "i" in the current stack.
+  * The caller must have called syn_get_id() before to fill the stack.
+  * Returns -1 when "i" is out of range.
+  */
+     int
+ syn_get_stack_item(i)
+     int i;
+ {
+     if (i >= current_state.ga_len )
+ 	return -1;
+     return CUR_STATE(i).si_id;
+ }
+ #endif
  
  #if defined(FEAT_FOLDING) || defined(PROTO)
  /*
*** ../vim-7.1.214/src/version.c	Wed Jan  9 22:39:55 2008
--- src/version.c	Thu Jan 10 22:17:38 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     215,
  /**/

-- 
TALL KNIGHT: We are now no longer the Knights Who Say Ni!
ONE KNIGHT:  Ni!
OTHERS:      Sh!
ONE KNIGHT:  (whispers) Sorry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.216
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.216
Problem:    Variants of --remote-tab are not mentioned for "vim --help".
Solution:   Display optional -wait and -silent.
Files:	    src/main.c


*** ../vim-7.1.215/src/main.c	Tue Sep 25 17:54:41 2007
--- src/main.c	Sun Dec 30 15:09:11 2007
***************
*** 3081,3087 ****
      main_msg(_("--remote-wait <files>  As --remote but wait for files to have been edited"));
      main_msg(_("--remote-wait-silent <files>  Same, don't complain if there is no server"));
  # ifdef FEAT_WINDOWS
!     main_msg(_("--remote-tab <files>  As --remote but open tab page for each file"));
  # endif
      main_msg(_("--remote-send <keys>\tSend <keys> to a Vim server and exit"));
      main_msg(_("--remote-expr <expr>\tEvaluate <expr> in a Vim server and print result"));
--- 3081,3087 ----
      main_msg(_("--remote-wait <files>  As --remote but wait for files to have been edited"));
      main_msg(_("--remote-wait-silent <files>  Same, don't complain if there is no server"));
  # ifdef FEAT_WINDOWS
!     main_msg(_("--remote-tab[-wait][-silent] <files>  As --remote but use tab page per file"));
  # endif
      main_msg(_("--remote-send <keys>\tSend <keys> to a Vim server and exit"));
      main_msg(_("--remote-expr <expr>\tEvaluate <expr> in a Vim server and print result"));
*** ../vim-7.1.215/src/version.c	Thu Jan 10 22:23:22 2008
--- src/version.c	Fri Jan 11 20:25:14 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     216,
  /**/

-- 
TIM: But follow only if you are men of valour.  For the entrance to this cave
     is guarded by a monster, a creature so foul and cruel that no man yet has
     fought with it and lived.  Bones of full fifty men lie strewn about its
     lair ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.217
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.217
Problem:    The "help-tags" tag may be missing from runtime/doc/tags when it
	    was generated during "make install".
Solution:   Add the "++t" argument to ":helptags" to force adding the tag.
Files:	    runtime/doc/Makefile, runtime/doc/various.txt, src/ex_cmds.c,
	    src/ex_cmds.h


*** ../vim-7.1.216/runtime/doc/Makefile	Sat May  5 19:14:15 2007
--- runtime/doc/Makefile	Fri Jan 11 20:55:34 2008
***************
*** 301,307 ****
  # Use Vim to generate the tags file.  Can only be used when Vim has been
  # compiled and installed.  Supports multiple languages.
  vimtags: $(DOCS)
! 	$(VIMEXE) -u NONE -esX -c "helptags ." -c quit
  
  # Use "doctags" to generate the tags file.  Only works for English!
  tags: doctags $(DOCS)
--- 301,307 ----
  # Use Vim to generate the tags file.  Can only be used when Vim has been
  # compiled and installed.  Supports multiple languages.
  vimtags: $(DOCS)
! 	$(VIMEXE) -u NONE -esX -c "helptags ++t ." -c quit
  
  # Use "doctags" to generate the tags file.  Only works for English!
  tags: doctags $(DOCS)
*** ../vim-7.1.216/runtime/doc/various.txt	Sat May 12 17:05:26 2007
--- runtime/doc/various.txt	Fri Jan 11 20:45:45 2008
***************
*** 1,4 ****
! *various.txt*   For Vim version 7.1.  Last change: 2007 Jan 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *various.txt*   For Vim version 7.1.  Last change: 2008 Jan 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 748,754 ****
  
  					*:helpt* *:helptags*
  				*E154* *E150* *E151* *E152* *E153* *E670*
! :helpt[ags] {dir}	Generate the help tags file(s) for directory {dir}.
  			All "*.txt" and "*.??x" files in the directory are
  			scanned for a help tag definition in between stars.
  			The "*.??x" files are for translated docs, they
--- 754,761 ----
  
  					*:helpt* *:helptags*
  				*E154* *E150* *E151* *E152* *E153* *E670*
! :helpt[ags] [++t] {dir}
! 			Generate the help tags file(s) for directory {dir}.
  			All "*.txt" and "*.??x" files in the directory are
  			scanned for a help tag definition in between stars.
  			The "*.??x" files are for translated docs, they
***************
*** 756,761 ****
--- 763,771 ----
  			The generated tags files are sorted.
  			When there are duplicates an error message is given.
  			An existing tags file is silently overwritten.
+ 			The optional "++t" argument forces adding the
+ 			"help-tags" tag.  This is also done when the {dir} is
+ 			equal to $VIMRUNTIME/doc.
  			To rebuild the help tags in the runtime directory
  			(requires write permission there): >
  				:helptags $VIMRUNTIME/doc
*** ../vim-7.1.216/src/ex_cmds.c	Wed Jan  9 22:39:55 2008
--- src/ex_cmds.c	Fri Jan 11 20:47:13 2008
***************
*** 6091,6097 ****
  }
  
  #if defined(FEAT_EX_EXTRA) || defined(PROTO)
! static void helptags_one __ARGS((char_u *dir, char_u *ext, char_u *lang));
  
  /*
   * ":helptags"
--- 6091,6097 ----
  }
  
  #if defined(FEAT_EX_EXTRA) || defined(PROTO)
! static void helptags_one __ARGS((char_u *dir, char_u *ext, char_u *lang, int add_help_tags));
  
  /*
   * ":helptags"
***************
*** 6110,6115 ****
--- 6110,6123 ----
      char_u	fname[8];
      int		filecount;
      char_u	**files;
+     int		add_help_tags = FALSE;
+ 
+     /* Check for ":helptags ++t {dir}". */
+     if (STRNCMP(eap->arg, "++t", 3) == 0 && vim_iswhite(eap->arg[3]))
+     {
+ 	add_help_tags = TRUE;
+ 	eap->arg = skipwhite(eap->arg + 3);
+     }
  
      if (!mch_isdir(eap->arg))
      {
***************
*** 6192,6198 ****
  	    ext[1] = fname[5];
  	    ext[2] = fname[6];
  	}
! 	helptags_one(eap->arg, ext, fname);
      }
  
      ga_clear(&ga);
--- 6200,6206 ----
  	    ext[1] = fname[5];
  	    ext[2] = fname[6];
  	}
! 	helptags_one(eap->arg, ext, fname, add_help_tags);
      }
  
      ga_clear(&ga);
***************
*** 6200,6214 ****
  
  #else
      /* No language support, just use "*.txt" and "tags". */
!     helptags_one(eap->arg, (char_u *)".txt", (char_u *)"tags");
  #endif
  }
  
      static void
! helptags_one(dir, ext, tagfname)
!     char_u	*dir;	    /* doc directory */
!     char_u	*ext;	    /* suffix, ".txt", ".itx", ".frx", etc. */
!     char_u	*tagfname;    /* "tags" for English, "tags-it" for Italian. */
  {
      FILE	*fd_tags;
      FILE	*fd;
--- 6208,6223 ----
  
  #else
      /* No language support, just use "*.txt" and "tags". */
!     helptags_one(eap->arg, (char_u *)".txt", (char_u *)"tags", add_help_tags);
  #endif
  }
  
      static void
! helptags_one(dir, ext, tagfname, add_help_tags)
!     char_u	*dir;		/* doc directory */
!     char_u	*ext;		/* suffix, ".txt", ".itx", ".frx", etc. */
!     char_u	*tagfname;      /* "tags" for English, "tags-fr" for French. */
!     int		add_help_tags;  /* add "help-tags" tag */
  {
      FILE	*fd_tags;
      FILE	*fd;
***************
*** 6259,6268 ****
      }
  
      /*
!      * If generating tags for "$VIMRUNTIME/doc" add the "help-tags" tag.
       */
      ga_init2(&ga, (int)sizeof(char_u *), 100);
!     if (fullpathcmp((char_u *)"$VIMRUNTIME/doc", dir, FALSE) == FPC_SAME)
      {
  	if (ga_grow(&ga, 1) == FAIL)
  	    got_int = TRUE;
--- 6268,6279 ----
      }
  
      /*
!      * If using the "++t" argument or generating tags for "$VIMRUNTIME/doc"
!      * add the "help-tags" tag.
       */
      ga_init2(&ga, (int)sizeof(char_u *), 100);
!     if (add_help_tags || fullpathcmp((char_u *)"$VIMRUNTIME/doc",
! 						      dir, FALSE) == FPC_SAME)
      {
  	if (ga_grow(&ga, 1) == FAIL)
  	    got_int = TRUE;
*** ../vim-7.1.216/src/ex_cmds.h	Thu Mar  8 11:00:55 2007
--- src/ex_cmds.h	Fri Jan 11 20:49:18 2008
***************
*** 422,428 ****
  EX(CMD_helpgrep,	"helpgrep",	ex_helpgrep,
  			EXTRA|NOTRLCOM|NEEDARG),
  EX(CMD_helptags,	"helptags",	ex_helptags,
! 			NEEDARG|FILE1|TRLBAR|CMDWIN),
  EX(CMD_hardcopy,	"hardcopy",	ex_hardcopy,
  			RANGE|COUNT|EXTRA|TRLBAR|DFLALL|BANG),
  EX(CMD_highlight,	"highlight",	ex_highlight,
--- 422,428 ----
  EX(CMD_helpgrep,	"helpgrep",	ex_helpgrep,
  			EXTRA|NOTRLCOM|NEEDARG),
  EX(CMD_helptags,	"helptags",	ex_helptags,
! 			NEEDARG|FILES|TRLBAR|CMDWIN),
  EX(CMD_hardcopy,	"hardcopy",	ex_hardcopy,
  			RANGE|COUNT|EXTRA|TRLBAR|DFLALL|BANG),
  EX(CMD_highlight,	"highlight",	ex_highlight,
*** ../vim-7.1.216/src/version.c	Fri Jan 11 20:25:42 2008
--- src/version.c	Fri Jan 11 20:58:44 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     217,
  /**/

-- 
My girlfriend told me I should be more affectionate.
So I got TWO girlfriends.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.218
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.218
Problem:    A syntax region without a "keepend", containing a region with
	    "extend" could be truncated at the end of the containing region.
Solution:   Do not call syn_update_ends() when there are no keepend items.
Files:	    src/syntax.c


*** ../vim-7.1.217/src/syntax.c	Thu Jan 10 22:23:22 2008
--- src/syntax.c	Wed Jan  9 15:17:47 2008
***************
*** 2495,2501 ****
  		if (current_state.ga_len == 0)
  		    break;
  
! 		if (had_extend)
  		{
  		    syn_update_ends(FALSE);
  		    if (current_state.ga_len == 0)
--- 2493,2499 ----
  		if (current_state.ga_len == 0)
  		    break;
  
! 		if (had_extend && keepend_level >= 0)
  		{
  		    syn_update_ends(FALSE);
  		    if (current_state.ga_len == 0)
*** ../vim-7.1.217/src/version.c	Fri Jan 11 21:00:49 2008
--- src/version.c	Fri Jan 11 21:25:46 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     218,
  /**/

-- 
The Law of VIM:
For each member b of the possible behaviour space B of program P, there exists
a finite time t before which at least one user u in the total user space U of
program P will request b becomes a member of the allowed behaviour space B'
(B' <= B).
In other words: Sooner or later everyone wants everything as an option.
                                        -- Vince Negri

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.219
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.219 (after 7.1.215)
Problem:    synstack() returns situation after the current character, can't
	    see the state for a one-character region.
Solution:   Don't update ending states in the requested column.
Files:	    runtime/doc/eval.txt, src/eval.c, src/hardcopy.c,
	    src/proto/syntax.pro, src/screen.c, src/spell.c, src/syntax.c


*** ../vim-7.1.218/runtime/doc/eval.txt	Thu Jan 10 22:23:22 2008
--- runtime/doc/eval.txt	Fri Jan 11 22:04:59 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 10
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 4967,4976 ****
  		Return a |List|, which is the stack of syntax items at the
  		position {lnum} and {col} in the current window.  Each item in
  		the List is an ID like what |synID()| returns.
- 		The stack is the situation in between the character at "col"
- 		and the next character.  Note that a region of only one
- 		character will not show up, it only exists inside that
- 		character, not in between characters.
  		The first item in the List is the outer region, following are
  		items contained in that one.  The last one is what |synID()|
  		returns, unless not the whole item is highlighted or it is a
--- 4970,4975 ----
*** ../vim-7.1.218/src/eval.c	Thu Jan 10 22:23:22 2008
--- src/eval.c	Fri Jan 11 21:46:12 2008
***************
*** 15725,15731 ****
  
      if (!transerr && lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
  	    && col >= 0 && col < (long)STRLEN(ml_get(lnum)))
! 	id = syn_get_id(curwin, lnum, (colnr_T)col, trans, NULL);
  #endif
  
      rettv->vval.v_number = id;
--- 15725,15731 ----
  
      if (!transerr && lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
  	    && col >= 0 && col < (long)STRLEN(ml_get(lnum)))
! 	id = syn_get_id(curwin, lnum, (colnr_T)col, trans, NULL, FALSE);
  #endif
  
      rettv->vval.v_number = id;
***************
*** 15874,15880 ****
  	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
  	    && rettv_list_alloc(rettv) != FAIL)
      {
! 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL);
  	for (i = 0; ; ++i)
  	{
  	    id = syn_get_stack_item(i);
--- 15874,15880 ----
  	    && col >= 0 && col < (long)STRLEN(ml_get(lnum))
  	    && rettv_list_alloc(rettv) != FAIL)
      {
! 	(void)syn_get_id(curwin, lnum, (colnr_T)col, FALSE, NULL, TRUE);
  	for (i = 0; ; ++i)
  	{
  	    id = syn_get_stack_item(i);
*** ../vim-7.1.218/src/hardcopy.c	Thu May 10 20:40:02 2007
--- src/hardcopy.c	Fri Jan 11 21:46:20 2008
***************
*** 876,882 ****
  	 */
  	if (psettings->do_syntax)
  	{
! 	    id = syn_get_id(curwin, ppos->file_line, col, 1, NULL);
  	    if (id > 0)
  		id = syn_get_final_id(id);
  	    else
--- 876,882 ----
  	 */
  	if (psettings->do_syntax)
  	{
! 	    id = syn_get_id(curwin, ppos->file_line, col, 1, NULL, FALSE);
  	    if (id > 0)
  		id = syn_get_final_id(id);
  	    else
*** ../vim-7.1.218/src/proto/syntax.pro	Thu Jan 10 22:23:22 2008
--- src/proto/syntax.pro	Fri Jan 11 21:54:19 2008
***************
*** 4,10 ****
  void syn_stack_apply_changes __ARGS((buf_T *buf));
  void syntax_end_parsing __ARGS((linenr_T lnum));
  int syntax_check_changed __ARGS((linenr_T lnum));
! int get_syntax_attr __ARGS((colnr_T col, int *can_spell));
  void syntax_clear __ARGS((buf_T *buf));
  void ex_syntax __ARGS((exarg_T *eap));
  int syntax_present __ARGS((buf_T *buf));
--- 4,10 ----
  void syn_stack_apply_changes __ARGS((buf_T *buf));
  void syntax_end_parsing __ARGS((linenr_T lnum));
  int syntax_check_changed __ARGS((linenr_T lnum));
! int get_syntax_attr __ARGS((colnr_T col, int *can_spell, int keep_state));
  void syntax_clear __ARGS((buf_T *buf));
  void ex_syntax __ARGS((exarg_T *eap));
  int syntax_present __ARGS((buf_T *buf));
***************
*** 12,18 ****
  void set_context_in_echohl_cmd __ARGS((expand_T *xp, char_u *arg));
  void set_context_in_syntax_cmd __ARGS((expand_T *xp, char_u *arg));
  char_u *get_syntax_name __ARGS((expand_T *xp, int idx));
! int syn_get_id __ARGS((win_T *wp, long lnum, colnr_T col, int trans, int *spellp));
  int syn_get_stack_item __ARGS((int i));
  int syn_get_foldlevel __ARGS((win_T *wp, long lnum));
  void init_highlight __ARGS((int both, int reset));
--- 12,18 ----
  void set_context_in_echohl_cmd __ARGS((expand_T *xp, char_u *arg));
  void set_context_in_syntax_cmd __ARGS((expand_T *xp, char_u *arg));
  char_u *get_syntax_name __ARGS((expand_T *xp, int idx));
! int syn_get_id __ARGS((win_T *wp, long lnum, colnr_T col, int trans, int *spellp, int keep_state));
  int syn_get_stack_item __ARGS((int i));
  int syn_get_foldlevel __ARGS((win_T *wp, long lnum));
  void init_highlight __ARGS((int both, int reset));
*** ../vim-7.1.218/src/screen.c	Thu Nov  8 21:23:34 2007
--- src/screen.c	Fri Jan 11 21:48:10 2008
***************
*** 3885,3891 ****
  # ifdef FEAT_SPELL
  					       has_spell ? &can_spell :
  # endif
! 					       NULL);
  
  		    if (did_emsg)
  		    {
--- 3885,3891 ----
  # ifdef FEAT_SPELL
  					       has_spell ? &can_spell :
  # endif
! 					       NULL, FALSE);
  
  		    if (did_emsg)
  		    {
*** ../vim-7.1.218/src/spell.c	Sun Aug  5 18:32:21 2007
--- src/spell.c	Fri Jan 11 21:46:50 2008
***************
*** 2146,2152 ****
  			{
  			    col = (int)(p - buf);
  			    (void)syn_get_id(wp, lnum, (colnr_T)col,
! 						       FALSE, &can_spell);
  			    if (!can_spell)
  				attr = HLF_COUNT;
  			}
--- 2146,2152 ----
  			{
  			    col = (int)(p - buf);
  			    (void)syn_get_id(wp, lnum, (colnr_T)col,
! 						    FALSE, &can_spell, FALSE);
  			    if (!can_spell)
  				attr = HLF_COUNT;
  			}
*** ../vim-7.1.218/src/syntax.c	Fri Jan 11 21:26:49 2008
--- src/syntax.c	Sat Jan 12 16:42:25 2008
***************
*** 378,384 ****
  static int syn_stack_equal __ARGS((synstate_T *sp));
  static void validate_current_state __ARGS((void));
  static int syn_finish_line __ARGS((int syncing));
! static int syn_current_attr __ARGS((int syncing, int displaying, int *can_spell));
  static int did_match_already __ARGS((int idx, garray_T *gap));
  static stateitem_T *push_next_match __ARGS((stateitem_T *cur_si));
  static void check_state_ends __ARGS((void));
--- 378,384 ----
  static int syn_stack_equal __ARGS((synstate_T *sp));
  static void validate_current_state __ARGS((void));
  static int syn_finish_line __ARGS((int syncing));
! static int syn_current_attr __ARGS((int syncing, int displaying, int *can_spell, int keep_state));
  static int did_match_already __ARGS((int idx, garray_T *gap));
  static stateitem_T *push_next_match __ARGS((stateitem_T *cur_si));
  static void check_state_ends __ARGS((void));
***************
*** 1691,1697 ****
      {
  	while (!current_finished)
  	{
! 	    (void)syn_current_attr(syncing, FALSE, NULL);
  	    /*
  	     * When syncing, and found some item, need to check the item.
  	     */
--- 1690,1696 ----
      {
  	while (!current_finished)
  	{
! 	    (void)syn_current_attr(syncing, FALSE, NULL, FALSE);
  	    /*
  	     * When syncing, and found some item, need to check the item.
  	     */
***************
*** 1731,1739 ****
   * done.
   */
      int
! get_syntax_attr(col, can_spell)
      colnr_T	col;
      int		*can_spell;
  {
      int	    attr = 0;
  
--- 1730,1739 ----
   * done.
   */
      int
! get_syntax_attr(col, can_spell, keep_state)
      colnr_T	col;
      int		*can_spell;
+     int		keep_state;	/* keep state of char at "col" */
  {
      int	    attr = 0;
  
***************
*** 1768,1774 ****
       */
      while (current_col <= col)
      {
! 	attr = syn_current_attr(FALSE, TRUE, can_spell);
  	++current_col;
      }
  
--- 1768,1775 ----
       */
      while (current_col <= col)
      {
! 	attr = syn_current_attr(FALSE, TRUE, can_spell,
! 				     current_col == col ? keep_state : FALSE);
  	++current_col;
      }
  
***************
*** 1779,1788 ****
   * Get syntax attributes for current_lnum, current_col.
   */
      static int
! syn_current_attr(syncing, displaying, can_spell)
      int		syncing;		/* When 1: called for syncing */
      int		displaying;		/* result will be displayed */
      int		*can_spell;		/* return: do spell checking */
  {
      int		syn_id;
      lpos_T	endpos;		/* was: char_u *endp; */
--- 1780,1790 ----
   * Get syntax attributes for current_lnum, current_col.
   */
      static int
! syn_current_attr(syncing, displaying, can_spell, keep_state)
      int		syncing;		/* When 1: called for syncing */
      int		displaying;		/* result will be displayed */
      int		*can_spell;		/* return: do spell checking */
+     int		keep_state;		/* keep syntax stack afterwards */
  {
      int		syn_id;
      lpos_T	endpos;		/* was: char_u *endp; */
***************
*** 2298,2304 ****
  	 * may be for an empty match and a containing item might end in the
  	 * current column.
  	 */
! 	if (!syncing)
  	{
  	    check_state_ends();
  	    if (current_state.ga_len > 0
--- 2300,2306 ----
  	 * may be for an empty match and a containing item might end in the
  	 * current column.
  	 */
! 	if (!syncing && !keep_state)
  	{
  	    check_state_ends();
  	    if (current_state.ga_len > 0
***************
*** 6086,6097 ****
   * Function called for expression evaluation: get syntax ID at file position.
   */
      int
! syn_get_id(wp, lnum, col, trans, spellp)
      win_T	*wp;
      long	lnum;
      colnr_T	col;
!     int		trans;	    /* remove transparancy */
!     int		*spellp;    /* return: can do spell checking */
  {
      /* When the position is not after the current position and in the same
       * line of the same buffer, need to restart parsing. */
--- 6088,6100 ----
   * Function called for expression evaluation: get syntax ID at file position.
   */
      int
! syn_get_id(wp, lnum, col, trans, spellp, keep_state)
      win_T	*wp;
      long	lnum;
      colnr_T	col;
!     int		trans;	     /* remove transparancy */
!     int		*spellp;     /* return: can do spell checking */
!     int		keep_state;  /* keep state of char at "col" */
  {
      /* When the position is not after the current position and in the same
       * line of the same buffer, need to restart parsing. */
***************
*** 6100,6106 ****
  	    || col < current_col)
  	syntax_start(wp, lnum);
  
!     (void)get_syntax_attr(col, spellp);
  
      return (trans ? current_trans_id : current_id);
  }
--- 6103,6109 ----
  	    || col < current_col)
  	syntax_start(wp, lnum);
  
!     (void)get_syntax_attr(col, spellp, keep_state);
  
      return (trans ? current_trans_id : current_id);
  }
***************
*** 6115,6122 ****
  syn_get_stack_item(i)
      int i;
  {
!     if (i >= current_state.ga_len )
  	return -1;
      return CUR_STATE(i).si_id;
  }
  #endif
--- 6118,6131 ----
  syn_get_stack_item(i)
      int i;
  {
!     if (i >= current_state.ga_len)
!     {
! 	/* Need to invalidate the state, because we didn't properly finish it
! 	 * for the last character, "keep_state" was TRUE. */
! 	invalidate_current_state();
! 	current_col = MAXCOL;
  	return -1;
+     }
      return CUR_STATE(i).si_id;
  }
  #endif
*** ../vim-7.1.218/src/version.c	Fri Jan 11 21:26:49 2008
--- src/version.c	Sat Jan 12 16:40:47 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     219,
  /**/

-- 
ARTHUR: Go on, Bors, chop its head off.
BORS:   Right.  Silly little bleeder.  One rabbit stew coming up.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.220
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.220
Problem:    When a ")" or word movement command moves the cursor back from the
	    end of the line it may end up on the trail byte of a multi-byte
	    character.  It's also moved back when it isn't needed.
Solution:   Add the adjust_cursor() function.
Files:	    src/normal.c


*** ../vim-7.1.219/src/normal.c	Sun Jan  6 20:05:36 2008
--- src/normal.c	Sat Jan 12 17:10:14 2008
***************
*** 150,155 ****
--- 150,156 ----
  static void	nv_bck_word __ARGS((cmdarg_T *cap));
  static void	nv_wordcmd __ARGS((cmdarg_T *cap));
  static void	nv_beginline __ARGS((cmdarg_T *cap));
+ static void	adjust_cursor __ARGS((oparg_T *oap));
  #ifdef FEAT_VISUAL
  static void	adjust_for_sel __ARGS((cmdarg_T *cap));
  static int	unadjust_for_sel __ARGS((void));
***************
*** 6567,6578 ****
  	clearopbeep(cap->oap);
      else
      {
! 	/* Don't leave the cursor on the NUL past a line */
! 	if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)
! 	{
! 	    --curwin->w_cursor.col;
! 	    cap->oap->inclusive = TRUE;
! 	}
  #ifdef FEAT_VIRTUALEDIT
  	curwin->w_cursor.coladd = 0;
  #endif
--- 6568,6575 ----
  	clearopbeep(cap->oap);
      else
      {
! 	/* Don't leave the cursor on the NUL past end of line. */
! 	adjust_cursor(cap->oap);
  #ifdef FEAT_VIRTUALEDIT
  	curwin->w_cursor.coladd = 0;
  #endif
***************
*** 8408,8419 ****
      else
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
!     /* Don't leave the cursor on the NUL past a line */
!     if (n != FAIL && curwin->w_cursor.col > 0 && gchar_cursor() == NUL)
!     {
! 	--curwin->w_cursor.col;
! 	cap->oap->inclusive = TRUE;
!     }
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
  	clearopbeep(cap->oap);
--- 8405,8413 ----
      else
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
!     /* Don't leave the cursor on the NUL past the end of line. */
!     if (n != FAIL)
! 	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
  	clearopbeep(cap->oap);
***************
*** 8426,8431 ****
--- 8420,8458 ----
  	if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)
  	    foldOpenCursor();
  #endif
+     }
+ }
+ 
+ /*
+  * Used after a movement command: If the cursor ends up on the NUL after the
+  * end of the line, may move it back to the last character and make the motion
+  * inclusive.
+  */
+     static void
+ adjust_cursor(oap)
+     oparg_T *oap;
+ {
+     /* The cursor cannot remain on the NUL when:
+      * - the column is > 0
+      * - not in Visual mode or 'selection' is "o"
+      * - 'virtualedit' is not "all" and not "onemore".
+      */
+     if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL
+ #ifdef FEAT_VISUAL
+ 		&& (!VIsual_active || *p_sel == 'o')
+ #endif
+ #ifdef FEAT_VIRTUALEDIT
+ 		&& !virtual_active() && (ve_flags & VE_ONEMORE) == 0
+ #endif
+ 		)
+     {
+ 	--curwin->w_cursor.col;
+ #ifdef FEAT_MBYTE
+ 	/* prevent cursor from moving on the trail byte */
+ 	if (has_mbyte)
+ 	    mb_adjust_cursor();
+ #endif
+ 	oap->inclusive = TRUE;
      }
  }
  
*** ../vim-7.1.219/src/version.c	Sat Jan 12 16:45:25 2008
--- src/version.c	Sat Jan 12 17:07:28 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     220,
  /**/

-- 
A hamburger walks into a bar, and the bartender says: "I'm sorry,
but we don't serve food here."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.221
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.221
Problem:    When inserting a "(", triggering the matchparen plugin, the
	    following highlighting may be messed up.
Solution:   Before triggering the CursorMovedI autocommands update the display
	    to update the stored syntax stacks for the change.
Files:	    src/edit.c


*** ../vim-7.1.220/src/edit.c	Wed Jan  9 10:13:24 2008
--- src/edit.c	Sat Jan 12 16:07:41 2008
***************
*** 1455,1460 ****
--- 1455,1468 ----
  # endif
  			     )
  	{
+ # ifdef FEAT_SYN_HL
+ 	    /* Need to update the screen first, to make sure syntax
+ 	     * highlighting is correct after making a change (e.g., inserting
+ 	     * a "(".  The autocommand may also require a redraw, so it's done
+ 	     * again below, unfortunately. */
+ 	    if (syntax_present(curbuf) && must_redraw)
+ 		update_screen(0);
+ # endif
  	    apply_autocmds(EVENT_CURSORMOVEDI, NULL, NULL, FALSE, curbuf);
  	    last_cursormoved = curwin->w_cursor;
  	}
*** ../vim-7.1.220/src/version.c	Sat Jan 12 17:11:25 2008
--- src/version.c	Sat Jan 12 18:11:22 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     221,
  /**/

-- 
ROBIN:  The what?
ARTHUR: The Holy Hand Grenade of Antioch.  'Tis one of the sacred relics
        Brother Maynard always carries with him.
ALL:    Yes. Of course.
ARTHUR: (shouting) Bring up the Holy Hand Grenade!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.222
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.222 (after 7.1.217)
Problem:    Wildcards in argument of ":helptags" are not expanded.  (Marcel
	    Svitalsky)
Solution:   Expand wildcards in the directory name.
Files:	    src/ex_cmds.c


*** ../vim-7.1.221/src/ex_cmds.c	Fri Jan 11 21:00:49 2008
--- src/ex_cmds.c	Sat Jan 12 21:40:51 2008
***************
*** 6106,6111 ****
--- 6106,6113 ----
  #ifdef FEAT_MULTI_LANG
      char_u	lang[2];
  #endif
+     expand_T	xpc;
+     char_u	*dirname;
      char_u	ext[5];
      char_u	fname[8];
      int		filecount;
***************
*** 6119,6125 ****
  	eap->arg = skipwhite(eap->arg + 3);
      }
  
!     if (!mch_isdir(eap->arg))
      {
  	EMSG2(_("E150: Not a directory: %s"), eap->arg);
  	return;
--- 6121,6131 ----
  	eap->arg = skipwhite(eap->arg + 3);
      }
  
!     ExpandInit(&xpc);
!     xpc.xp_context = EXPAND_DIRECTORIES;
!     dirname = ExpandOne(&xpc, eap->arg, NULL,
! 			    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);
!     if (dirname == NULL || !mch_isdir(dirname))
      {
  	EMSG2(_("E150: Not a directory: %s"), eap->arg);
  	return;
***************
*** 6127,6133 ****
  
  #ifdef FEAT_MULTI_LANG
      /* Get a list of all files in the directory. */
!     STRCPY(NameBuff, eap->arg);
      add_pathsep(NameBuff);
      STRCAT(NameBuff, "*");
      if (gen_expand_wildcards(1, &NameBuff, &filecount, &files,
--- 6133,6139 ----
  
  #ifdef FEAT_MULTI_LANG
      /* Get a list of all files in the directory. */
!     STRCPY(NameBuff, dirname);
      add_pathsep(NameBuff);
      STRCAT(NameBuff, "*");
      if (gen_expand_wildcards(1, &NameBuff, &filecount, &files,
***************
*** 6135,6140 ****
--- 6141,6147 ----
  	    || filecount == 0)
      {
  	EMSG2("E151: No match: %s", NameBuff);
+ 	vim_free(dirname);
  	return;
      }
  
***************
*** 6200,6206 ****
  	    ext[1] = fname[5];
  	    ext[2] = fname[6];
  	}
! 	helptags_one(eap->arg, ext, fname, add_help_tags);
      }
  
      ga_clear(&ga);
--- 6207,6213 ----
  	    ext[1] = fname[5];
  	    ext[2] = fname[6];
  	}
! 	helptags_one(dirname, ext, fname, add_help_tags);
      }
  
      ga_clear(&ga);
***************
*** 6208,6215 ****
  
  #else
      /* No language support, just use "*.txt" and "tags". */
!     helptags_one(eap->arg, (char_u *)".txt", (char_u *)"tags", add_help_tags);
  #endif
  }
  
      static void
--- 6215,6223 ----
  
  #else
      /* No language support, just use "*.txt" and "tags". */
!     helptags_one(dirname, (char_u *)".txt", (char_u *)"tags", add_help_tags);
  #endif
+     vim_free(dirname);
  }
  
      static void
*** ../vim-7.1.221/src/version.c	Sat Jan 12 18:13:05 2008
--- src/version.c	Sun Jan 13 13:27:04 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     222,
  /**/

-- 
   Arthur pulls Pin out.  The MONK blesses the grenade as ...
ARTHUR:  (quietly) One, two, five ...
GALAHAD: Three, sir!
ARTHUR:  Three.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.223
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.223
Problem:    glob() doesn't work properly when 'shell' is "sh" or "bash" and
	    the expanded name contains spaces, '~', single quotes and other
	    special characters.  (Adri Verhoef, Charles Campbell)
Solution:   For Posix shells define a vimglob() function to list the matches
	    instead of using "echo" directly.
Files:	    src/os_unix.c


*** ../vim-7.1.222/src/os_unix.c	Thu Jan  3 18:55:21 2008
--- src/os_unix.c	Sun Jan 13 13:52:53 2008
***************
*** 4946,4951 ****
--- 4946,4954 ----
      char_u	*p;
      int		dir;
  #ifdef __EMX__
+     /*
+      * This is the OS/2 implementation.
+      */
  # define EXPL_ALLOC_INC	16
      char_u	**expl_files;
      size_t	files_alloced, files_free;
***************
*** 5056,5075 ****
      return OK;
  
  #else /* __EMX__ */
! 
      int		j;
      char_u	*tempname;
      char_u	*command;
      FILE	*fd;
      char_u	*buffer;
! #define STYLE_ECHO  0	    /* use "echo" to expand */
! #define STYLE_GLOB  1	    /* use "glob" to expand, for csh */
! #define STYLE_PRINT 2	    /* use "print -N" to expand, for zsh */
! #define STYLE_BT    3	    /* `cmd` expansion, execute the pattern directly */
      int		shell_style = STYLE_ECHO;
      int		check_spaces;
      static int	did_find_nul = FALSE;
      int		ampersent = FALSE;
  
      *num_file = 0;	/* default: no files found */
      *file = NULL;
--- 5059,5084 ----
      return OK;
  
  #else /* __EMX__ */
!     /*
!      * This is the non-OS/2 implementation (really Unix).
!      */
      int		j;
      char_u	*tempname;
      char_u	*command;
      FILE	*fd;
      char_u	*buffer;
! #define STYLE_ECHO	0	/* use "echo", the default */
! #define STYLE_GLOB	1	/* use "glob", for csh */
! #define STYLE_VIMGLOB	2	/* use "vimglob", for Posix sh */
! #define STYLE_PRINT	3	/* use "print -N", for zsh */
! #define STYLE_BT	4	/* `cmd` expansion, execute the pattern
! 				 * directly */
      int		shell_style = STYLE_ECHO;
      int		check_spaces;
      static int	did_find_nul = FALSE;
      int		ampersent = FALSE;
+ 		/* vimglob() function to define for Posix shell */
+     static char *sh_vimglob_func = "vimglob() { while [ $# -ge 1 ]; do echo -n \"$1\"; echo; shift; done }; vimglob >";
  
      *num_file = 0;	/* default: no files found */
      *file = NULL;
***************
*** 5107,5115 ****
  
      /*
       * Let the shell expand the patterns and write the result into the temp
!      * file.  if expanding `cmd` execute it directly.
!      * If we use csh, glob will work better than echo.
!      * If we use zsh, print -N will work better than glob.
       */
      if (num_pat == 1 && *pat[0] == '`'
  	    && (len = STRLEN(pat[0])) > 2
--- 5116,5132 ----
  
      /*
       * Let the shell expand the patterns and write the result into the temp
!      * file.
!      * STYLE_BT:	NL separated
!      *	    If expanding `cmd` execute it directly.
!      * STYLE_GLOB:	NUL separated
!      *	    If we use *csh, "glob" will work better than "echo".
!      * STYLE_PRINT:	NL or NUL separated
!      *	    If we use *zsh, "print -N" will work better than "glob".
!      * STYLE_VIMGLOB:	NL separated
!      *	    If we use *sh*, we define "vimglob()".
!      * STYLE_ECHO:	space separated.
!      *	    A shell we don't know, stay safe and use "echo".
       */
      if (num_pat == 1 && *pat[0] == '`'
  	    && (len = STRLEN(pat[0])) > 2
***************
*** 5122,5130 ****
  	else if (STRCMP(p_sh + len - 3, "zsh") == 0)
  	    shell_style = STYLE_PRINT;
      }
! 
!     /* "unset nonomatch; print -N >" plus two is 29 */
      len = STRLEN(tempname) + 29;
      for (i = 0; i < num_pat; ++i)
      {
  	/* Count the length of the patterns in the same way as they are put in
--- 5139,5155 ----
  	else if (STRCMP(p_sh + len - 3, "zsh") == 0)
  	    shell_style = STYLE_PRINT;
      }
!     if (shell_style == STYLE_ECHO && strstr((char *)gettail(p_sh),
! 								"sh") != NULL)
! 	shell_style = STYLE_VIMGLOB;
! 
!     /* Compute the length of the command.  We need 2 extra bytes: for the
!      * optional '&' and for the NUL.
!      * Worst case: "unset nonomatch; print -N >" plus two is 29 */
      len = STRLEN(tempname) + 29;
+     if (shell_style == STYLE_VIMGLOB)
+ 	len += STRLEN(sh_vimglob_func);
+ 
      for (i = 0; i < num_pat; ++i)
      {
  	/* Count the length of the patterns in the same way as they are put in
***************
*** 5183,5192 ****
--- 5208,5221 ----
  	    STRCAT(command, "glob >");
  	else if (shell_style == STYLE_PRINT)
  	    STRCAT(command, "print -N >");
+ 	else if (shell_style == STYLE_VIMGLOB)
+ 	    STRCAT(command, sh_vimglob_func);
  	else
  	    STRCAT(command, "echo >");
      }
+ 
      STRCAT(command, tempname);
+ 
      if (shell_style != STYLE_BT)
  	for (i = 0; i < num_pat; ++i)
  	{
***************
*** 5232,5239 ****
      if (flags & EW_SILENT)
  	show_shell_mess = FALSE;
      if (ampersent)
! 	STRCAT(command, "&");		/* put the '&' back after the
! 					   redirection */
  
      /*
       * Using zsh -G: If a pattern has no matches, it is just deleted from
--- 5261,5267 ----
      if (flags & EW_SILENT)
  	show_shell_mess = FALSE;
      if (ampersent)
! 	STRCAT(command, "&");		/* put the '&' after the redirection */
  
      /*
       * Using zsh -G: If a pattern has no matches, it is just deleted from
***************
*** 5265,5271 ****
      show_shell_mess = TRUE;
      vim_free(command);
  
!     if (i)				/* mch_call_shell() failed */
      {
  	mch_remove(tempname);
  	vim_free(tempname);
--- 5293,5299 ----
      show_shell_mess = TRUE;
      vim_free(command);
  
!     if (i != 0)				/* mch_call_shell() failed */
      {
  	mch_remove(tempname);
  	vim_free(tempname);
***************
*** 5336,5342 ****
      }
      vim_free(tempname);
  
! #if defined(__CYGWIN__) || defined(__CYGWIN32__)
      /* Translate <CR><NL> into <NL>.  Caution, buffer may contain NUL. */
      p = buffer;
      for (i = 0; i < len; ++i)
--- 5364,5370 ----
      }
      vim_free(tempname);
  
! # if defined(__CYGWIN__) || defined(__CYGWIN32__)
      /* Translate <CR><NL> into <NL>.  Caution, buffer may contain NUL. */
      p = buffer;
      for (i = 0; i < len; ++i)
***************
*** 5359,5365 ****
  	}
      }
      /* file names are separated with NL */
!     else if (shell_style == STYLE_BT)
      {
  	buffer[len] = NUL;		/* make sure the buffer ends in NUL */
  	p = buffer;
--- 5387,5393 ----
  	}
      }
      /* file names are separated with NL */
!     else if (shell_style == STYLE_BT || shell_style == STYLE_VIMGLOB)
      {
  	buffer[len] = NUL;		/* make sure the buffer ends in NUL */
  	p = buffer;
***************
*** 5438,5444 ****
      {
  	(*file)[i] = p;
  	/* Space or NL separates */
! 	if (shell_style == STYLE_ECHO || shell_style == STYLE_BT)
  	{
  	    while (!(shell_style == STYLE_ECHO && *p == ' ')
  						   && *p != '\n' && *p != NUL)
--- 5466,5473 ----
      {
  	(*file)[i] = p;
  	/* Space or NL separates */
! 	if (shell_style == STYLE_ECHO || shell_style == STYLE_BT
! 					      || shell_style == STYLE_VIMGLOB)
  	{
  	    while (!(shell_style == STYLE_ECHO && *p == ' ')
  						   && *p != '\n' && *p != NUL)
*** ../vim-7.1.222/src/version.c	Sun Jan 13 13:30:34 2008
--- src/version.c	Sun Jan 13 13:45:04 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     223,
  /**/

-- 
User:       I'm having problems with my text editor.
Help desk:  Which editor are you using?
User:       I don't know, but it's version VI (pronounced: 6).
Help desk:  Oh, then you should upgrade to version VIM (pronounced: 994).

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.224
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.224
Problem:    When using "vim -F -o file1 file2" only one window is
	    right-to-left.  Same for "-H".  (Ben Schmidt)
Solution:   use set_option_value() to set 'rightleft'.
Files:	    src/main.c


*** ../vim-7.1.223/src/main.c	Fri Jan 11 20:25:42 2008
--- src/main.c	Sun Jan 13 16:12:09 2008
***************
*** 1775,1781 ****
  
  	    case 'F':		/* "-F" start in Farsi mode: rl + fkmap set */
  #ifdef FEAT_FKMAP
! 		curwin->w_p_rl = p_fkmap = TRUE;
  #else
  		mch_errmsg(_(e_nofarsi));
  		mch_exit(2);
--- 1775,1782 ----
  
  	    case 'F':		/* "-F" start in Farsi mode: rl + fkmap set */
  #ifdef FEAT_FKMAP
! 		p_fkmap = TRUE;
! 		set_option_value((char_u *)"rl", 1L, NULL, 0);
  #else
  		mch_errmsg(_(e_nofarsi));
  		mch_exit(2);
***************
*** 1792,1798 ****
  
  	    case 'H':		/* "-H" start in Hebrew mode: rl + hkmap set */
  #ifdef FEAT_RIGHTLEFT
! 		curwin->w_p_rl = p_hkmap = TRUE;
  #else
  		mch_errmsg(_(e_nohebrew));
  		mch_exit(2);
--- 1793,1800 ----
  
  	    case 'H':		/* "-H" start in Hebrew mode: rl + hkmap set */
  #ifdef FEAT_RIGHTLEFT
! 		p_hkmap = TRUE;
! 		set_option_value((char_u *)"rl", 1L, NULL, 0);
  #else
  		mch_errmsg(_(e_nohebrew));
  		mch_exit(2);
*** ../vim-7.1.223/src/version.c	Sun Jan 13 13:53:30 2008
--- src/version.c	Sun Jan 13 16:15:49 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     224,
  /**/

-- 
LAUNCELOT: Isn't there a St. Aaaaarrrrrrggghhh's in Cornwall?
ARTHUR:    No, that's Saint Ives.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.225
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.225
Problem:    Using unitialized value when XGetWMNormalHints() fails.
Solution:   Check the return value. (Dominique Pelle)
Files:	    src/os_unix.c


*** ../vim-7.1.224/src/os_unix.c	Sun Jan 13 13:53:30 2008
--- src/os_unix.c	Sun Jan 13 13:52:53 2008
***************
*** 6145,6153 ****
      if (xterm_trace == 1)
      {
  	/* Get the hints just before tracking starts.  The font size might
! 	 * have changed recently */
! 	XGetWMNormalHints(xterm_dpy, x11_window, &xterm_hints, &got_hints);
! 	if (!(got_hints & PResizeInc)
  		|| xterm_hints.width_inc <= 1
  		|| xterm_hints.height_inc <= 1)
  	{
--- 6145,6153 ----
      if (xterm_trace == 1)
      {
  	/* Get the hints just before tracking starts.  The font size might
! 	 * have changed recently. */
! 	if (!XGetWMNormalHints(xterm_dpy, x11_window, &xterm_hints, &got_hints)
! 		|| !(got_hints & PResizeInc)
  		|| xterm_hints.width_inc <= 1
  		|| xterm_hints.height_inc <= 1)
  	{
*** ../vim-7.1.224/src/version.c	Sun Jan 13 16:17:02 2008
--- src/version.c	Sun Jan 13 16:29:51 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     225,
  /**/

-- 
"When I die, I want a tombstone that says "GAME OVER" - Ton Richters

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.226
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.226
Problem:    Command line completion doesn't work when a file name contains a
	    '&' character.
Solution:   Accept all characters in a file name, except ones that end a
	    command or white space.
Files:	    src/ex_docmd.c


*** ../vim-7.1.225/src/ex_docmd.c	Wed Jan  9 20:29:51 2008
--- src/ex_docmd.c	Wed Jan  9 20:11:13 2008
***************
*** 3338,3349 ****
  		}
  		in_quote = !in_quote;
  	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec_or_wc(c)
! 					 && (!(ea.argt & NOSPC) || usefilter))
! #else
! 	    else if (!vim_isfilec_or_wc(c))
  #endif
  	    {
  		while (*p != NUL)
  		{
--- 3338,3350 ----
  		}
  		in_quote = !in_quote;
  	    }
+ 	    /* An argument can contain just about everything, except
+ 	     * characters that end the command and white space. */
+ 	    else if (c == '|' || c == '\n' || c == '"' || (vim_iswhite(c)
  #ifdef SPACE_IN_FILENAME
! 					 && (!(ea.argt & NOSPC) || usefilter)
  #endif
+ 		    ))
  	    {
  		while (*p != NUL)
  		{
*** ../vim-7.1.225/src/version.c	Sun Jan 13 16:30:23 2008
--- src/version.c	Sun Jan 13 17:10:15 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     226,
  /**/

-- 
   [Another hideous roar.]
BEDEVERE: That's it!
ARTHUR:   What?
BEDEVERE: It's The Legendary Black Beast of Aaaaarrrrrrggghhh!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.227
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.227
Problem:    Hang in syntax HL when moving over a ")". (Dominique Pelle)
Solution:   Avoid storing a syntax state in the wrong position in the list of
	    remembered states.
Files:	    src/syntax.c


*** ../vim-7.1.226/src/syntax.c	Sat Jan 12 16:45:25 2008
--- src/syntax.c	Sat Jan 12 16:45:44 2008
***************
*** 372,378 ****
  static int syn_stack_cleanup __ARGS((void));
  static void syn_stack_free_entry __ARGS((buf_T *buf, synstate_T *p));
  static synstate_T *syn_stack_find_entry __ARGS((linenr_T lnum));
! static synstate_T *store_current_state __ARGS((synstate_T *sp));
  static void load_current_state __ARGS((synstate_T *from));
  static void invalidate_current_state __ARGS((void));
  static int syn_stack_equal __ARGS((synstate_T *sp));
--- 372,378 ----
  static int syn_stack_cleanup __ARGS((void));
  static void syn_stack_free_entry __ARGS((buf_T *buf, synstate_T *p));
  static synstate_T *syn_stack_find_entry __ARGS((linenr_T lnum));
! static synstate_T *store_current_state __ARGS((void));
  static void load_current_state __ARGS((synstate_T *from));
  static void invalidate_current_state __ARGS((void));
  static int syn_stack_equal __ARGS((synstate_T *sp));
***************
*** 464,470 ****
      synstate_T	*p;
      synstate_T	*last_valid = NULL;
      synstate_T	*last_min_valid = NULL;
!     synstate_T	*sp, *prev;
      linenr_T	parsed_lnum;
      linenr_T	first_stored;
      int		dist;
--- 464,470 ----
      synstate_T	*p;
      synstate_T	*last_valid = NULL;
      synstate_T	*last_min_valid = NULL;
!     synstate_T	*sp, *prev = NULL;
      linenr_T	parsed_lnum;
      linenr_T	first_stored;
      int		dist;
***************
*** 502,508 ****
  	if (!current_state_stored)
  	{
  	    ++current_lnum;
! 	    (void)store_current_state(NULL);
  	}
  
  	/*
--- 502,508 ----
  	if (!current_state_stored)
  	{
  	    ++current_lnum;
! 	    (void)store_current_state();
  	}
  
  	/*
***************
*** 558,564 ****
  	dist = 999999;
      else
  	dist = syn_buf->b_ml.ml_line_count / (syn_buf->b_sst_len - Rows) + 1;
-     prev = syn_stack_find_entry(current_lnum);
      while (current_lnum < lnum)
      {
  	syn_start_line();
--- 558,563 ----
***************
*** 573,581 ****
  	     * equal to the current state.  If so, then validate all saved
  	     * states that depended on a change before the parsed line. */
  	    if (prev == NULL)
  		sp = syn_buf->b_sst_first;
  	    else
! 		sp = prev->sst_next;
  	    if (sp != NULL
  		    && sp->sst_lnum == current_lnum
  		    && syn_stack_equal(sp))
--- 572,584 ----
  	     * equal to the current state.  If so, then validate all saved
  	     * states that depended on a change before the parsed line. */
  	    if (prev == NULL)
+ 		prev = syn_stack_find_entry(current_lnum - 1);
+ 	    if (prev == NULL)
  		sp = syn_buf->b_sst_first;
  	    else
! 		sp = prev;
! 	    while (sp != NULL && sp->sst_lnum < current_lnum)
! 		sp = sp->sst_next;
  	    if (sp != NULL
  		    && sp->sst_lnum == current_lnum
  		    && syn_stack_equal(sp))
***************
*** 601,607 ****
  	    else if (prev == NULL
  			|| current_lnum == lnum
  			|| current_lnum >= prev->sst_lnum + dist)
! 		prev = store_current_state(prev);
  	}
  
  	/* This can take a long time: break when CTRL-C pressed.  The current
--- 604,610 ----
  	    else if (prev == NULL
  			|| current_lnum == lnum
  			|| current_lnum >= prev->sst_lnum + dist)
! 		prev = store_current_state();
  	}
  
  	/* This can take a long time: break when CTRL-C pressed.  The current
***************
*** 1353,1369 ****
   * The current state must be valid for the start of the current_lnum line!
   */
      static synstate_T *
! store_current_state(sp)
!     synstate_T	*sp;	/* at or before where state is to be saved or
! 				   NULL */
  {
      int		i;
      synstate_T	*p;
      bufstate_T	*bp;
      stateitem_T	*cur_si;
! 
!     if (sp == NULL)
! 	sp = syn_stack_find_entry(current_lnum);
  
      /*
       * If the current state contains a start or end pattern that continues
--- 1356,1368 ----
   * The current state must be valid for the start of the current_lnum line!
   */
      static synstate_T *
! store_current_state()
  {
      int		i;
      synstate_T	*p;
      bufstate_T	*bp;
      stateitem_T	*cur_si;
!     synstate_T	*sp = syn_stack_find_entry(current_lnum);
  
      /*
       * If the current state contains a start or end pattern that continues
***************
*** 1667,1673 ****
  	     * Store the current state in b_sst_array[] for later use.
  	     */
  	    ++current_lnum;
! 	    (void)store_current_state(NULL);
  	}
      }
  
--- 1666,1672 ----
  	     * Store the current state in b_sst_array[] for later use.
  	     */
  	    ++current_lnum;
! 	    (void)store_current_state();
  	}
      }
  
*** ../vim-7.1.226/src/version.c	Sun Jan 13 17:11:25 2008
--- src/version.c	Sun Jan 13 17:37:10 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     227,
  /**/

-- 
Dreams are free, but there's a small charge for alterations.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.228
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.228
Problem:    When 'foldmethod' is "indent" and a fold is created with ">>" it
	    can't be closed with "zc".  (Daniel Shahaf)
Solution:   Reset the "small" flag of a fold when adding a line to it.
Files:	    src/fold.c


*** ../vim-7.1.227/src/fold.c	Sun Oct 14 15:32:10 2007
--- src/fold.c	Sun Jan 13 21:26:48 2008
***************
*** 2676,2681 ****
--- 2676,2682 ----
      if (fp->fd_len < flp->lnum - fp->fd_top)
      {
  	fp->fd_len = flp->lnum - fp->fd_top;
+ 	fp->fd_small = MAYBE;
  	fold_changed = TRUE;
      }
  
*** ../vim-7.1.227/src/version.c	Sun Jan 13 17:39:29 2008
--- src/version.c	Sun Jan 13 21:56:53 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     228,
  /**/

-- 
VOICE OVER: As the horrendous Black Beast lunged forward, escape for Arthur
            and his knights seemed hopeless,  when, suddenly ... the animator
            suffered a fatal heart attack.
ANIMATOR:   Aaaaagh!
VOICE OVER: The cartoon peril was no more ... The Quest for Holy Grail could
            continue.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.229
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.229
Problem:    A fold is closed when it shouldn't when 'foldmethod' is "indent"
	    and backspacing a non-white character so that the indent increases.
Solution:   Keep the fold open after backspacing a character.
Files:	    src/edit.c


*** ../vim-7.1.228/src/edit.c	Sat Jan 12 18:13:05 2008
--- src/edit.c	Mon Jan 14 20:06:43 2008
***************
*** 8618,8623 ****
--- 8619,8632 ----
      if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == 0)
  	dollar_vcol = curwin->w_virtcol;
  
+ #ifdef FEAT_FOLDING
+     /* When deleting a char the cursor line must never be in a closed fold.
+      * E.g., when 'foldmethod' is indent and deleting the first non-white
+      * char before a Tab. */
+     if (did_backspace)
+ 	foldOpenCursor();
+ #endif
+ 
      return did_backspace;
  }
  
*** ../vim-7.1.228/src/version.c	Sun Jan 13 21:57:25 2008
--- src/version.c	Mon Jan 14 20:08:35 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     229,
  /**/

-- 
ROBIN:  (warily) And if you get a question wrong?
ARTHUR: You are cast into the Gorge of Eternal Peril.
ROBIN:  Oh ... wacho!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.230
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.230
Problem:    Memory leak when executing SourceCmd autocommands.
Solution:   Free the memory. (Dominique Pelle)
Files:	    src/ex_cmds2.c


*** ../vim-7.1.229/src/ex_cmds2.c	Sun Jan  6 20:05:36 2008
--- src/ex_cmds2.c	Tue Jan 15 20:41:28 2008
***************
*** 2889,2899 ****
      if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)
  	    && apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,
  							       FALSE, curbuf))
  # ifdef FEAT_EVAL
! 	return aborting() ? FAIL : OK;
  # else
! 	return OK;
  # endif
  
      /* Apply SourcePre autocommands, they may get the file. */
      apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, FALSE, curbuf);
--- 2889,2902 ----
      if (has_autocmd(EVENT_SOURCECMD, fname_exp, NULL)
  	    && apply_autocmds(EVENT_SOURCECMD, fname_exp, fname_exp,
  							       FALSE, curbuf))
+     {
  # ifdef FEAT_EVAL
! 	retval = aborting() ? FAIL : OK;
  # else
! 	retval = OK;
  # endif
+ 	goto theend;
+     }
  
      /* Apply SourcePre autocommands, they may get the file. */
      apply_autocmds(EVENT_SOURCEPRE, fname_exp, fname_exp, FALSE, curbuf);
*** ../vim-7.1.229/src/version.c	Mon Jan 14 20:11:37 2008
--- src/version.c	Tue Jan 15 22:15:03 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     230,
  /**/

-- 
Citizens are not allowed to attend a movie house or theater nor ride in a
public streetcar within at least four hours after eating garlic.
		[real standing law in Indiana, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.231
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.231
Problem:    When shifting lines the change is acted upon multiple times.
Solution:   Don't have shift_line() call changed_bytes.
Files:	    src/edit.c, src/ops.c, src/proto/edit.pro, src/proto/ops.pro


*** ../vim-7.1.230/src/edit.c	Mon Jan 14 20:11:37 2008
--- src/edit.c	Mon Jan 14 20:06:43 2008
***************
*** 1662,1672 ****
   * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).
   */
      void
! change_indent(type, amount, round, replaced)
      int		type;
      int		amount;
      int		round;
      int		replaced;	/* replaced character, put on replace stack */
  {
      int		vcol;
      int		last_vcol;
--- 1662,1673 ----
   * if round is TRUE, round the indent to 'shiftwidth' (only with _INC and _Dec).
   */
      void
! change_indent(type, amount, round, replaced, call_changed_bytes)
      int		type;
      int		amount;
      int		round;
      int		replaced;	/* replaced character, put on replace stack */
+     int		call_changed_bytes;	/* call changed_bytes() */
  {
      int		vcol;
      int		last_vcol;
***************
*** 1723,1729 ****
       * Set the new indent.  The cursor will be put on the first non-blank.
       */
      if (type == INDENT_SET)
! 	(void)set_indent(amount, SIN_CHANGED);
      else
      {
  #ifdef FEAT_VREPLACE
--- 1724,1730 ----
       * Set the new indent.  The cursor will be put on the first non-blank.
       */
      if (type == INDENT_SET)
! 	(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);
      else
      {
  #ifdef FEAT_VREPLACE
***************
*** 1733,1739 ****
  	if (State & VREPLACE_FLAG)
  	    State = INSERT;
  #endif
! 	shift_line(type == INDENT_DEC, round, 1);
  #ifdef FEAT_VREPLACE
  	State = save_State;
  #endif
--- 1734,1740 ----
  	if (State & VREPLACE_FLAG)
  	    State = INSERT;
  #endif
! 	shift_line(type == INDENT_DEC, round, 1, call_changed_bytes);
  #ifdef FEAT_VREPLACE
  	State = save_State;
  #endif
***************
*** 5921,5927 ****
  	    {
  #ifdef FEAT_VREPLACE
  		if (State & VREPLACE_FLAG)
! 		    change_indent(INDENT_SET, second_indent, FALSE, NUL);
  		else
  #endif
  		    (void)set_indent(second_indent, SIN_CHANGED);
--- 5922,5928 ----
  	    {
  #ifdef FEAT_VREPLACE
  		if (State & VREPLACE_FLAG)
! 		    change_indent(INDENT_SET, second_indent, FALSE, NUL, TRUE);
  		else
  #endif
  		    (void)set_indent(second_indent, SIN_CHANGED);
***************
*** 7227,7233 ****
  fixthisline(get_the_indent)
      int (*get_the_indent) __ARGS((void));
  {
!     change_indent(INDENT_SET, get_the_indent(), FALSE, 0);
      if (linewhite(curwin->w_cursor.lnum))
  	did_ai = TRUE;	    /* delete the indent if the line stays empty */
  }
--- 7228,7234 ----
  fixthisline(get_the_indent)
      int (*get_the_indent) __ARGS((void));
  {
!     change_indent(INDENT_SET, get_the_indent(), FALSE, 0, TRUE);
      if (linewhite(curwin->w_cursor.lnum))
  	did_ai = TRUE;	    /* delete the indent if the line stays empty */
  }
***************
*** 8170,8179 ****
  	    replace_pop_ins();
  	if (lastc == '^')
  	    old_indent = get_indent();	/* remember curr. indent */
! 	change_indent(INDENT_SET, 0, TRUE, 0);
      }
      else
! 	change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0);
  
      if (did_ai && *skipwhite(ml_get_curline()) != NUL)
  	did_ai = FALSE;
--- 8171,8180 ----
  	    replace_pop_ins();
  	if (lastc == '^')
  	    old_indent = get_indent();	/* remember curr. indent */
! 	change_indent(INDENT_SET, 0, TRUE, 0, TRUE);
      }
      else
! 	change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);
  
      if (did_ai && *skipwhite(ml_get_curline()) != NUL)
  	did_ai = FALSE;
***************
*** 9633,9639 ****
  	    curwin->w_cursor = old_pos;
  #ifdef FEAT_VREPLACE
  	    if (State & VREPLACE_FLAG)
! 		change_indent(INDENT_SET, i, FALSE, NUL);
  	    else
  #endif
  		(void)set_indent(i, SIN_CHANGED);
--- 9634,9640 ----
  	    curwin->w_cursor = old_pos;
  #ifdef FEAT_VREPLACE
  	    if (State & VREPLACE_FLAG)
! 		change_indent(INDENT_SET, i, FALSE, NUL, TRUE);
  	    else
  #endif
  		(void)set_indent(i, SIN_CHANGED);
***************
*** 9662,9668 ****
  		curwin->w_cursor = old_pos;
  	    }
  	    if (temp)
! 		shift_line(TRUE, FALSE, 1);
  	}
      }
  
--- 9663,9669 ----
  		curwin->w_cursor = old_pos;
  	    }
  	    if (temp)
! 		shift_line(TRUE, FALSE, 1, TRUE);
  	}
      }
  
*** ../vim-7.1.230/src/ops.c	Thu Jan  3 16:31:17 2008
--- src/ops.c	Sun Jan 13 21:52:18 2008
***************
*** 258,264 ****
  	    if (first_char != '#' || !preprocs_left())
  #endif
  	{
! 	    shift_line(oap->op_type == OP_LSHIFT, p_sr, amount);
  	}
  	++curwin->w_cursor.lnum;
      }
--- 258,264 ----
  	    if (first_char != '#' || !preprocs_left())
  #endif
  	{
! 	    shift_line(oap->op_type == OP_LSHIFT, p_sr, amount, FALSE);
  	}
  	++curwin->w_cursor.lnum;
      }
***************
*** 321,330 ****
   * leaves cursor on first blank in the line
   */
      void
! shift_line(left, round, amount)
      int	left;
      int	round;
      int	amount;
  {
      int		count;
      int		i, j;
--- 321,331 ----
   * leaves cursor on first blank in the line
   */
      void
! shift_line(left, round, amount, call_changed_bytes)
      int	left;
      int	round;
      int	amount;
+     int call_changed_bytes;	/* call changed_bytes() */
  {
      int		count;
      int		i, j;
***************
*** 363,372 ****
      /* Set new indent */
  #ifdef FEAT_VREPLACE
      if (State & VREPLACE_FLAG)
! 	change_indent(INDENT_SET, count, FALSE, NUL);
      else
  #endif
! 	(void)set_indent(count, SIN_CHANGED);
  }
  
  #if defined(FEAT_VISUALEXTRA) || defined(PROTO)
--- 364,373 ----
      /* Set new indent */
  #ifdef FEAT_VREPLACE
      if (State & VREPLACE_FLAG)
! 	change_indent(INDENT_SET, count, FALSE, NUL, call_changed_bytes);
      else
  #endif
! 	(void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);
  }
  
  #if defined(FEAT_VISUALEXTRA) || defined(PROTO)
*** ../vim-7.1.230/src/proto/edit.pro	Wed Jan  2 17:48:24 2008
--- src/proto/edit.pro	Sun Jan 13 21:52:27 2008
***************
*** 3,9 ****
  void edit_putchar __ARGS((int c, int highlight));
  void edit_unputchar __ARGS((void));
  void display_dollar __ARGS((colnr_T col));
! void change_indent __ARGS((int type, int amount, int round, int replaced));
  void truncate_spaces __ARGS((char_u *line));
  void backspace_until_column __ARGS((int col));
  int vim_is_ctrl_x_key __ARGS((int c));
--- 3,9 ----
  void edit_putchar __ARGS((int c, int highlight));
  void edit_unputchar __ARGS((void));
  void display_dollar __ARGS((colnr_T col));
! void change_indent __ARGS((int type, int amount, int round, int replaced, int call_changed_bytes));
  void truncate_spaces __ARGS((char_u *line));
  void backspace_until_column __ARGS((int col));
  int vim_is_ctrl_x_key __ARGS((int c));
*** ../vim-7.1.230/src/proto/ops.pro	Sun May  6 13:56:32 2007
--- src/proto/ops.pro	Sun Jan 13 21:52:30 2008
***************
*** 4,10 ****
  int get_op_char __ARGS((int optype));
  int get_extra_op_char __ARGS((int optype));
  void op_shift __ARGS((oparg_T *oap, int curs_top, int amount));
! void shift_line __ARGS((int left, int round, int amount));
  void op_reindent __ARGS((oparg_T *oap, int (*how)(void)));
  int get_expr_register __ARGS((void));
  void set_expr_line __ARGS((char_u *new_line));
--- 4,10 ----
  int get_op_char __ARGS((int optype));
  int get_extra_op_char __ARGS((int optype));
  void op_shift __ARGS((oparg_T *oap, int curs_top, int amount));
! void shift_line __ARGS((int left, int round, int amount, int call_changed_bytes));
  void op_reindent __ARGS((oparg_T *oap, int (*how)(void)));
  int get_expr_register __ARGS((void));
  void set_expr_line __ARGS((char_u *new_line));
*** ../vim-7.1.230/src/version.c	Tue Jan 15 22:16:36 2008
--- src/version.c	Wed Jan 16 19:58:25 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     231,
  /**/

-- 
Snoring is prohibited unless all bedroom windows are closed and securely
locked.
		[real standing law in Massachusetts, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.232
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.232 (after 7.1.207 and 7.1.211)
Problem:    Compiler warnings with MSVC.
Solution:   Add type casts. (Mike Williams)
Files:	    src/ex_cmds2.c, src/netbeans.c


*** ../vim-7.1.231/src/ex_cmds2.c	Tue Jan 15 22:16:36 2008
--- src/ex_cmds2.c	Tue Jan 15 20:41:28 2008
***************
*** 916,922 ****
  
  	QueryPerformanceCounter(tm);
  	QueryPerformanceFrequency(&fr);
! 	tm->QuadPart +=  (double)msec / 1000.0 * (double)fr.QuadPart;
  # else
  	long	    usec;
  
--- 916,922 ----
  
  	QueryPerformanceCounter(tm);
  	QueryPerformanceFrequency(&fr);
! 	tm->QuadPart += (LONGLONG)((double)msec / 1000.0 * (double)fr.QuadPart);
  # else
  	long	    usec;
  
*** ../vim-7.1.231/src/netbeans.c	Sat Jan  5 18:06:33 2008
--- src/netbeans.c	Mon Jan 14 21:11:02 2008
***************
*** 1217,1223 ****
  
      oldtext = ml_get(lnum);
      oldlen = STRLEN(oldtext);
!     if (first >= oldlen || oldlen == 0)  /* just in case */
  	return;
      if (lastbyte >= oldlen)
  	lastbyte = oldlen - 1;
--- 1217,1223 ----
  
      oldtext = ml_get(lnum);
      oldlen = STRLEN(oldtext);
!     if (first >= (colnr_T)oldlen || oldlen == 0)  /* just in case */
  	return;
      if (lastbyte >= oldlen)
  	lastbyte = oldlen - 1;
*** ../vim-7.1.231/src/version.c	Wed Jan 16 20:01:14 2008
--- src/version.c	Fri Jan 18 11:38:39 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     232,
  /**/

-- 
Why is "abbreviation" such a long word?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.233
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.233
Problem:    Crash when doing Insert mode completion for a user defined
	    command.  (Yegappan Lakshmanan)
Solution:   Don't use the non-existing command line.
Files:	    src/ex_getln.c


*** ../vim-7.1.232/src/ex_getln.c	Fri Jan  4 15:16:57 2008
--- src/ex_getln.c	Fri Jan 18 13:07:11 2008
***************
*** 4655,4661 ****
  static void * call_user_expand_func __ARGS((void *(*user_expand_func) __ARGS((char_u *, int, char_u **, int)), expand_T	*xp, int *num_file, char_u ***file));
  
  /*
!  * call "user_expand_func()" to invoke a user defined VimL function and return
   * the result (either a string or a List).
   */
      static void *
--- 4655,4661 ----
  static void * call_user_expand_func __ARGS((void *(*user_expand_func) __ARGS((char_u *, int, char_u **, int)), expand_T	*xp, int *num_file, char_u ***file));
  
  /*
!  * Call "user_expand_func()" to invoke a user defined VimL function and return
   * the result (either a string or a List).
   */
      static void *
***************
*** 4677,4687 ****
      *num_file = 0;
      *file = NULL;
  
!     keep = ccline.cmdbuff[ccline.cmdlen];
!     ccline.cmdbuff[ccline.cmdlen] = 0;
!     sprintf((char *)num, "%d", ccline.cmdpos);
      args[0] = xp->xp_pattern;
-     args[1] = ccline.cmdbuff;
      args[2] = num;
  
      /* Save the cmdline, we don't know what the function may do. */
--- 4677,4698 ----
      *num_file = 0;
      *file = NULL;
  
!     if (ccline.cmdbuff == NULL)
!     {
! 	/* Completion from Insert mode, pass fake arguments. */
! 	keep = 0;
! 	sprintf((char *)num, "%d", STRLEN(xp->xp_pattern));
! 	args[1] = xp->xp_pattern;
!     }
!     else
!     {
! 	/* Completion on the command line, pass real arguments. */
! 	keep = ccline.cmdbuff[ccline.cmdlen];
! 	ccline.cmdbuff[ccline.cmdlen] = 0;
! 	sprintf((char *)num, "%d", ccline.cmdpos);
! 	args[1] = ccline.cmdbuff;
!     }
      args[0] = xp->xp_pattern;
      args[2] = num;
  
      /* Save the cmdline, we don't know what the function may do. */
***************
*** 4694,4701 ****
  
      ccline = save_ccline;
      current_SID = save_current_SID;
! 
!     ccline.cmdbuff[ccline.cmdlen] = keep;
  
      return ret;
  }
--- 4705,4712 ----
  
      ccline = save_ccline;
      current_SID = save_current_SID;
!     if (ccline.cmdbuff != NULL)
! 	ccline.cmdbuff[ccline.cmdlen] = keep;
  
      return ret;
  }
*** ../vim-7.1.232/src/version.c	Fri Jan 18 11:40:02 2008
--- src/version.c	Fri Jan 18 13:01:05 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     233,
  /**/

-- 
"I love deadlines.  I especially like the whooshing sound they
make as they go flying by."
                         -- Douglas Adams

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.234
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.234
Problem:    When diff'ing three files the third one isn't displayed correctly.
	    (Gary Johnson)
Solution:   Compute the size of diff blocks correctly when merging blocks.
	    Compute filler lines correctly when scrolling.
Files:	    src/diff.c


*** ../vim-7.1.233/src/diff.c	Fri Oct 19 18:57:33 2007
--- src/diff.c	Fri Jan 18 17:32:31 2008
***************
*** 1299,1305 ****
  	    }
  	    else
  		/* second overlap of new block with existing block */
! 		dp->df_count[idx_new] += count_new - count_orig;
  
  	    /* Adjust the size of the block to include all the lines to the
  	     * end of the existing block or the new diff, whatever ends last. */
--- 1299,1307 ----
  	    }
  	    else
  		/* second overlap of new block with existing block */
! 		dp->df_count[idx_new] += count_new - count_orig
! 		    + dpl->df_lnum[idx_orig] + dpl->df_count[idx_orig]
! 		    - (dp->df_lnum[idx_orig] + dp->df_count[idx_orig]);
  
  	    /* Adjust the size of the block to include all the lines to the
  	     * end of the existing block or the new diff, whatever ends last. */
***************
*** 1628,1641 ****
      win_T	*fromwin;
      win_T	*towin;
  {
!     buf_T	*buf = fromwin->w_buffer;
      linenr_T	lnum = fromwin->w_topline;
!     int		idx;
      diff_T	*dp;
      int		i;
  
!     idx = diff_buf_idx(buf);
!     if (idx == DB_COUNT)
  	return;		/* safety check */
  
      if (curtab->tp_diff_invalid)
--- 1630,1645 ----
      win_T	*fromwin;
      win_T	*towin;
  {
!     buf_T	*frombuf = fromwin->w_buffer;
      linenr_T	lnum = fromwin->w_topline;
!     int		fromidx;
!     int		toidx;
      diff_T	*dp;
+     int		max_count;
      int		i;
  
!     fromidx = diff_buf_idx(frombuf);
!     if (fromidx == DB_COUNT)
  	return;		/* safety check */
  
      if (curtab->tp_diff_invalid)
***************
*** 1645,1686 ****
  
      /* search for a change that includes "lnum" in the list of diffblocks. */
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
! 	if (lnum <= dp->df_lnum[idx] + dp->df_count[idx])
  	    break;
      if (dp == NULL)
      {
  	/* After last change, compute topline relative to end of file; no
  	 * filler lines. */
  	towin->w_topline = towin->w_buffer->b_ml.ml_line_count
! 					   - (buf->b_ml.ml_line_count - lnum);
      }
      else
      {
  	/* Find index for "towin". */
! 	i = diff_buf_idx(towin->w_buffer);
! 	if (i == DB_COUNT)
  	    return;		/* safety check */
  
! 	towin->w_topline = lnum + (dp->df_lnum[i] - dp->df_lnum[idx]);
! 	if (lnum >= dp->df_lnum[idx])
  	{
! 	    /* Inside a change: compute filler lines. */
! 	    if (dp->df_count[i] == dp->df_count[idx])
  		towin->w_topfill = fromwin->w_topfill;
! 	    else if (dp->df_count[i] > dp->df_count[idx])
  	    {
! 		if (lnum == dp->df_lnum[idx] + dp->df_count[idx])
! 		    towin->w_topline = dp->df_lnum[i] + dp->df_count[i]
! 							 - fromwin->w_topfill;
  	    }
! 	    else
  	    {
! 		if (towin->w_topline >= dp->df_lnum[i] + dp->df_count[i])
  		{
! 		    if (diff_flags & DIFF_FILLER)
! 			towin->w_topfill = dp->df_lnum[idx]
! 						   + dp->df_count[idx] - lnum;
! 		    towin->w_topline = dp->df_lnum[i] + dp->df_count[i];
  		}
  	    }
  	}
--- 1649,1720 ----
  
      /* search for a change that includes "lnum" in the list of diffblocks. */
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
! 	if (lnum <= dp->df_lnum[fromidx] + dp->df_count[fromidx])
  	    break;
      if (dp == NULL)
      {
  	/* After last change, compute topline relative to end of file; no
  	 * filler lines. */
  	towin->w_topline = towin->w_buffer->b_ml.ml_line_count
! 				       - (frombuf->b_ml.ml_line_count - lnum);
      }
      else
      {
  	/* Find index for "towin". */
! 	toidx = diff_buf_idx(towin->w_buffer);
! 	if (toidx == DB_COUNT)
  	    return;		/* safety check */
  
! 	towin->w_topline = lnum + (dp->df_lnum[toidx] - dp->df_lnum[fromidx]);
! 	if (lnum >= dp->df_lnum[fromidx])
  	{
! 	    /* Inside a change: compute filler lines. With three or more
! 	     * buffers we need to know the largest count. */
! 	    max_count = 0;
! 	    for (i = 0; i < DB_COUNT; ++i)
! 		if (curtab->tp_diffbuf[i] != NULL
! 					       && max_count < dp->df_count[i])
! 		    max_count = dp->df_count[i];
! 
! 	    if (dp->df_count[toidx] == dp->df_count[fromidx])
! 	    {
! 		/* same number of lines: use same filler count */
  		towin->w_topfill = fromwin->w_topfill;
! 	    }
! 	    else if (dp->df_count[toidx] > dp->df_count[fromidx])
  	    {
! 		if (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])
! 		{
! 		    /* more lines in towin and fromwin doesn't show diff
! 		     * lines, only filler lines */
! 		    if (max_count - fromwin->w_topfill >= dp->df_count[toidx])
! 		    {
! 			/* towin also only shows filler lines */
! 			towin->w_topline = dp->df_lnum[toidx]
! 						       + dp->df_count[toidx];
! 			towin->w_topfill = fromwin->w_topfill;
! 		    }
! 		    else
! 			/* towin still has some diff lines to show */
! 			towin->w_topline = dp->df_lnum[toidx]
! 					     + max_count - fromwin->w_topfill;
! 		}
  	    }
! 	    else if (towin->w_topline >= dp->df_lnum[toidx]
! 							+ dp->df_count[toidx])
  	    {
! 		/* less lines in towin and no diff lines to show: compute
! 		 * filler lines */
! 		towin->w_topline = dp->df_lnum[toidx] + dp->df_count[toidx];
! 		if (diff_flags & DIFF_FILLER)
  		{
! 		    if (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])
! 			/* fromwin is also out of diff lines */
! 			towin->w_topfill = fromwin->w_topfill;
! 		    else
! 			/* fromwin has some diff lines */
! 			towin->w_topfill = dp->df_lnum[fromidx]
! 							   + max_count - lnum;
  		}
  	    }
  	}
*** ../vim-7.1.233/src/version.c	Fri Jan 18 13:15:32 2008
--- src/version.c	Fri Jan 18 17:37:32 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     234,
  /**/

-- 
ERIC IDLE PLAYED: THE DEAD COLLECTOR, MR BINT (A VILLAGE NE'ER-DO -WELL VERY
                  KEEN ON BURNING WITCHES), SIR ROBIN, THE GUARD WHO DOESN'T
                  HICOUGH BUT TRIES TO GET THINGS STRAIGHT, CONCORDE (SIR
                  LAUNCELOT'S TRUSTY STEED), ROGER THE SHRUBBER (A SHRUBBER),
                  BROTHER MAYNARD
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.235
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.235
Problem:    Pattern matching is slow when using a lot of simple patterns.
Solution:   Avoid allocating memory by not freeing it when it's not so much.
	    (Alexei Alexandrov)
Files:	    src/regexp.c


*** ../vim-7.1.234/src/regexp.c	Wed Jan  2 15:34:48 2008
--- src/regexp.c	Fri Jan 18 20:35:21 2008
***************
*** 378,391 ****
  
  static char_u		*reg_prev_sub = NULL;
  
- #if defined(EXITFREE) || defined(PROTO)
-     void
- free_regexp_stuff()
- {
-     vim_free(reg_prev_sub);
- }
- #endif
- 
  /*
   * REGEXP_INRANGE contains all characters which are always special in a []
   * range after '\'.
--- 378,383 ----
***************
*** 3206,3217 ****
  } backpos_T;
  
  /*
!  * regstack and backpos are used by regmatch().  They are kept over calls to
!  * avoid invoking malloc() and free() often.
   */
! static garray_T	regstack;	/* stack with regitem_T items, sometimes
! 				   preceded by regstar_T or regbehind_T. */
! static garray_T	backpos;	/* table with backpos_T for BACK */
  
  /*
   * Get pointer to the line "lnum", which is relative to "reg_firstlnum".
--- 3198,3236 ----
  } backpos_T;
  
  /*
!  * "regstack" and "backpos" are used by regmatch().  They are kept over calls
!  * to avoid invoking malloc() and free() often.
!  * "regstack" is a stack with regitem_T items, sometimes preceded by regstar_T
!  * or regbehind_T.
!  * "backpos_T" is a table with backpos_T for BACK
!  */
! static garray_T	regstack = {0, 0, 0, 0, NULL};
! static garray_T	backpos = {0, 0, 0, 0, NULL};
! 
! /*
!  * Both for regstack and backpos tables we use the following strategy of
!  * allocation (to reduce malloc/free calls):
!  * - Initial size is fairly small.
!  * - When needed, the tables are grown bigger (8 times at first, double after
!  *   that).
!  * - After executing the match we free the memory only if the array has grown.
!  *   Thus the memory is kept allocated when it's at the initial size.
!  * This makes it fast while not keeping a lot of memory allocated.
!  * A three times speed increase was observed when using many simple patterns.
   */
! #define REGSTACK_INITIAL	2048
! #define BACKPOS_INITIAL		64
! 
! #if defined(EXITFREE) || defined(PROTO)
!     void
! free_regexp_stuff()
! {
!     ga_clear(&regstack);
!     ga_clear(&backpos);
!     vim_free(reg_tofree);
!     vim_free(reg_prev_sub);
! }
! #endif
  
  /*
   * Get pointer to the line "lnum", which is relative to "reg_firstlnum".
***************
*** 3346,3360 ****
      char_u	*s;
      long	retval = 0L;
  
!     reg_tofree = NULL;
! 
!     /* Init the regstack empty.  Use an item size of 1 byte, since we push
!      * different things onto it.  Use a large grow size to avoid reallocating
!      * it too often. */
!     ga_init2(&regstack, 1, 10000);
! 
!     /* Init the backpos table empty. */
!     ga_init2(&backpos, sizeof(backpos_T), 10);
  
      if (REG_MULTI)
      {
--- 3365,3389 ----
      char_u	*s;
      long	retval = 0L;
  
!     /* Create "regstack" and "backpos" if they are not allocated yet.
!      * We allocate *_INITIAL amount of bytes first and then set the grow size
!      * to much bigger value to avoid many malloc calls in case of deep regular
!      * expressions.  */
!     if (regstack.ga_data == NULL)
!     {
! 	/* Use an item size of 1 byte, since we push different things
! 	 * onto the regstack. */
! 	ga_init2(&regstack, 1, REGSTACK_INITIAL);
! 	ga_grow(&regstack, REGSTACK_INITIAL);
! 	regstack.ga_growsize = REGSTACK_INITIAL * 8;
!     }
! 
!     if (backpos.ga_data == NULL)
!     {
! 	ga_init2(&backpos, sizeof(backpos_T), BACKPOS_INITIAL);
! 	ga_grow(&backpos, BACKPOS_INITIAL);
! 	backpos.ga_growsize = BACKPOS_INITIAL * 8;
!     }
  
      if (REG_MULTI)
      {
***************
*** 3525,3533 ****
      }
  
  theend:
!     vim_free(reg_tofree);
!     ga_clear(&regstack);
!     ga_clear(&backpos);
  
      return retval;
  }
--- 3554,3570 ----
      }
  
  theend:
!     /* Free "reg_tofree" when it's a bit big.
!      * Free regstack and backpos if they are bigger than their initial size. */
!     if (reg_tofreelen > 400)
!     {
! 	vim_free(reg_tofree);
! 	reg_tofree = NULL;
!     }
!     if (regstack.ga_maxlen > REGSTACK_INITIAL)
! 	ga_clear(&regstack);
!     if (backpos.ga_maxlen > BACKPOS_INITIAL)
! 	ga_clear(&backpos);
  
      return retval;
  }
***************
*** 3717,3724 ****
  #define RA_MATCH	4	/* successful match */
  #define RA_NOMATCH	5	/* didn't match */
  
!   /* Init the regstack and backpos table empty.  They are initialized and
!    * freed in vim_regexec_both() to reduce malloc()/free() calls. */
    regstack.ga_len = 0;
    backpos.ga_len = 0;
  
--- 3754,3761 ----
  #define RA_MATCH	4	/* successful match */
  #define RA_NOMATCH	5	/* didn't match */
  
!   /* Make "regstack" and "backpos" empty.  They are allocated and freed in
!    * vim_regexec_both() to reduce malloc()/free() calls. */
    regstack.ga_len = 0;
    backpos.ga_len = 0;
  
*** ../vim-7.1.234/src/version.c	Fri Jan 18 17:39:10 2008
--- src/version.c	Fri Jan 18 20:33:26 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     235,
  /**/

-- 
NEIL INNES PLAYED: THE FIRST SELF-DESTRUCTIVE MONK, ROBIN'S LEAST FAVORITE
                   MINSTREL, THE PAGE CRUSHED BY A RABBIT, THE OWNER OF A DUCK
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.236
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.236
Problem:    When using 'incsearch' and 'hlsearch' a complicated pattern may
	    make Vim hang until CTRL-C is pressed.
Solution:   Add the 'redrawtime' option.
Files:	    runtime/doc/options.txt, src/ex_cmds.c, src/ex_docmd.c,
	    src/ex_getln.c, src/gui.c, src/misc1.c, src/normal.c,
	    src/option.c, src/quickfix.c, src/regexp.c, src/proto/regexp.pro,
	    src/proto/search.pro, src/search.c, src/screen.c,
	    src/option.h, src/spell.c, src/structs.h, src/syntax.c, src/tag.c,
	    src/vim.h


*** ../vim-7.1.235/runtime/doc/options.txt	Sun Aug 12 16:55:01 2007
--- runtime/doc/options.txt	Sat Jan 19 14:01:22 2008
***************
*** 3618,3623 ****
--- 3636,3642 ----
  	When you get bored looking at the highlighted matches, you can turn it
  	off with |:nohlsearch|.  As soon as you use a search command, the
  	highlighting comes back.
+ 	'redrawtime' specifies the maximum time spend on finding matches.
  	When the search pattern can match an end-of-line, Vim will try to
  	highlight all of the matched text.  However, this depends on where the
  	search starts.  This will be the first line in the window or the first
***************
*** 3851,3856 ****
--- 3870,3879 ----
  	original position when no match is found and when pressing <Esc>.  You
  	still need to finish the search command with <Enter> to move the
  	cursor to the match.
+ 	When compiled with the |+reltime| feature Vim only searches for about
+ 	half a second.  With a complicated pattern and/or a lot of text the
+ 	match may not be found.  This is to avoid that Vim hangs while you
+ 	are typing the pattern.
  	The highlighting can be set with the 'i' flag in 'highlight'.
  	See also: 'hlsearch'.
  	CTRL-L can be used to add one character from after the current match
***************
*** 5185,5190 ****
--- 5210,5227 ----
  	{not in Vi:}  When using the ":view" command the 'readonly' option is
  	set for the newly edited buffer.
  
+ 						*'redrawtime'* *'rdt'*
+ 'redrawtime' 'rdt'	number	(default 2000)
+ 			global
+ 			{not in Vi}
+ 			{only available when compiled with the |+reltime|
+ 			feature}
+ 	The time in milliseconds for redrawing the display.  This applies to
+ 	searching for patterns for 'hlsearch' and |:match| highlighting.
+ 	When redrawing takes more than this many milliseconds no further
+ 	matches will be highlighted.  This is used to avoid that Vim hangs
+ 	when using a very complicated pattern.
+ 
  						*'remap'* *'noremap'*
  'remap'			boolean	(default on)
  			global
*** ../vim-7.1.235/src/ex_cmds.c	Sun Jan 13 13:30:34 2008
--- src/ex_cmds.c	Sat Jan 19 13:04:28 2008
***************
*** 4446,4452 ****
  #endif
  		); ++lnum)
      {
! 	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum, (colnr_T)0);
  	if (nmatch)
  	{
  	    colnr_T	copycol;
--- 4446,4453 ----
  #endif
  		); ++lnum)
      {
! 	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
! 							    (colnr_T)0, NULL);
  	if (nmatch)
  	{
  	    colnr_T	copycol;
***************
*** 4957,4963 ****
  			|| (do_ask && !re_lookbehind(regmatch.regprog))
  			|| nmatch_tl > 0
  			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
! 				       curbuf, sub_firstlnum, matchcol)) == 0
  			|| regmatch.startpos[0].lnum > 0)
  		{
  		    if (new_start != NULL)
--- 4958,4965 ----
  			|| (do_ask && !re_lookbehind(regmatch.regprog))
  			|| nmatch_tl > 0
  			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
! 							curbuf, sub_firstlnum,
! 							 matchcol, NULL)) == 0
  			|| regmatch.startpos[0].lnum > 0)
  		{
  		    if (new_start != NULL)
***************
*** 5022,5028 ****
  		    }
  		    if (nmatch == -1 && !lastone)
  			nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,
! 						     sub_firstlnum, matchcol);
  
  		    /*
  		     * 5. break if there isn't another match in this line
--- 5024,5030 ----
  		    }
  		    if (nmatch == -1 && !lastone)
  			nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,
! 					       sub_firstlnum, matchcol, NULL);
  
  		    /*
  		     * 5. break if there isn't another match in this line
***************
*** 5252,5258 ****
      for (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)
      {
  	/* a match on this line? */
! 	match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum, (colnr_T)0);
  	if ((type == 'g' && match) || (type == 'v' && !match))
  	{
  	    ml_setmarked(lnum);
--- 5254,5261 ----
      for (lnum = eap->line1; lnum <= eap->line2 && !got_int; ++lnum)
      {
  	/* a match on this line? */
! 	match = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
! 							    (colnr_T)0, NULL);
  	if ((type == 'g' && match) || (type == 'v' && !match))
  	{
  	    ml_setmarked(lnum);
*** ../vim-7.1.235/src/ex_docmd.c	Sun Jan 13 17:11:25 2008
--- src/ex_docmd.c	Fri Jan 18 21:01:16 2008
***************
*** 3931,3937 ****
  				curwin->w_cursor.col = 0;
  			    searchcmdlen = 0;
  			    if (!do_search(NULL, c, cmd, 1L,
! 				      SEARCH_HIS + SEARCH_MSG + SEARCH_START))
  			    {
  				curwin->w_cursor = pos;
  				cmd = NULL;
--- 3931,3938 ----
  				curwin->w_cursor.col = 0;
  			    searchcmdlen = 0;
  			    if (!do_search(NULL, c, cmd, 1L,
! 					SEARCH_HIS + SEARCH_MSG + SEARCH_START,
! 					NULL))
  			    {
  				curwin->w_cursor = pos;
  				cmd = NULL;
*** ../vim-7.1.235/src/ex_getln.c	Fri Jan 18 13:15:32 2008
--- src/ex_getln.c	Fri Jan 18 21:34:42 2008
***************
*** 1709,1714 ****
--- 1709,1717 ----
  	if (p_is && !cmd_silent && (firstc == '/' || firstc == '?'))
  	{
  	    pos_T	end_pos;
+ #ifdef FEAT_RELTIME
+ 	    proftime_T	tm;
+ #endif
  
  	    /* if there is a character waiting, search and redraw later */
  	    if (char_avail())
***************
*** 1727,1734 ****
  		cursor_off();		/* so the user knows we're busy */
  		out_flush();
  		++emsg_off;    /* So it doesn't beep if bad expr */
  		i = do_search(NULL, firstc, ccline.cmdbuff, count,
! 			SEARCH_KEEP + SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK);
  		--emsg_off;
  		/* if interrupted while searching, behave like it failed */
  		if (got_int)
--- 1730,1747 ----
  		cursor_off();		/* so the user knows we're busy */
  		out_flush();
  		++emsg_off;    /* So it doesn't beep if bad expr */
+ #ifdef FEAT_RELTIME
+ 		/* Set the time limit to half a second. */
+ 		profile_setlimit(500L, &tm);
+ #endif
  		i = do_search(NULL, firstc, ccline.cmdbuff, count,
! 			SEARCH_KEEP + SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK,
! #ifdef FEAT_RELTIME
! 			&tm
! #else
! 			NULL
! #endif
! 			);
  		--emsg_off;
  		/* if interrupted while searching, behave like it failed */
  		if (got_int)
*** ../vim-7.1.235/src/gui.c	Thu Jan  3 16:14:25 2008
--- src/gui.c	Fri Jan 18 21:01:36 2008
***************
*** 5052,5058 ****
  	/* Search for the next match. */
  	i = msg_scroll;
  	do_search(NULL, down ? '/' : '?', ga.ga_data, 1L,
! 						    SEARCH_MSG + SEARCH_MARK);
  	msg_scroll = i;	    /* don't let an error message set msg_scroll */
      }
  
--- 5052,5058 ----
  	/* Search for the next match. */
  	i = msg_scroll;
  	do_search(NULL, down ? '/' : '?', ga.ga_data, 1L,
! 					      SEARCH_MSG + SEARCH_MARK, NULL);
  	msg_scroll = i;	    /* don't let an error message set msg_scroll */
      }
  
*** ../vim-7.1.235/src/misc1.c	Thu Jan  3 12:42:38 2008
--- src/misc1.c	Sat Jan 19 13:04:39 2008
***************
*** 437,443 ****
      {
  	regmatch.rmm_ic = FALSE;
  	regmatch.rmm_maxcol = 0;
! 	if (vim_regexec_multi(&regmatch, curwin, curbuf, lnum, (colnr_T)0))
  	{
  	    pos.lnum = regmatch.endpos[0].lnum + lnum;
  	    pos.col = regmatch.endpos[0].col;
--- 437,444 ----
      {
  	regmatch.rmm_ic = FALSE;
  	regmatch.rmm_maxcol = 0;
! 	if (vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
! 							    (colnr_T)0, NULL))
  	{
  	    pos.lnum = regmatch.endpos[0].lnum + lnum;
  	    pos.col = regmatch.endpos[0].col;
*** ../vim-7.1.235/src/normal.c	Sat Jan 12 17:11:25 2008
--- src/normal.c	Fri Jan 18 21:01:47 2008
***************
*** 6093,6099 ****
      curwin->w_set_curswant = TRUE;
  
      i = do_search(cap->oap, dir, pat, cap->count1,
! 				 opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG);
      if (i == 0)
  	clearop(cap->oap);
      else
--- 6093,6099 ----
      curwin->w_set_curswant = TRUE;
  
      i = do_search(cap->oap, dir, pat, cap->count1,
! 			   opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, NULL);
      if (i == 0)
  	clearop(cap->oap);
      else
*** ../vim-7.1.235/src/option.c	Tue Oct  2 20:40:01 2007
--- src/option.c	Sat Jan 19 13:44:33 2008
***************
*** 1991,1996 ****
--- 1991,2003 ----
      {"redraw",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
+     {"redrawtime",  "rdt",  P_NUM|P_VI_DEF,
+ #ifdef FEAT_RELTIME
+ 			    (char_u *)&p_rdt, PV_NONE,
+ #else
+ 			    (char_u *)NULL, PV_NONE,
+ #endif
+ 			    {(char_u *)2000L, (char_u *)0L}},
      {"remap",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_remap, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L}},
*** ../vim-7.1.235/src/quickfix.c	Sun Sep 30 14:00:41 2007
--- src/quickfix.c	Sat Jan 19 13:04:53 2008
***************
*** 1803,1809 ****
  	    /* Move the cursor to the first line in the buffer */
  	    save_cursor = curwin->w_cursor;
  	    curwin->w_cursor.lnum = 0;
! 	    if (!do_search(NULL, '/', qf_ptr->qf_pattern, (long)1, SEARCH_KEEP))
  		curwin->w_cursor = save_cursor;
  	}
  
--- 1803,1810 ----
  	    /* Move the cursor to the first line in the buffer */
  	    save_cursor = curwin->w_cursor;
  	    curwin->w_cursor.lnum = 0;
! 	    if (!do_search(NULL, '/', qf_ptr->qf_pattern, (long)1,
! 							   SEARCH_KEEP, NULL))
  		curwin->w_cursor = save_cursor;
  	}
  
***************
*** 3159,3165 ****
  	    {
  		col = 0;
  		while (vim_regexec_multi(&regmatch, curwin, buf, lnum,
! 								     col) > 0)
  		{
  		    ;
  		    if (qf_add_entry(qi, &prevp,
--- 3160,3166 ----
  	    {
  		col = 0;
  		while (vim_regexec_multi(&regmatch, curwin, buf, lnum,
! 							       col, NULL) > 0)
  		{
  		    ;
  		    if (qf_add_entry(qi, &prevp,
*** ../vim-7.1.235/src/regexp.c	Fri Jan 18 20:36:40 2008
--- src/regexp.c	Sat Jan 19 15:18:12 2008
***************
*** 3040,3046 ****
  } save_se_T;
  
  static char_u	*reg_getline __ARGS((linenr_T lnum));
! static long	vim_regexec_both __ARGS((char_u *line, colnr_T col));
  static long	regtry __ARGS((regprog_T *prog, colnr_T col));
  static void	cleanup_subexpr __ARGS((void));
  #ifdef FEAT_SYN_HL
--- 3040,3046 ----
  } save_se_T;
  
  static char_u	*reg_getline __ARGS((linenr_T lnum));
! static long	vim_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
  static long	regtry __ARGS((regprog_T *prog, colnr_T col));
  static void	cleanup_subexpr __ARGS((void));
  #ifdef FEAT_SYN_HL
***************
*** 3284,3290 ****
      ireg_icombine = FALSE;
  #endif
      ireg_maxcol = 0;
!     return (vim_regexec_both(line, col) != 0);
  }
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
--- 3284,3290 ----
      ireg_icombine = FALSE;
  #endif
      ireg_maxcol = 0;
!     return (vim_regexec_both(line, col, NULL) != 0);
  }
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) \
***************
*** 3308,3314 ****
      ireg_icombine = FALSE;
  #endif
      ireg_maxcol = 0;
!     return (vim_regexec_both(line, col) != 0);
  }
  #endif
  
--- 3308,3314 ----
      ireg_icombine = FALSE;
  #endif
      ireg_maxcol = 0;
!     return (vim_regexec_both(line, col, NULL) != 0);
  }
  #endif
  
***************
*** 3321,3332 ****
   * match otherwise.
   */
      long
! vim_regexec_multi(rmp, win, buf, lnum, col)
      regmmatch_T	*rmp;
      win_T	*win;		/* window in which to search or NULL */
      buf_T	*buf;		/* buffer in which to search */
      linenr_T	lnum;		/* nr of line to start looking for match */
      colnr_T	col;		/* column to start looking for match */
  {
      long	r;
      buf_T	*save_curbuf = curbuf;
--- 3321,3333 ----
   * match otherwise.
   */
      long
! vim_regexec_multi(rmp, win, buf, lnum, col, tm)
      regmmatch_T	*rmp;
      win_T	*win;		/* window in which to search or NULL */
      buf_T	*buf;		/* buffer in which to search */
      linenr_T	lnum;		/* nr of line to start looking for match */
      colnr_T	col;		/* column to start looking for match */
+     proftime_T	*tm;		/* timeout limit or NULL */
  {
      long	r;
      buf_T	*save_curbuf = curbuf;
***************
*** 3346,3352 ****
  
      /* Need to switch to buffer "buf" to make vim_iswordc() work. */
      curbuf = buf;
!     r = vim_regexec_both(NULL, col);
      curbuf = save_curbuf;
  
      return r;
--- 3347,3353 ----
  
      /* Need to switch to buffer "buf" to make vim_iswordc() work. */
      curbuf = buf;
!     r = vim_regexec_both(NULL, col, tm);
      curbuf = save_curbuf;
  
      return r;
***************
*** 3356,3365 ****
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
      static long
! vim_regexec_both(line, col)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
  {
      regprog_T	*prog;
      char_u	*s;
--- 3357,3368 ----
   * Match a regexp against a string ("line" points to the string) or multiple
   * lines ("line" is NULL, use reg_getline()).
   */
+ /*ARGSUSED*/
      static long
! vim_regexec_both(line, col, tm)
      char_u	*line;
      colnr_T	col;		/* column to start looking for match */
+     proftime_T	*tm;		/* timeout limit or NULL */
  {
      regprog_T	*prog;
      char_u	*s;
***************
*** 3502,3507 ****
--- 3505,3513 ----
      }
      else
      {
+ #ifdef FEAT_RELTIME
+ 	int tm_count = 0;
+ #endif
  	/* Messy cases:  unanchored match. */
  	while (!got_int)
  	{
***************
*** 3550,3555 ****
--- 3556,3570 ----
  	    else
  #endif
  		++col;
+ #ifdef FEAT_RELTIME
+ 	    /* Check for timeout once in a twenty times to avoid overhead. */
+ 	    if (tm != NULL && ++tm_count == 20)
+ 	    {
+ 		tm_count = 0;
+ 		if (profile_passed_limit(tm))
+ 		    break;
+ 	    }
+ #endif
  	}
      }
  
*** ../vim-7.1.235/src/proto/regexp.pro	Sat May  5 19:42:08 2007
--- src/proto/regexp.pro	Sat Jan 19 13:14:09 2008
***************
*** 1,13 ****
  /* regexp.c */
- void free_regexp_stuff __ARGS((void));
  int re_multiline __ARGS((regprog_T *prog));
  int re_lookbehind __ARGS((regprog_T *prog));
  char_u *skip_regexp __ARGS((char_u *startp, int dirc, int magic, char_u **newp));
  regprog_T *vim_regcomp __ARGS((char_u *expr, int re_flags));
  int vim_regcomp_had_eol __ARGS((void));
  int vim_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
  int vim_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
! long vim_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col));
  reg_extmatch_T *ref_extmatch __ARGS((reg_extmatch_T *em));
  void unref_extmatch __ARGS((reg_extmatch_T *em));
  char_u *regtilde __ARGS((char_u *source, int magic));
--- 1,13 ----
  /* regexp.c */
  int re_multiline __ARGS((regprog_T *prog));
  int re_lookbehind __ARGS((regprog_T *prog));
  char_u *skip_regexp __ARGS((char_u *startp, int dirc, int magic, char_u **newp));
  regprog_T *vim_regcomp __ARGS((char_u *expr, int re_flags));
  int vim_regcomp_had_eol __ARGS((void));
+ void free_regexp_stuff __ARGS((void));
  int vim_regexec __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
  int vim_regexec_nl __ARGS((regmatch_T *rmp, char_u *line, colnr_T col));
! long vim_regexec_multi __ARGS((regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm));
  reg_extmatch_T *ref_extmatch __ARGS((reg_extmatch_T *em));
  void unref_extmatch __ARGS((reg_extmatch_T *em));
  char_u *regtilde __ARGS((char_u *source, int magic));
*** ../vim-7.1.235/src/proto/search.pro	Sun Jan  6 20:05:36 2008
--- src/proto/search.pro	Fri Jan 18 21:03:49 2008
***************
*** 11,17 ****
  void set_last_search_pat __ARGS((char_u *s, int idx, int magic, int setlast));
  void last_pat_prog __ARGS((regmmatch_T *regmatch));
  int searchit __ARGS((win_T *win, buf_T *buf, pos_T *pos, int dir, char_u *pat, long count, int options, int pat_use, linenr_T stop_lnum, proftime_T *tm));
! int do_search __ARGS((oparg_T *oap, int dirc, char_u *pat, long count, int options));
  int search_for_exact_line __ARGS((buf_T *buf, pos_T *pos, int dir, char_u *pat));
  int searchc __ARGS((cmdarg_T *cap, int t_cmd));
  pos_T *findmatch __ARGS((oparg_T *oap, int initc));
--- 11,17 ----
  void set_last_search_pat __ARGS((char_u *s, int idx, int magic, int setlast));
  void last_pat_prog __ARGS((regmmatch_T *regmatch));
  int searchit __ARGS((win_T *win, buf_T *buf, pos_T *pos, int dir, char_u *pat, long count, int options, int pat_use, linenr_T stop_lnum, proftime_T *tm));
! int do_search __ARGS((oparg_T *oap, int dirc, char_u *pat, long count, int options, proftime_T *tm));
  int search_for_exact_line __ARGS((buf_T *buf, pos_T *pos, int dir, char_u *pat));
  int searchc __ARGS((cmdarg_T *cap, int t_cmd));
  pos_T *findmatch __ARGS((oparg_T *oap, int initc));
*** ../vim-7.1.235/src/search.c	Sun Jan  6 20:05:36 2008
--- src/search.c	Sat Jan 19 13:13:25 2008
***************
*** 606,612 ****
  		 * Look for a match somewhere in line "lnum".
  		 */
  		nmatched = vim_regexec_multi(&regmatch, win, buf,
! 							    lnum, (colnr_T)0);
  		/* Abort searching on an error (e.g., out of stack). */
  		if (called_emsg)
  		    break;
--- 606,618 ----
  		 * Look for a match somewhere in line "lnum".
  		 */
  		nmatched = vim_regexec_multi(&regmatch, win, buf,
! 						      lnum, (colnr_T)0,
! #ifdef FEAT_RELTIME
! 						      tm
! #else
! 						      NULL
! #endif
! 						      );
  		/* Abort searching on an error (e.g., out of stack). */
  		if (called_emsg)
  		    break;
***************
*** 615,623 ****
  		    /* match may actually be in another line when using \zs */
  		    matchpos = regmatch.startpos[0];
  		    endpos = regmatch.endpos[0];
! # ifdef FEAT_EVAL
  		    submatch = first_submatch(&regmatch);
! # endif
  		    /* Line me be past end of buffer for "\n\zs". */
  		    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)
  			ptr = (char_u *)"";
--- 621,629 ----
  		    /* match may actually be in another line when using \zs */
  		    matchpos = regmatch.startpos[0];
  		    endpos = regmatch.endpos[0];
! #ifdef FEAT_EVAL
  		    submatch = first_submatch(&regmatch);
! #endif
  		    /* Line me be past end of buffer for "\n\zs". */
  		    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)
  			ptr = (char_u *)"";
***************
*** 693,699 ****
  			    if (ptr[matchcol] == NUL
  				    || (nmatched = vim_regexec_multi(&regmatch,
  					      win, buf, lnum + matchpos.lnum,
! 					      matchcol)) == 0)
  			    {
  				match_ok = FALSE;
  				break;
--- 699,711 ----
  			    if (ptr[matchcol] == NUL
  				    || (nmatched = vim_regexec_multi(&regmatch,
  					      win, buf, lnum + matchpos.lnum,
! 					      matchcol,
! #ifdef FEAT_RELTIME
! 					      tm
! #else
! 					      NULL
! #endif
! 					      )) == 0)
  			    {
  				match_ok = FALSE;
  				break;
***************
*** 799,805 ****
  			    if (ptr[matchcol] == NUL
  				    || (nmatched = vim_regexec_multi(&regmatch,
  					      win, buf, lnum + matchpos.lnum,
! 							      matchcol)) == 0)
  				break;
  
  			    /* Need to get the line pointer again, a
--- 811,823 ----
  			    if (ptr[matchcol] == NUL
  				    || (nmatched = vim_regexec_multi(&regmatch,
  					      win, buf, lnum + matchpos.lnum,
! 					      matchcol,
! #ifdef FEAT_RELTIME
! 					      tm
! #else
! 					      NULL
! #endif
! 					    )) == 0)
  				break;
  
  			    /* Need to get the line pointer again, a
***************
*** 977,988 ****
   * return 0 for failure, 1 for found, 2 for found and line offset added
   */
      int
! do_search(oap, dirc, pat, count, options)
      oparg_T	    *oap;	/* can be NULL */
      int		    dirc;	/* '/' or '?' */
      char_u	   *pat;
      long	    count;
      int		    options;
  {
      pos_T	    pos;	/* position of the last match */
      char_u	    *searchstr;
--- 995,1007 ----
   * return 0 for failure, 1 for found, 2 for found and line offset added
   */
      int
! do_search(oap, dirc, pat, count, options, tm)
      oparg_T	    *oap;	/* can be NULL */
      int		    dirc;	/* '/' or '?' */
      char_u	   *pat;
      long	    count;
      int		    options;
+     proftime_T	    *tm;	/* timeout limit or NULL */
  {
      pos_T	    pos;	/* position of the last match */
      char_u	    *searchstr;
***************
*** 1256,1262 ****
  		       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS
  			+ SEARCH_MSG + SEARCH_START
  			+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),
! 		RE_LAST, (linenr_T)0, NULL);
  
  	if (dircp != NULL)
  	    *dircp = dirc;	/* restore second '/' or '?' for normal_cmd() */
--- 1275,1281 ----
  		       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS
  			+ SEARCH_MSG + SEARCH_START
  			+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),
! 		RE_LAST, (linenr_T)0, tm);
  
  	if (dircp != NULL)
  	    *dircp = dirc;	/* restore second '/' or '?' for normal_cmd() */
*** ../vim-7.1.235/src/screen.c	Sat Jan 12 16:45:25 2008
--- src/screen.c	Sat Jan 19 13:52:29 2008
***************
*** 848,858 ****
--- 848,863 ----
  	cur->hl.buf = buf;
  	cur->hl.lnum = 0;
  	cur->hl.first_lnum = 0;
+ # ifdef FEAT_RELTIME
+ 	/* Set the time limit to 'redrawtime'. */
+ 	profile_setlimit(p_rdt, &(cur->hl.tm));
+ # endif
  	cur = cur->next;
      }
      search_hl.buf = buf;
      search_hl.lnum = 0;
      search_hl.first_lnum = 0;
+     /* time limit is set at the toplevel, for all windows */
  #endif
  
  #ifdef FEAT_LINEBREAK
***************
*** 6462,6467 ****
--- 6467,6476 ----
      {
  	last_pat_prog(&search_hl.rm);
  	search_hl.attr = hl_attr(HLF_L);
+ # ifdef FEAT_RELTIME
+ 	/* Set the time limit to 'redrawtime'. */
+ 	profile_setlimit(p_rdt, &search_hl.tm);
+ # endif
      }
  }
  
***************
*** 6587,6592 ****
--- 6596,6609 ----
      called_emsg = FALSE;
      for (;;)
      {
+ #ifdef FEAT_RELTIME
+ 	/* Stop searching after passing the time limit. */
+ 	if (profile_passed_limit(&(shl->tm)))
+ 	{
+ 	    shl->lnum = 0;		/* no match found in time */
+ 	    break;
+ 	}
+ #endif
  	/* Three situations:
  	 * 1. No useful previous match: search from start of line.
  	 * 2. Not Vi compatible or empty match: continue at next character.
***************
*** 6620,6626 ****
  	    matchcol = shl->rm.endpos[0].col;
  
  	shl->lnum = lnum;
! 	nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol);
  	if (called_emsg)
  	{
  	    /* Error while handling regexp: stop using this regexp. */
--- 6637,6649 ----
  	    matchcol = shl->rm.endpos[0].col;
  
  	shl->lnum = lnum;
! 	nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol,
! #ifdef FEAT_RELTIME
! 		&(shl->tm)
! #else
! 		NULL
! #endif
! 		);
  	if (called_emsg)
  	{
  	    /* Error while handling regexp: stop using this regexp. */
*** ../vim-7.1.235/src/option.h	Thu May 10 20:34:47 2007
--- src/option.h	Sat Jan 19 13:45:51 2008
***************
*** 633,638 ****
--- 633,641 ----
  #ifdef FEAT_SEARCHPATH
  EXTERN char_u	*p_cdpath;	/* 'cdpath' */
  #endif
+ #ifdef FEAT_RELTIME
+ EXTERN long	p_rdt;		/* 'redrawtime' */
+ #endif
  EXTERN int	p_remap;	/* 'remap' */
  EXTERN long	p_report;	/* 'report' */
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
*** ../vim-7.1.235/src/spell.c	Sat Jan 12 16:45:25 2008
--- src/spell.c	Fri Jan 18 21:02:47 2008
***************
*** 10343,10349 ****
      curwin->w_cursor.lnum = 0;
      while (!got_int)
      {
! 	if (do_search(NULL, '/', frompat, 1L, SEARCH_KEEP) == 0
  						   || u_save_cursor() == FAIL)
  	    break;
  
--- 10343,10349 ----
      curwin->w_cursor.lnum = 0;
      while (!got_int)
      {
! 	if (do_search(NULL, '/', frompat, 1L, SEARCH_KEEP, NULL) == 0
  						   || u_save_cursor() == FAIL)
  	    break;
  
*** ../vim-7.1.235/src/structs.h	Mon Oct  1 22:53:27 2007
--- src/structs.h	Fri Jan 18 21:18:53 2008
***************
*** 1717,1722 ****
--- 1717,1725 ----
      linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
      colnr_T	startcol; /* in win_line() points to char where HL starts */
      colnr_T	endcol;	 /* in win_line() points to char where HL ends */
+ #ifdef FEAT_RELTIME
+     proftime_T	tm;	/* for a time limit */
+ #endif
  } match_T;
  
  /*
*** ../vim-7.1.235/src/syntax.c	Sun Jan 13 17:39:29 2008
--- src/syntax.c	Sat Jan 19 13:13:49 2008
***************
*** 3097,3103 ****
      colnr_T	col;
  {
      rmp->rmm_maxcol = syn_buf->b_p_smc;
!     if (vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col) > 0)
      {
  	rmp->startpos[0].lnum += lnum;
  	rmp->endpos[0].lnum += lnum;
--- 3097,3103 ----
      colnr_T	col;
  {
      rmp->rmm_maxcol = syn_buf->b_p_smc;
!     if (vim_regexec_multi(rmp, syn_win, syn_buf, lnum, col, NULL) > 0)
      {
  	rmp->startpos[0].lnum += lnum;
  	rmp->endpos[0].lnum += lnum;
*** ../vim-7.1.235/src/tag.c	Thu May 10 19:44:07 2007
--- src/tag.c	Fri Jan 18 21:03:41 2008
***************
*** 3191,3197 ****
  #endif
  	    save_lnum = curwin->w_cursor.lnum;
  	    curwin->w_cursor.lnum = 0;	/* start search before first line */
! 	    if (do_search(NULL, pbuf[0], pbuf + 1, (long)1, search_options))
  		retval = OK;
  	    else
  	    {
--- 3191,3198 ----
  #endif
  	    save_lnum = curwin->w_cursor.lnum;
  	    curwin->w_cursor.lnum = 0;	/* start search before first line */
! 	    if (do_search(NULL, pbuf[0], pbuf + 1, (long)1,
! 							search_options, NULL))
  		retval = OK;
  	    else
  	    {
***************
*** 3203,3209 ****
  		 */
  		p_ic = TRUE;
  		if (!do_search(NULL, pbuf[0], pbuf + 1, (long)1,
! 							      search_options))
  		{
  		    /*
  		     * Failed to find pattern, take a guess: "^func  ("
--- 3204,3210 ----
  		 */
  		p_ic = TRUE;
  		if (!do_search(NULL, pbuf[0], pbuf + 1, (long)1,
! 							search_options, NULL))
  		{
  		    /*
  		     * Failed to find pattern, take a guess: "^func  ("
***************
*** 3213,3225 ****
  		    cc = *tagp.tagname_end;
  		    *tagp.tagname_end = NUL;
  		    sprintf((char *)pbuf, "^%s\\s\\*(", tagp.tagname);
! 		    if (!do_search(NULL, '/', pbuf, (long)1, search_options))
  		    {
  			/* Guess again: "^char * \<func  (" */
  			sprintf((char *)pbuf, "^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*(",
  								tagp.tagname);
  			if (!do_search(NULL, '/', pbuf, (long)1,
! 							      search_options))
  			    found = 0;
  		    }
  		    *tagp.tagname_end = cc;
--- 3214,3227 ----
  		    cc = *tagp.tagname_end;
  		    *tagp.tagname_end = NUL;
  		    sprintf((char *)pbuf, "^%s\\s\\*(", tagp.tagname);
! 		    if (!do_search(NULL, '/', pbuf, (long)1,
! 							search_options, NULL))
  		    {
  			/* Guess again: "^char * \<func  (" */
  			sprintf((char *)pbuf, "^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*(",
  								tagp.tagname);
  			if (!do_search(NULL, '/', pbuf, (long)1,
! 							search_options, NULL))
  			    found = 0;
  		    }
  		    *tagp.tagname_end = cc;
*** ../vim-7.1.235/src/vim.h	Sat Jan  5 13:34:01 2008
--- src/vim.h	Fri Jan 18 21:29:22 2008
***************
*** 1550,1555 ****
--- 1550,1565 ----
  # define MB_MAXBYTES	21
  #endif
  
+ #if (defined(FEAT_PROFILE) || defined(FEAT_RELTIME)) && !defined(PROTO)
+ # ifdef WIN3264
+ typedef LARGE_INTEGER proftime_T;
+ # else
+ typedef struct timeval proftime_T;
+ # endif
+ #else
+ typedef int proftime_T;	    /* dummy for function prototypes */
+ #endif
+ 
  /* Include option.h before structs.h, because the number of window-local and
   * buffer-local options is used there. */
  #include "option.h"	    /* options and default values */
***************
*** 1760,1775 ****
  # include <io.h>	    /* for access() */
  
  # define stat(a,b) (access(a,0) ? -1 : stat(a,b))
- #endif
- 
- #if (defined(FEAT_PROFILE) || defined(FEAT_RELTIME)) && !defined(PROTO)
- # ifdef WIN3264
- typedef LARGE_INTEGER proftime_T;
- # else
- typedef struct timeval proftime_T;
- # endif
- #else
- typedef int proftime_T;	    /* dummy for function prototypes */
  #endif
  
  #include "ex_cmds.h"	    /* Ex command defines */
--- 1770,1775 ----
*** ../vim-7.1.235/src/version.c	Fri Jan 18 20:36:40 2008
--- src/version.c	Sat Jan 19 15:19:48 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     236,
  /**/

-- 
Every time I lose weight, it finds me again!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.237
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.237
Problem:    Compiler warning on an Alpha processor in Motif code.
Solution:   Change a typecast. (Adri Verhoef)
Files:	    src/gui_motif.c


*** ../vim-7.1.236/src/gui_motif.c	Thu May 10 19:51:05 2007
--- src/gui_motif.c	Mon Jan 21 21:03:55 2008
***************
*** 3813,3819 ****
  
      XtAddCallback(frdp->find, XmNactivateCallback,
  	    find_replace_callback,
! 	    (XtPointer) (do_replace ? FRD_R_FINDNEXT : FRD_FINDNEXT));
  
      if (do_replace)
      {
--- 3813,3819 ----
  
      XtAddCallback(frdp->find, XmNactivateCallback,
  	    find_replace_callback,
! 	    (do_replace ? (XtPointer)FRD_R_FINDNEXT : (XtPointer)FRD_FINDNEXT));
  
      if (do_replace)
      {
*** ../vim-7.1.236/src/version.c	Sat Jan 19 15:55:51 2008
--- src/version.c	Tue Jan 22 11:05:12 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     237,
  /**/

-- 
I am always surprised in the Linux world how quickly solutions can be
obtained.  (Imagine sending an email to Bill Gates, asking why Windows
crashed, and how to fix it...  and then getting an answer that fixed the
problem... <0>_<0> !)		              -- Mark Langdon

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.238
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.238
Problem:    Using the 'c' flag with searchpair() may cause it to fail.  Using
	    the 'r' flag doesn't work when 'wrapscan' is set.  (A.Politz)
Solution:   Only use the 'c' flag for the first search, not for repeating.
	    When using 'r' imply 'W'. (Antony Scriven)
Files:	    src/eval.c


*** ../vim-7.1.237/src/eval.c	Sat Jan 12 16:45:25 2008
--- src/eval.c	Tue Jan 22 11:42:28 2008
***************
*** 14189,14194 ****
--- 14189,14198 ----
  	goto theend;
      }
  
+     /* Using 'r' implies 'W', otherwise it doesn't work. */
+     if (flags & SP_REPEAT)
+ 	p_ws = FALSE;
+ 
      /* Optional fifth argument: skip expression */
      if (argvars[3].v_type == VAR_UNKNOWN
  	    || argvars[4].v_type == VAR_UNKNOWN)
***************
*** 14344,14349 ****
--- 14348,14356 ----
  		incl(&pos);
  	}
  	foundpos = pos;
+ 
+ 	/* clear the start flag to avoid getting stuck here */
+ 	options &= ~SEARCH_START;
  
  	/* If the skip pattern matches, ignore this match. */
  	if (*skip != NUL)
*** ../vim-7.1.237/src/version.c	Tue Jan 22 11:06:06 2008
--- src/version.c	Tue Jan 22 11:57:28 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     238,
  /**/

-- 
To keep milk from turning sour: Keep it in the cow.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.239
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.239 (after 7.1.233)
Problem:    Compiler warning for sprintf() argument.
Solution:   Add a typecast. (Nico Weber)
Files:	    src/ex_getln.c


*** ../vim-7.1.238/src/ex_getln.c	Sat Jan 19 15:55:51 2008
--- src/ex_getln.c	Tue Jan 22 12:40:54 2008
***************
*** 4694,4700 ****
      {
  	/* Completion from Insert mode, pass fake arguments. */
  	keep = 0;
! 	sprintf((char *)num, "%d", STRLEN(xp->xp_pattern));
  	args[1] = xp->xp_pattern;
      }
      else
--- 4694,4700 ----
      {
  	/* Completion from Insert mode, pass fake arguments. */
  	keep = 0;
! 	sprintf((char *)num, "%d", (int)STRLEN(xp->xp_pattern));
  	args[1] = xp->xp_pattern;
      }
      else
*** ../vim-7.1.238/src/version.c	Tue Jan 22 11:58:41 2008
--- src/version.c	Tue Jan 22 12:42:36 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     239,
  /**/

-- 
We apologise again for the fault in the subtitles.  Those responsible for
sacking the people who have just been sacked have been sacked.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.240
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.240
Problem:    When "gUe" turns a German sharp s into SS the operation stops
            before the end of the word.  Latin2 has the same sharp s but it's
            not changed to SS there.
Solution:   Make sure all the characters are operated upon.  Detect the sharp
            s in latin2.  Also fixes that changing case of a multi-byte
            character that changes the byte cound doesn't always work.
Files:      src/ops.c


*** ../vim-7.1.239/src/ops.c	Wed Jan 16 20:01:14 2008
--- src/ops.c	Tue Jan 22 16:00:07 2008
***************
*** 2184,2189 ****
--- 2184,2191 ----
  }
  #endif
  
+ static int swapchars __ARGS((int op_type, pos_T *pos, int length));
+ 
  /*
   * Handle the (non-standard vi) tilde operator.  Also for "gu", "gU" and "g?".
   */
***************
*** 2194,2202 ****
      pos_T		pos;
  #ifdef FEAT_VISUAL
      struct block_def	bd;
-     int			todo;
  #endif
!     int			did_change = 0;
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
--- 2196,2203 ----
      pos_T		pos;
  #ifdef FEAT_VISUAL
      struct block_def	bd;
  #endif
!     int			did_change;
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
***************
*** 2210,2225 ****
  	{
  	    block_prep(oap, &bd, pos.lnum, FALSE);
  	    pos.col = bd.textcol;
! 	    for (todo = bd.textlen; todo > 0; --todo)
! 	    {
! # ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    todo -= (*mb_ptr2len)(ml_get_pos(&pos)) - 1;
! # endif
! 		did_change |= swapchar(oap->op_type, &pos);
! 		if (inc(&pos) == -1)	    /* at end of file */
! 		    break;
! 	    }
  # ifdef FEAT_NETBEANS_INTG
  	    if (usingNetbeans && did_change)
  	    {
--- 2211,2218 ----
  	{
  	    block_prep(oap, &bd, pos.lnum, FALSE);
  	    pos.col = bd.textcol;
! 	    did_change = swapchars(oap->op_type, &pos, bd.textlen);
! 
  # ifdef FEAT_NETBEANS_INTG
  	    if (usingNetbeans && did_change)
  	    {
***************
*** 2249,2261 ****
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	while (ltoreq(pos, oap->end))
! 	{
! 	    did_change |= swapchar(oap->op_type, &pos);
! 	    if (inc(&pos) == -1)    /* at end of file */
! 		break;
! 	}
! 
  	if (did_change)
  	{
  	    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,
--- 2242,2248 ----
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	did_change = swapchars(oap->op_type, &pos, oap->end.col - pos.col + 1);
  	if (did_change)
  	{
  	    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,
***************
*** 2309,2314 ****
--- 2296,2337 ----
  }
  
  /*
+  * Invoke swapchar() on "length" bytes at position "pos".
+  * "pos" is advanced to just after the changed characters.
+  * "length" is rounded up to include the whole last multi-byte character.
+  * Also works correctly when the number of bytes changes.
+  * Returns TRUE if some character was changed.
+  */
+     static int
+ swapchars(op_type, pos, length)
+     int		op_type;
+     pos_T	*pos;
+     int		length;
+ {
+     int todo;
+     int	did_change = 0;
+ 
+     for (todo = length; todo > 0; --todo)
+     {
+ # ifdef FEAT_MBYTE
+ 	int pos_col = pos->col;
+ 
+ 	if (has_mbyte)
+ 	    /* we're counting bytes, not characters */
+ 	    todo -= (*mb_ptr2len)(ml_get_pos(pos)) - 1;
+ # endif
+ 	did_change |= swapchar(op_type, pos);
+ # ifdef FEAT_MBYTE
+ 	/* Changing German sharp s to SS increases the column. */
+ 	todo += pos->col - pos_col;
+ # endif
+ 	if (inc(pos) == -1)    /* at end of file */
+ 	    break;
+     }
+     return did_change;
+ }
+ 
+ /*
   * If op_type == OP_UPPER: make uppercase,
   * if op_type == OP_LOWER: make lowercase,
   * if op_type == OP_ROT13: do rot13 encoding,
***************
*** 2330,2336 ****
  	return FALSE;
  
  #ifdef FEAT_MBYTE
!     if (op_type == OP_UPPER && enc_latin1like && c == 0xdf)
      {
  	pos_T   sp = curwin->w_cursor;
  
--- 2353,2360 ----
  	return FALSE;
  
  #ifdef FEAT_MBYTE
!     if (op_type == OP_UPPER && c == 0xdf
! 		      && (enc_latin1like || STRCMP(p_enc, "iso-8859-2") == 0))
      {
  	pos_T   sp = curwin->w_cursor;
  
*** ../vim-7.1.239/src/version.c	Tue Jan 22 12:44:03 2008
--- src/version.c	Tue Jan 22 15:36:36 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     240,
  /**/

-- 
ARTHUR: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot.
        King of all Britons, defeator of the Saxons, sovereign of all England!
   [Pause]
SOLDIER: Get away!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.241
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.241
Problem:    Focus change events not always ignored.  (Erik Falor)
Solution:   Ignore K_IGNORE in Insert mode in a few more places.
Files:	    src/edit.c


*** ../vim-7.1.240/src/edit.c	Wed Jan 16 20:01:14 2008
--- src/edit.c	Tue Jan 22 17:45:32 2008
***************
*** 703,712 ****
  #endif
  
  	/*
! 	 * Get a character for Insert mode.
  	 */
  	lastc = c;			/* remember previous char for CTRL-D */
! 	c = safe_vgetc();
  
  #ifdef FEAT_AUTOCMD
  	/* Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V. */
--- 703,715 ----
  #endif
  
  	/*
! 	 * Get a character for Insert mode.  Ignore K_IGNORE.
  	 */
  	lastc = c;			/* remember previous char for CTRL-D */
! 	do
! 	{
! 	    c = safe_vgetc();
! 	} while (c == K_IGNORE);
  
  #ifdef FEAT_AUTOCMD
  	/* Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V. */
***************
*** 777,783 ****
  	/* Prepare for or stop CTRL-X mode.  This doesn't do completion, but
  	 * it does fix up the text when finishing completion. */
  	compl_get_longest = FALSE;
! 	if (c != K_IGNORE && ins_compl_prep(c))
  	    continue;
  #endif
  
--- 780,786 ----
  	/* Prepare for or stop CTRL-X mode.  This doesn't do completion, but
  	 * it does fix up the text when finishing completion. */
  	compl_get_longest = FALSE;
! 	if (ins_compl_prep(c))
  	    continue;
  #endif
  
***************
*** 4516,4530 ****
  	else
  	{
  	    /* Need to get the character to have KeyTyped set.  We'll put it
! 	     * back with vungetc() below. */
  	    c = safe_vgetc();
  
! 	    /* Don't interrupt completion when the character wasn't typed,
! 	     * e.g., when doing @q to replay keys. */
! 	    if (c != Ctrl_R && KeyTyped)
! 		compl_interrupted = TRUE;
! 
! 	    vungetc(c);
  	}
      }
      if (compl_pending != 0 && !got_int)
--- 4519,4535 ----
  	else
  	{
  	    /* Need to get the character to have KeyTyped set.  We'll put it
! 	     * back with vungetc() below.  But skip K_IGNORE. */
  	    c = safe_vgetc();
+ 	    if (c != K_IGNORE)
+ 	    {
+ 		/* Don't interrupt completion when the character wasn't typed,
+ 		 * e.g., when doing @q to replay keys. */
+ 		if (c != Ctrl_R && KeyTyped)
+ 		    compl_interrupted = TRUE;
  
! 		vungetc(c);
! 	    }
  	}
      }
      if (compl_pending != 0 && !got_int)
*** ../vim-7.1.240/src/version.c	Tue Jan 22 16:01:25 2008
--- src/version.c	Tue Jan 22 17:48:46 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     241,
  /**/

-- 
The problem with political jokes is that they get elected.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.242
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.242 (after 7.1.005)
Problem:    "cib" doesn't work properly on "(x)". (Tim Pope)
Solution:   Use ltoreq() instead of lt().  Also fix "ciT" on "<a>x</a>".
Files:	    src/search.c


*** ../vim-7.1.241/src/search.c	Sat Jan 19 15:55:51 2008
--- src/search.c	Sat Jan 26 13:56:06 2008
***************
*** 3637,3643 ****
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (lt(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
--- 3637,3643 ----
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (ltoreq(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
***************
*** 3754,3759 ****
--- 3754,3763 ----
      old_pos = curwin->w_cursor;
      old_end = curwin->w_cursor;		    /* remember where we started */
      old_start = old_end;
+ #ifdef FEAT_VISUAL
+     if (!VIsual_active || *p_sel == 'e')
+ #endif
+ 	decl(&old_end);			    /* old_end is inclusive */
  
      /*
       * If we start on "<aaa>" select that block.
*** ../vim-7.1.241/src/version.c	Tue Jan 22 17:49:17 2008
--- src/version.c	Sat Jan 26 21:14:05 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     242,
  /**/

-- 
DENNIS: Oh, very nice. King, eh!  I expect you've got a palace and fine
        clothes and courtiers and plenty of food.  And how d'you get that?  By
        exploiting the workers! By hanging on to outdated imperialist dogma
        which perpetuates the social and economic differences in our society!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.243
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.243 (after 7.1.240)
Problem:    "U" doesn't work on all text in Visual mode. (Adri Verhoef)
Solution:   Loop over all the lines to be changed.  Add tests for this.
Files:	    src/ops.c, src/testdir/test39.in, src/testdir/test39.ok


*** ../vim-7.1.242/src/ops.c	Tue Jan 22 16:01:25 2008
--- src/ops.c	Mon Feb  4 22:23:22 2008
***************
*** 2197,2203 ****
  #ifdef FEAT_VISUAL
      struct block_def	bd;
  #endif
!     int			did_change;
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
--- 2197,2203 ----
  #ifdef FEAT_VISUAL
      struct block_def	bd;
  #endif
!     int			did_change = FALSE;
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
***************
*** 2242,2248 ****
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	did_change = swapchars(oap->op_type, &pos, oap->end.col - pos.col + 1);
  	if (did_change)
  	{
  	    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,
--- 2242,2259 ----
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	if (pos.lnum == oap->end.lnum)
! 	    did_change = swapchars(oap->op_type, &pos,
! 						  oap->end.col - pos.col + 1);
! 	else
! 	    for (;;)
! 	    {
! 		did_change |= swapchars(oap->op_type, &pos,
! 				pos.lnum == oap->end.lnum ? oap->end.col + 1:
! 					   (int)STRLEN(ml_get_pos(&pos)));
! 		if (ltoreq(oap->end, pos) || inc(&pos) == -1)
! 		    break;
! 	    }
  	if (did_change)
  	{
  	    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1,
***************
*** 2314,2330 ****
      for (todo = length; todo > 0; --todo)
      {
  # ifdef FEAT_MBYTE
- 	int pos_col = pos->col;
- 
  	if (has_mbyte)
  	    /* we're counting bytes, not characters */
  	    todo -= (*mb_ptr2len)(ml_get_pos(pos)) - 1;
  # endif
  	did_change |= swapchar(op_type, pos);
- # ifdef FEAT_MBYTE
- 	/* Changing German sharp s to SS increases the column. */
- 	todo += pos->col - pos_col;
- # endif
  	if (inc(pos) == -1)    /* at end of file */
  	    break;
      }
--- 2325,2335 ----
*** ../vim-7.1.242/src/testdir/test39.in	Sun Jun 13 18:21:09 2004
--- src/testdir/test39.in	Wed Feb  6 13:57:37 2008
***************
*** 1,8 ****
--- 1,10 ----
  
  Test Visual block mode commands
+ And test "U" in Visual mode, also on German sharp S.
  
  STARTTEST
  :so small.vim
+ :so mbyte.vim
  /^abcde
  :" Test shift-right of a block
  jlllljj>wlljlll>
***************
*** 14,20 ****
  Gllllkkklllrq
  :" Test block-change
  G$khhhhhkkcmno
! :$-4,$wq! test.out
  ENDTEST
  
  abcdefghijklm
--- 16,37 ----
  Gllllkkklllrq
  :" Test block-change
  G$khhhhhkkcmno
! :$-4,$w! test.out
! :" gUe must uppercase a whole word, also when  changes to SS
! Gothe youtueuu endYpk0wgUe
! :" gUfx must uppercase until x, inclusive.
! O- youtuexu -0fogUfx
! :" VU must uppercase a whole line
! YpkVU
! :" same, when it's the last line in the buffer
! YPGi111VUddP
! :" Uppercase two lines
! Oblah di
! doh dutVkUj
! :" Uppercase part of two lines
! ddppi333k0i222fyllvjfuUk
! :/^the/,$w >> test.out
! :qa!
  ENDTEST
  
  abcdefghijklm
*** ../vim-7.1.242/src/testdir/test39.ok	Sun Jun 13 18:59:28 2004
--- src/testdir/test39.ok	Tue Feb  5 22:25:38 2008
***************
*** 3,5 ****
--- 3,13 ----
  axyzqqqqef mno        ghijklm
  axyzqqqqefgmnoklm
  abcdqqqqijklm
+ the YOUTUSSEUU end
+ - yOUSSTUSSEXu -
+ THE YOUTUSSEUU END
+ 111THE YOUTUSSEUU END
+ BLAH DI
+ DOH DUT
+ 222the yoUTUSSEUU END
+ 333THE YOUTUeuu end
*** ../vim-7.1.242/src/version.c	Sat Jan 26 21:15:00 2008
--- src/version.c	Wed Feb  6 14:41:00 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     243,
  /**/

-- 
It's totally unfair to suggest - as many have - that engineers are socially
inept.  Engineers simply have different objectives when it comes to social
interaction.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.244
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.244
Problem:    GUI may have part of the command line cut off.
Solution:   Don't round the number of lines up, always round down.
	    (Tony Houghton, Scott Dillard)
Files:	    src/gui.c


*** ../vim-7.1.243/src/gui.c	Sat Jan 19 15:55:51 2008
--- src/gui.c	Wed Feb  6 16:43:44 2008
***************
*** 1294,1304 ****
      out_flush();
  
      gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width;
!     gui.num_rows = (pixel_height - gui_get_base_height()
! #if !defined(FEAT_GUI_PHOTON) && !defined(FEAT_GUI_MSWIN)
! 				    + (gui.char_height / 2)
! #endif
! 					) / gui.char_height;
  
      gui_position_components(pixel_width);
  
--- 1294,1300 ----
      out_flush();
  
      gui.num_cols = (pixel_width - gui_get_base_width()) / gui.char_width;
!     gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height;
  
      gui_position_components(pixel_width);
  
*** ../vim-7.1.243/src/version.c	Wed Feb  6 14:43:50 2008
--- src/version.c	Wed Feb  6 17:32:35 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     244,
  /**/

-- 
A consultant is a person who takes your money and annoys your employees while
tirelessly searching for the best way to extend the consulting contract.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.245
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.245
Problem:    Pressing CTRL-\ three times causes Vim to quit.  (Ranganath Rao).
	    Also for f CTRL-\ CTRL-\.
Solution:   When going to cooked mode in mch_delay() set a flag to ignore
	    SIGQUIT.
Files:	    src/os_unix.c


*** ../vim-7.1.244/src/os_unix.c	Sun Jan 13 16:30:23 2008
--- src/os_unix.c	Sun Feb 10 22:07:27 2008
***************
*** 195,200 ****
--- 195,201 ----
  static int	show_shell_mess = TRUE;
  #endif
  static int	deadly_signal = 0;	    /* The signal we caught */
+ static int	in_mch_delay = FALSE;	    /* sleeping in mch_delay() */
  
  static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
  
***************
*** 538,544 ****
      if (ignoreinput)
      {
  	/* Go to cooked mode without echo, to allow SIGINT interrupting us
! 	 * here */
  	old_tmode = curr_tmode;
  	if (curr_tmode == TMODE_RAW)
  	    settmode(TMODE_SLEEP);
--- 539,547 ----
      if (ignoreinput)
      {
  	/* Go to cooked mode without echo, to allow SIGINT interrupting us
! 	 * here.  But we don't want QUIT to kill us (CTRL-\ used in a
! 	 * shell may produce SIGQUIT). */
! 	in_mch_delay = TRUE;
  	old_tmode = curr_tmode;
  	if (curr_tmode == TMODE_RAW)
  	    settmode(TMODE_SLEEP);
***************
*** 602,607 ****
--- 605,611 ----
  #endif
  
  	settmode(old_tmode);
+ 	in_mch_delay = FALSE;
      }
      else
  	WaitForChar(msec);
***************
*** 922,927 ****
--- 926,939 ----
  #endif
  
  #ifdef SIGHASARG
+ # ifdef SIGQUIT
+     /* While in mch_delay() we go to cooked mode to allow a CTRL-C to
+      * interrupt us.  But in cooked mode we may also get SIGQUIT, e.g., when
+      * pressing CTRL-\, but we don't want Vim to exit then. */
+     if (in_mch_delay && sigarg == SIGQUIT)
+ 	SIGRETURN;
+ # endif
+ 
      /* When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return
       * here.  This avoids that a non-reentrant function is interrupted, e.g.,
       * free().  Calling free() again may then cause a crash. */
*** ../vim-7.1.244/src/version.c	Wed Feb  6 17:33:19 2008
--- src/version.c	Sun Feb 10 22:04:09 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     245,
  /**/

-- 
Me?  A skeptic?  I trust you have proof.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.246
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.246
Problem:    Configure hangs when the man pager is something strange. (lorien)
Solution:   Set MANPAGER and PAGER to "cat". (Micah Cowan)
Files:	    src/auto/configure, src/configure.in


*** ../vim-7.1.245/src/auto/configure	Tue Jan  1 16:25:33 2008
--- src/auto/configure	Wed Feb 13 10:22:56 2008
***************
*** 14259,14265 ****
  echo "$as_me:$LINENO: checking how to run man with a section nr" >&5
  echo $ECHO_N "checking how to run man with a section nr... $ECHO_C" >&6
  MANDEF="man"
! (eval man -s 2 read) < /dev/null > /dev/null 2>&5 && MANDEF="man -s"
  echo "$as_me:$LINENO: result: $MANDEF" >&5
  echo "${ECHO_T}$MANDEF" >&6
  if test "$MANDEF" = "man -s"; then
--- 14259,14265 ----
  echo "$as_me:$LINENO: checking how to run man with a section nr" >&5
  echo $ECHO_N "checking how to run man with a section nr... $ECHO_C" >&6
  MANDEF="man"
! (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&5 && MANDEF="man -s"
  echo "$as_me:$LINENO: result: $MANDEF" >&5
  echo "${ECHO_T}$MANDEF" >&6
  if test "$MANDEF" = "man -s"; then
*** ../vim-7.1.245/src/configure.in	Tue Jan  1 16:25:33 2008
--- src/configure.in	Fri Jan 25 20:51:51 2008
***************
*** 2726,2732 ****
  dnl Check how we can run man with a section number
  AC_MSG_CHECKING(how to run man with a section nr)
  MANDEF="man"
! (eval man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
  AC_MSG_RESULT($MANDEF)
  if test "$MANDEF" = "man -s"; then
    AC_DEFINE(USEMAN_S)
--- 2726,2732 ----
  dnl Check how we can run man with a section number
  AC_MSG_CHECKING(how to run man with a section nr)
  MANDEF="man"
! (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
  AC_MSG_RESULT($MANDEF)
  if test "$MANDEF" = "man -s"; then
    AC_DEFINE(USEMAN_S)
*** ../vim-7.1.245/src/version.c	Sun Feb 10 22:25:12 2008
--- src/version.c	Wed Feb 13 10:26:47 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     246,
  /**/

-- 
Anyone who is capable of getting themselves made President should on no
account be allowed to do the job.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.247
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.247
Problem:    When using Netbeans backspacing in Insert mode skips a character
	    now and then. (Ankit Jain)
Solution:   Avoid calling netbeans_removed(), it frees the line pointer.
	    (partly by Dominique Pelle).
Files:	    src/misc1.c


*** ../vim-7.1.246/src/misc1.c	Sat Jan 19 15:55:51 2008
--- src/misc1.c	Wed Feb 13 10:56:16 2008
***************
*** 2270,2282 ****
      /*
       * If the old line has been allocated the deletion can be done in the
       * existing line. Otherwise a new line has to be allocated
       */
-     was_alloced = ml_line_alloced();	    /* check if oldp was allocated */
  #ifdef FEAT_NETBEANS_INTG
!     if (was_alloced && usingNetbeans)
! 	netbeans_removed(curbuf, lnum, col, count);
!     /* else is handled by ml_replace() */
  #endif
      if (was_alloced)
  	newp = oldp;			    /* use same allocated memory */
      else
--- 2270,2285 ----
      /*
       * If the old line has been allocated the deletion can be done in the
       * existing line. Otherwise a new line has to be allocated
+      * Can't do this when using Netbeans, because we would need to invoke
+      * netbeans_removed(), which deallocates the line.  Let ml_replace() take
+      * care of notifiying Netbeans.
       */
  #ifdef FEAT_NETBEANS_INTG
!     if (usingNetbeans)
! 	was_alloced = FALSE;
!     else
  #endif
+ 	was_alloced = ml_line_alloced();    /* check if oldp was allocated */
      if (was_alloced)
  	newp = oldp;			    /* use same allocated memory */
      else
***************
*** 3978,3984 ****
  	    /* remove trailing path separator */
  #ifndef MACOS_CLASSIC
  	    /* With MacOS path (with  colons) the final colon is required */
! 	    /* to avoid confusion between absoulute and relative path */
  	    if (pend > p && after_pathsep(p, pend))
  		--pend;
  #endif
--- 3981,3987 ----
  	    /* remove trailing path separator */
  #ifndef MACOS_CLASSIC
  	    /* With MacOS path (with  colons) the final colon is required */
! 	    /* to avoid confusion between absolute and relative path */
  	    if (pend > p && after_pathsep(p, pend))
  		--pend;
  #endif
***************
*** 5689,5695 ****
  	    else if (lookfor_ctor_init || class_or_struct)
  	    {
  		/* we have something found, that looks like the start of
! 		 * cpp-base-class-declaration or contructor-initialization */
  		cpp_base_class = TRUE;
  		lookfor_ctor_init = class_or_struct = FALSE;
  		*col = 0;
--- 5692,5698 ----
  	    else if (lookfor_ctor_init || class_or_struct)
  	    {
  		/* we have something found, that looks like the start of
! 		 * cpp-base-class-declaration or constructor-initialization */
  		cpp_base_class = TRUE;
  		lookfor_ctor_init = class_or_struct = FALSE;
  		*col = 0;
***************
*** 6146,6152 ****
      pos_T	our_paren_pos;
      char_u	*start;
      int		start_brace;
! #define BRACE_IN_COL0		1	    /* '{' is in comumn 0 */
  #define BRACE_AT_START		2	    /* '{' is at start of line */
  #define BRACE_AT_END		3	    /* '{' is at end of line */
      linenr_T	ourscope;
--- 6149,6155 ----
      pos_T	our_paren_pos;
      char_u	*start;
      int		start_brace;
! #define BRACE_IN_COL0		1	    /* '{' is in column 0 */
  #define BRACE_AT_START		2	    /* '{' is at start of line */
  #define BRACE_AT_END		3	    /* '{' is at end of line */
      linenr_T	ourscope;
***************
*** 6369,6375 ****
  		    if (curwin->w_cursor.lnum > 1)
  		    {
  			/* If the start comment string matches in the previous
! 			 * line, use the indent of that line pluss offset.  If
  			 * the middle comment string matches in the previous
  			 * line, use the indent of that line.  XXX */
  			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
--- 6372,6378 ----
  		    if (curwin->w_cursor.lnum > 1)
  		    {
  			/* If the start comment string matches in the previous
! 			 * line, use the indent of that line plus offset.  If
  			 * the middle comment string matches in the previous
  			 * line, use the indent of that line.  XXX */
  			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
***************
*** 8222,8228 ****
  
  		    if (*that && *that != ';') /* not a comment line */
  		    {
! 			/* test *that != '(' to accomodate first let/do
  			 * argument if it is more than one line */
  			if (!vi_lisp && *that != '(' && *that != '[')
  			    firsttry++;
--- 8225,8231 ----
  
  		    if (*that && *that != ';') /* not a comment line */
  		    {
! 			/* test *that != '(' to accommodate first let/do
  			 * argument if it is more than one line */
  			if (!vi_lisp && *that != '(' && *that != '[')
  			    firsttry++;
*** ../vim-7.1.246/src/version.c	Wed Feb 13 10:27:28 2008
--- src/version.c	Wed Feb 13 10:56:42 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     247,
  /**/

-- 
Far back in the mists of ancient time, in the great and glorious days of the
former Galactic Empire, life was wild, rich and largely tax free.
Mighty starships plied their way between exotic suns, seeking adventure and
reward among the furthest reaches of Galactic space.  In those days, spirits
were brave, the stakes were high, men were real men, women were real women
and small furry creatures from Alpha Centauri were real small furry creatures
from Alpha Centauri.  And all dared to brave unknown terrors, to do mighty
deeds, to boldly split infinitives that no man had split before -- and thus
was the Empire forged.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.248
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.248
Problem:    Can't set the '" mark.  Can't know if setpos() was successful.
Solution:   Allow setting the '" mark with setpos().  Have setpos() return a
	    value indicating success/failure.
Files:	    runtime/doc/eval.txt, src/eval.c, src/mark.c


*** ../vim-7.1.247/runtime/doc/eval.txt	Sat Jan 12 16:45:25 2008
--- runtime/doc/eval.txt	Wed Feb 13 11:49:16 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Jan 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Feb 13
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 4523,4528 ****
--- 4528,4536 ----
  		character.  E.g., a position within a <Tab> or after the last
  		character.
  
+ 		Returns 0 when the position could be set, -1 otherwise.
+ 		An error message is given if {expr} is invalid.
+ 
  		Also see |getpos()|
  
  		This does not restore the preferred column for moving
*** ../vim-7.1.247/src/eval.c	Tue Jan 22 11:58:41 2008
--- src/eval.c	Wed Feb 13 11:54:09 2008
***************
*** 14776,14799 ****
      int		fnum;
      char_u	*name;
  
      name = get_tv_string_chk(argvars);
      if (name != NULL)
      {
  	if (list2fpos(&argvars[1], &pos, &fnum) == OK)
  	{
  	    --pos.col;
! 	    if (name[0] == '.')		/* cursor */
  	    {
  		if (fnum == curbuf->b_fnum)
  		{
  		    curwin->w_cursor = pos;
  		    check_cursor();
  		}
  		else
  		    EMSG(_(e_invarg));
  	    }
! 	    else if (name[0] == '\'')	/* mark */
! 		(void)setmark_pos(name[1], &pos, fnum);
  	    else
  		EMSG(_(e_invarg));
  	}
--- 14778,14808 ----
      int		fnum;
      char_u	*name;
  
+     rettv->vval.v_number = -1;
      name = get_tv_string_chk(argvars);
      if (name != NULL)
      {
  	if (list2fpos(&argvars[1], &pos, &fnum) == OK)
  	{
  	    --pos.col;
! 	    if (name[0] == '.' && name[1] == NUL)
  	    {
+ 		/* set cursor */
  		if (fnum == curbuf->b_fnum)
  		{
  		    curwin->w_cursor = pos;
  		    check_cursor();
+ 		    rettv->vval.v_number = 0;
  		}
  		else
  		    EMSG(_(e_invarg));
  	    }
! 	    else if (name[0] == '\'' && name[1] != NUL && name[2] == NUL)
! 	    {
! 		/* set mark */
! 		if (setmark_pos(name[1], &pos, fnum) == OK)
! 		    rettv->vval.v_number = 0;
! 	    }
  	    else
  		EMSG(_(e_invarg));
  	}
*** ../vim-7.1.247/src/mark.c	Thu Jan  3 20:21:34 2008
--- src/mark.c	Wed Feb 13 11:42:30 2008
***************
*** 79,84 ****
--- 79,90 ----
  	return OK;
      }
  
+     if (c == '"')
+     {
+ 	curbuf->b_last_cursor = *pos;
+ 	return OK;
+     }
+ 
      /* Allow setting '[ and '] for an autocommand that simulates reading a
       * file. */
      if (c == '[')
*** ../vim-7.1.247/src/version.c	Wed Feb 13 10:57:11 2008
--- src/version.c	Wed Feb 13 12:39:23 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     248,
  /**/

-- 
"Making it up?  Why should I want to make anything up?  Life's bad enough
as it is without wanting to invent any more of it."
		-- Marvin, the Paranoid Android in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.249
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.249
Problem:    After "U" the cursor can be past end of line.  (Adri Verhoef)
Solution:   Adjust the cursor position in u_undoline().
Files:	    src/undo.c


*** ../vim-7.1.248/src/undo.c	Sat Nov 10 22:50:20 2007
--- src/undo.c	Wed Feb 13 15:17:54 2008
***************
*** 1814,1826 ****
      if (undo_off)
  	return;
  
!     if (curbuf->b_u_line_ptr == NULL ||
! 			curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)
      {
  	beep_flush();
  	return;
      }
! 	/* first save the line for the 'u' command */
      if (u_savecommon(curbuf->b_u_line_lnum - 1,
  				curbuf->b_u_line_lnum + 1, (linenr_T)0) == FAIL)
  	return;
--- 1814,1827 ----
      if (undo_off)
  	return;
  
!     if (curbuf->b_u_line_ptr == NULL
! 			|| curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)
      {
  	beep_flush();
  	return;
      }
! 
!     /* first save the line for the 'u' command */
      if (u_savecommon(curbuf->b_u_line_lnum - 1,
  				curbuf->b_u_line_lnum + 1, (linenr_T)0) == FAIL)
  	return;
***************
*** 1840,1845 ****
--- 1841,1847 ----
  	curbuf->b_u_line_colnr = curwin->w_cursor.col;
      curwin->w_cursor.col = t;
      curwin->w_cursor.lnum = curbuf->b_u_line_lnum;
+     check_cursor_col();
  }
  
  /*
*** ../vim-7.1.248/src/version.c	Wed Feb 13 12:41:30 2008
--- src/version.c	Wed Feb 13 15:20:12 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     249,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
1. At lunch time, sit in your parked car with sunglasses on and point
   a hair dryer at passing cars. See if they slow down.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.250
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.250
Problem:    ":setglobal fenc=anything" gives an error message in a buffer
	    where 'modifiable' is off.  (Ben Schmidt)
Solution:   Don't give an error if 'modifiable' doesn't matter.
Files:	    src/option.c


*** ../vim-7.1.249/src/option.c	Sat Jan 19 15:55:51 2008
--- src/option.c	Wed Feb 13 18:31:39 2008
***************
*** 5671,5677 ****
      {
  	if (gvarp == &p_fenc)
  	{
! 	    if (!curbuf->b_p_ma)
  		errmsg = e_modifiable;
  	    else if (vim_strchr(*varp, ',') != NULL)
  		/* No comma allowed in 'fileencoding'; catches confusing it
--- 5671,5677 ----
      {
  	if (gvarp == &p_fenc)
  	{
! 	    if (!curbuf->b_p_ma && opt_flags != OPT_GLOBAL)
  		errmsg = e_modifiable;
  	    else if (vim_strchr(*varp, ',') != NULL)
  		/* No comma allowed in 'fileencoding'; catches confusing it
*** ../vim-7.1.249/src/version.c	Wed Feb 13 15:20:59 2008
--- src/version.c	Wed Feb 13 18:34:24 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     250,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
3. Every time someone asks you to do something, ask if they want fries
   with that.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.251
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.251
Problem:    Using freed memory when spell checking enabled.
Solution:   Obtain the current line again after calling spell_move_to().
	    (Dominique Pelle)
Files:	    src/screen.c


*** ../vim-7.1.250/src/screen.c	Sat Jan 19 15:55:51 2008
--- src/screen.c	Wed Feb 13 21:45:38 2008
***************
*** 2644,2650 ****
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
  # define LINE_ATTR
!     int		line_attr = 0;		/* atrribute for the whole line */
  #endif
  #ifdef FEAT_SEARCH_EXTRA
      matchitem_T *cur;			/* points to the match list */
--- 2644,2650 ----
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
  # define LINE_ATTR
!     int		line_attr = 0;		/* attribute for the whole line */
  #endif
  #ifdef FEAT_SEARCH_EXTRA
      matchitem_T *cur;			/* points to the match list */
***************
*** 3040,3057 ****
  	if (has_spell)
  	{
  	    int		len;
  	    hlf_T	spell_hlf = HLF_COUNT;
  
  	    pos = wp->w_cursor;
  	    wp->w_cursor.lnum = lnum;
! 	    wp->w_cursor.col = (colnr_T)(ptr - line);
  	    len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);
  	    if (len == 0 || (int)wp->w_cursor.col > ptr - line)
  	    {
  		/* no bad word found at line start, don't check until end of a
  		 * word */
  		spell_hlf = HLF_COUNT;
! 		word_end = (int)(spell_to_word_end(ptr, wp->w_buffer) - line + 1);
  	    }
  	    else
  	    {
--- 3040,3064 ----
  	if (has_spell)
  	{
  	    int		len;
+ 	    colnr_T	linecol = (colnr_T)(ptr - line);
  	    hlf_T	spell_hlf = HLF_COUNT;
  
  	    pos = wp->w_cursor;
  	    wp->w_cursor.lnum = lnum;
! 	    wp->w_cursor.col = linecol;
  	    len = spell_move_to(wp, FORWARD, TRUE, TRUE, &spell_hlf);
+ 
+ 	    /* spell_move_to() may call ml_get() and make "line" invalid */
+ 	    line = ml_get_buf(wp->w_buffer, lnum, FALSE);
+ 	    ptr = line + linecol;
+ 
  	    if (len == 0 || (int)wp->w_cursor.col > ptr - line)
  	    {
  		/* no bad word found at line start, don't check until end of a
  		 * word */
  		spell_hlf = HLF_COUNT;
! 		word_end = (int)(spell_to_word_end(ptr, wp->w_buffer)
! 								  - line + 1);
  	    }
  	    else
  	    {
*** ../vim-7.1.250/src/version.c	Wed Feb 13 18:35:23 2008
--- src/version.c	Wed Feb 13 21:48:08 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     251,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
6. In the memo field of all your checks, write "for sexual favors".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.252
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.252 (after 7.1.243)
Problem:    Test 39 fails when the environment has a utf-8 locale. (Dominique
	    Pelle)
Solution:   Force 'encoding' to be latin1.
Files:	    src/testdir/test39.in


*** ../vim-7.1.251/src/testdir/test39.in	Wed Feb  6 14:43:50 2008
--- src/testdir/test39.in	Thu Feb 14 22:16:57 2008
***************
*** 5,10 ****
--- 5,12 ----
  STARTTEST
  :so small.vim
  :so mbyte.vim
+ :" This only works when 'encoding' is "latin1", don't depend on the environment
+ :set enc=latin1
  /^abcde
  :" Test shift-right of a block
  jlllljj>wlljlll>
*** ../vim-7.1.251/src/version.c	Wed Feb 13 21:48:24 2008
--- src/version.c	Thu Feb 14 22:18:11 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     252,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
9. As often as possible, skip rather than walk.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.253
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.253
Problem:    ":sort" doesn't work in a one line file. (Patrick Texier)
Solution:   Don't sort if there is only one line. (Dominique Pelle)
Files:	    src/ex_cmds.c


*** ../vim-7.1.252/src/ex_cmds.c	Sat Jan 19 15:55:51 2008
--- src/ex_cmds.c	Mon Feb 18 19:38:02 2008
***************
*** 365,370 ****
--- 365,374 ----
      int		sort_oct;		/* sort on octal number */
      int		sort_hex;		/* sort on hex number */
  
+     /* Sorting one line is really quick! */
+     if (count <= 1)
+ 	return;
+ 
      if (u_save((linenr_T)(eap->line1 - 1), (linenr_T)(eap->line2 + 1)) == FAIL)
  	return;
      sortbuf1 = NULL;
*** ../vim-7.1.252/src/version.c	Thu Feb 14 22:19:39 2008
--- src/version.c	Mon Feb 18 19:39:24 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     253,
  /**/

-- 
"You know, it's at times like this when I'm trapped in a Vogon airlock with
a man from Betelgeuse and about to die of asphyxiation in deep space that I
really wish I'd listened to what my mother told me when I was young!"
"Why, what did she tell you?"
"I don't know, I didn't listen!"
		-- Arthur Dent and Ford Prefect in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.254
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.254
Problem:    Tests 49 and 55 fail when the locale is French.
Solution:   Using C messages for test 49.  Filter the error message in test 55
	    such that it works when the number is halfway the message.
Files:	    src/testdir/test49.in, src/testdir/test55.in


*** ../vim-7.1.253/src/testdir/test49.in	Tue Sep 25 17:54:41 2007
--- src/testdir/test49.in	Tue Feb 19 21:03:20 2008
***************
*** 6,11 ****
--- 6,12 ----
  STARTTEST
  :so small.vim
  :se nocp nomore viminfo+=nviminfo
+ :lang mess C
  :so test49.vim
  GGGGGGGGGGGGGG"rp:.-,$w! test.out
  :"
*** ../vim-7.1.253/src/testdir/test55.in	Tue Sep 25 17:54:41 2007
--- src/testdir/test55.in	Tue Feb 19 21:06:21 2008
***************
*** 146,152 ****
  :try
  :  let n = d[1500]
  :catch
! :  $put =v:exception[:14] . v:exception[-4:-1]
  :endtry
  :" lookup each items
  :for i in range(1500)
--- 146,152 ----
  :try
  :  let n = d[1500]
  :catch
! :  $put =substitute(v:exception, '\v(.{14}).*( \d{4}).*', '\1\2', '')
  :endtry
  :" lookup each items
  :for i in range(1500)
*** ../vim-7.1.253/src/version.c	Mon Feb 18 19:41:40 2008
--- src/version.c	Wed Feb 20 10:16:59 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     254,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
34. You laugh at people with 14400 baud modems.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.255
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.255
Problem:    Vim doesn't support utf-32. (Yongwei Wu)
Solution:   Add aliases for utf-32, it's the same as ucs-4.
Files:	    src/mbyte.c


*** ../vim-7.1.254/src/mbyte.c	Sun Jan  6 17:18:16 2008
--- src/mbyte.c	Tue Feb 19 20:31:48 2008
***************
*** 360,365 ****
--- 360,371 ----
      {"ucs4be",		IDX_UCS4},
      {"ucs-4be",		IDX_UCS4},
      {"ucs4le",		IDX_UCS4LE},
+     {"utf32",		IDX_UCS4},
+     {"utf-32",		IDX_UCS4},
+     {"utf32be",		IDX_UCS4},
+     {"utf-32be",	IDX_UCS4},
+     {"utf32le",		IDX_UCS4LE},
+     {"utf-32le",	IDX_UCS4LE},
      {"932",		IDX_CP932},
      {"949",		IDX_CP949},
      {"936",		IDX_CP936},
*** ../vim-7.1.254/src/version.c	Wed Feb 20 10:57:11 2008
--- src/version.c	Wed Feb 20 11:27:00 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     255,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
37. You start looking for hot HTML addresses in public restrooms.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.256
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.256
Problem:    findfile() also returns directories.
Solution:   Cleanup the code for finding files and directories in a list of
            directories.  Remove the ugly global ff_search_ctx.
Files:      src/eval.c, src/misc2.c, src/vim.h, src/tag.c


*** ../vim-7.1.255/src/eval.c	Wed Feb 13 12:41:30 2008
--- src/eval.c	Wed Feb 20 11:08:21 2008
***************
*** 9203,9215 ****
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
  
! static void findfilendir __ARGS((typval_T *argvars, typval_T *rettv, int dir));
  
      static void
! findfilendir(argvars, rettv, dir)
      typval_T	*argvars;
      typval_T	*rettv;
!     int		dir;
  {
  #ifdef FEAT_SEARCHPATH
      char_u	*fname;
--- 9205,9217 ----
      rettv->vval.v_number = filewritable(get_tv_string(&argvars[0]));
  }
  
! static void findfilendir __ARGS((typval_T *argvars, typval_T *rettv, int find_what));
  
      static void
! findfilendir(argvars, rettv, find_what)
      typval_T	*argvars;
      typval_T	*rettv;
!     int		find_what;
  {
  #ifdef FEAT_SEARCHPATH
      char_u	*fname;
***************
*** 9254,9261 ****
  		vim_free(fresult);
  	    fresult = find_file_in_path_option(first ? fname : NULL,
  					       first ? (int)STRLEN(fname) : 0,
! 					0, first, path, dir, curbuf->b_ffname,
! 					dir ? (char_u *)"" : curbuf->b_p_sua);
  	    first = FALSE;
  
  	    if (fresult != NULL && rettv->v_type == VAR_LIST)
--- 9256,9266 ----
  		vim_free(fresult);
  	    fresult = find_file_in_path_option(first ? fname : NULL,
  					       first ? (int)STRLEN(fname) : 0,
! 					0, first, path,
! 					find_what,
! 					curbuf->b_ffname,
! 					find_what == FINDFILE_DIR
! 					    ? (char_u *)"" : curbuf->b_p_sua);
  	    first = FALSE;
  
  	    if (fresult != NULL && rettv->v_type == VAR_LIST)
***************
*** 9445,9451 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
!     findfilendir(argvars, rettv, TRUE);
  }
  
  /*
--- 9450,9456 ----
      typval_T	*argvars;
      typval_T	*rettv;
  {
!     findfilendir(argvars, rettv, FINDFILE_DIR);
  }
  
  /*
***************
*** 9456,9462 ****
      typval_T	*argvars;
      typval_T	*rettv;
  {
!     findfilendir(argvars, rettv, FALSE);
  }
  
  /*
--- 9461,9467 ----
      typval_T	*argvars;
      typval_T	*rettv;
  {
!     findfilendir(argvars, rettv, FINDFILE_FILE);
  }
  
  /*
*** ../vim-7.1.255/src/misc2.c	Fri Jan  4 21:25:01 2008
--- src/misc2.c	Wed Feb 13 17:19:21 2008
***************
*** 3777,3785 ****
      char_u		ffs_filearray_cur;   /* needed for partly handled dirs */
  
      /* to store status of partly handled directories
!      * 0: we work the on this directory for the first time
       * 1: this directory was partly searched in an earlier step
!     */
      int			ffs_stage;
  
      /* How deep are we in the directory tree?
--- 3778,3786 ----
      char_u		ffs_filearray_cur;   /* needed for partly handled dirs */
  
      /* to store status of partly handled directories
!      * 0: we work on this directory for the first time
       * 1: this directory was partly searched in an earlier step
!      */
      int			ffs_stage;
  
      /* How deep are we in the directory tree?
***************
*** 3848,3853 ****
--- 3849,3855 ----
   * Set the default maximum depth.
   */
  #define FF_MAX_STAR_STAR_EXPAND ((char_u)30)
+ 
  /*
   * The search context:
   *   ffsc_stack_ptr:	the stack for the dirs to search
***************
*** 3862,3868 ****
   *   ffsc_wc_path:	the part of the given path containing wildcards
   *   ffsc_level:	how many levels of dirs to search downwards
   *   ffsc_stopdirs_v:	array of stop directories for upward search
!  *   ffsc_need_dir:	TRUE if we search for a directory
   */
  typedef struct ff_search_ctx_T
  {
--- 3864,3870 ----
   *   ffsc_wc_path:	the part of the given path containing wildcards
   *   ffsc_level:	how many levels of dirs to search downwards
   *   ffsc_stopdirs_v:	array of stop directories for upward search
!  *   ffsc_find_what:	FINDFILE_BOTH, FINDFILE_DIR or FINDFILE_FILE
   */
  typedef struct ff_search_ctx_T
  {
***************
*** 3879,3889 ****
       int			ffsc_level;
       char_u			**ffsc_stopdirs_v;
  #endif
!      int			ffsc_need_dir;
  } ff_search_ctx_T;
  
- static ff_search_ctx_T *ff_search_ctx = NULL;
- 
  /* locally needed functions */
  #ifdef FEAT_PATH_EXTRA
  static int ff_check_visited __ARGS((ff_visited_T **, char_u *, char_u *));
--- 3881,3889 ----
       int			ffsc_level;
       char_u			**ffsc_stopdirs_v;
  #endif
!      int			ffsc_find_what;
  } ff_search_ctx_T;
  
  /* locally needed functions */
  #ifdef FEAT_PATH_EXTRA
  static int ff_check_visited __ARGS((ff_visited_T **, char_u *, char_u *));
***************
*** 3897,3906 ****
  static int ff_wc_equal __ARGS((char_u *s1, char_u *s2));
  #endif
  
! static void ff_push __ARGS((ff_stack_T *));
! static ff_stack_T * ff_pop __ARGS((void));
! static void ff_clear __ARGS((void));
! static void ff_free_stack_element __ARGS((ff_stack_T *));
  #ifdef FEAT_PATH_EXTRA
  static ff_stack_T *ff_create_stack_element __ARGS((char_u *, char_u *, int, int));
  #else
--- 3897,3906 ----
  static int ff_wc_equal __ARGS((char_u *s1, char_u *s2));
  #endif
  
! static void ff_push __ARGS((ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr));
! static ff_stack_T *ff_pop __ARGS((ff_search_ctx_T *search_ctx));
! static void ff_clear __ARGS((ff_search_ctx_T *search_ctx));
! static void ff_free_stack_element __ARGS((ff_stack_T *stack_ptr));
  #ifdef FEAT_PATH_EXTRA
  static ff_stack_T *ff_create_stack_element __ARGS((char_u *, char_u *, int, int));
  #else
***************
*** 3961,3966 ****
--- 3961,3969 ----
   * not related to restricts given to the '**' wildcard. If 'level' is 100
   * and you use '**200' vim_findfile() will stop after 100 levels.
   *
+  * 'filename' cannot contain wildcards!  It is used as-is, no backslashes to
+  * escape special characters.
+  *
   * If 'stopdirs' is not NULL and nothing is found downward, the search is
   * restarted on the next higher directory level. This is repeated until the
   * start-directory of a search is contained in 'stopdirs'. 'stopdirs' has the
***************
*** 3980,4053 ****
   * The list of visited files/dirs can also be cleared with the function
   * vim_findfile_free_visited().
   *
!  * Set the parameter 'need_dir' to TRUE if you want to search for a directory
!  * instead of a file.
   *
   * A search context returned by a previous call to vim_findfile_init() can be
!  * passed in the parameter 'search_ctx'. This context is than reused and
!  * reinitialized with the new parameters. The list of already viseted
   * directories from this context is only deleted if the parameter
!  * 'free_visited' is true. Be aware that the passed search_context is freed if
!  * the reinitialization fails.
   *
!  * If you don't have a search context from a previous call 'search_ctx' must be
!  * NULL.
   *
   * This function silently ignores a few errors, vim_findfile() will have
   * limited functionality then.
   */
  /*ARGSUSED*/
      void *
! vim_findfile_init(path, filename, stopdirs, level, free_visited, need_dir,
! 						search_ctx, tagfile, rel_fname)
      char_u	*path;
      char_u	*filename;
      char_u	*stopdirs;
      int		level;
      int		free_visited;
!     int		need_dir;
!     void	*search_ctx;
      int		tagfile;
      char_u	*rel_fname;	/* file name to use for "." */
  {
  #ifdef FEAT_PATH_EXTRA
!     char_u	*wc_part;
  #endif
!     ff_stack_T	*sptr;
  
      /* If a search context is given by the caller, reuse it, else allocate a
       * new one.
       */
!     if (search_ctx != NULL)
! 	ff_search_ctx = search_ctx;
      else
      {
! 	ff_search_ctx = (ff_search_ctx_T*)alloc(
! 					   (unsigned)sizeof(ff_search_ctx_T));
! 	if (ff_search_ctx == NULL)
  	    goto error_return;
! 	memset(ff_search_ctx, 0, sizeof(ff_search_ctx_T));
      }
  
      /* clear the search context, but NOT the visited lists */
!     ff_clear();
  
      /* clear visited list if wanted */
      if (free_visited == TRUE)
! 	vim_findfile_free_visited(ff_search_ctx);
      else
      {
  	/* Reuse old visited lists. Get the visited list for the given
  	 * filename. If no list for the current filename exists, creates a new
! 	 * one.
! 	 */
! 	ff_search_ctx->ffsc_visited_list = ff_get_visited_list(filename,
! 				     &ff_search_ctx->ffsc_visited_lists_list);
! 	if (ff_search_ctx->ffsc_visited_list == NULL)
  	    goto error_return;
! 	ff_search_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,
! 				 &ff_search_ctx->ffsc_dir_visited_lists_list);
! 	if (ff_search_ctx->ffsc_dir_visited_list == NULL)
  	    goto error_return;
      }
  
--- 3983,4056 ----
   * The list of visited files/dirs can also be cleared with the function
   * vim_findfile_free_visited().
   *
!  * Set the parameter 'find_what' to FINDFILE_DIR if you want to search for
!  * directories only, FINDFILE_FILE for files only, FINDFILE_BOTH for both.
   *
   * A search context returned by a previous call to vim_findfile_init() can be
!  * passed in the parameter "search_ctx_arg".  This context is reused and
!  * reinitialized with the new parameters.  The list of already visited
   * directories from this context is only deleted if the parameter
!  * "free_visited" is true.  Be aware that the passed "search_ctx_arg" is freed
!  * if the reinitialization fails.
   *
!  * If you don't have a search context from a previous call "search_ctx_arg"
!  * must be NULL.
   *
   * This function silently ignores a few errors, vim_findfile() will have
   * limited functionality then.
   */
  /*ARGSUSED*/
      void *
! vim_findfile_init(path, filename, stopdirs, level, free_visited, find_what,
! 					   search_ctx_arg, tagfile, rel_fname)
      char_u	*path;
      char_u	*filename;
      char_u	*stopdirs;
      int		level;
      int		free_visited;
!     int		find_what;
!     void	*search_ctx_arg;
      int		tagfile;
      char_u	*rel_fname;	/* file name to use for "." */
  {
  #ifdef FEAT_PATH_EXTRA
!     char_u		*wc_part;
  #endif
!     ff_stack_T		*sptr;
!     ff_search_ctx_T	*search_ctx;
  
      /* If a search context is given by the caller, reuse it, else allocate a
       * new one.
       */
!     if (search_ctx_arg != NULL)
! 	search_ctx = search_ctx_arg;
      else
      {
! 	search_ctx = (ff_search_ctx_T*)alloc((unsigned)sizeof(ff_search_ctx_T));
! 	if (search_ctx == NULL)
  	    goto error_return;
! 	memset(search_ctx, 0, sizeof(ff_search_ctx_T));
      }
+     search_ctx->ffsc_find_what = find_what;
  
      /* clear the search context, but NOT the visited lists */
!     ff_clear(search_ctx);
  
      /* clear visited list if wanted */
      if (free_visited == TRUE)
! 	vim_findfile_free_visited(search_ctx);
      else
      {
  	/* Reuse old visited lists. Get the visited list for the given
  	 * filename. If no list for the current filename exists, creates a new
! 	 * one. */
! 	search_ctx->ffsc_visited_list = ff_get_visited_list(filename,
! 					&search_ctx->ffsc_visited_lists_list);
! 	if (search_ctx->ffsc_visited_list == NULL)
  	    goto error_return;
! 	search_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,
! 				    &search_ctx->ffsc_dir_visited_lists_list);
! 	if (search_ctx->ffsc_dir_visited_list == NULL)
  	    goto error_return;
      }
  
***************
*** 4071,4082 ****
  	{
  	    /* Make the start dir an absolute path name. */
  	    vim_strncpy(ff_expand_buffer, rel_fname, len);
! 	    ff_search_ctx->ffsc_start_dir = FullName_save(ff_expand_buffer,
! 								       FALSE);
  	}
  	else
! 	    ff_search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);
! 	if (ff_search_ctx->ffsc_start_dir == NULL)
  	    goto error_return;
  	if (*++path != NUL)
  	    ++path;
--- 4074,4084 ----
  	{
  	    /* Make the start dir an absolute path name. */
  	    vim_strncpy(ff_expand_buffer, rel_fname, len);
! 	    search_ctx->ffsc_start_dir = FullName_save(ff_expand_buffer, FALSE);
  	}
  	else
! 	    search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);
! 	if (search_ctx->ffsc_start_dir == NULL)
  	    goto error_return;
  	if (*++path != NUL)
  	    ++path;
***************
*** 4101,4108 ****
  	if (mch_dirname(ff_expand_buffer, MAXPATHL) == FAIL)
  	    goto error_return;
  
! 	ff_search_ctx->ffsc_start_dir = vim_strsave(ff_expand_buffer);
! 	if (ff_search_ctx->ffsc_start_dir == NULL)
  	    goto error_return;
  
  #ifdef BACKSLASH_IN_FILENAME
--- 4103,4110 ----
  	if (mch_dirname(ff_expand_buffer, MAXPATHL) == FAIL)
  	    goto error_return;
  
! 	search_ctx->ffsc_start_dir = vim_strsave(ff_expand_buffer);
! 	if (search_ctx->ffsc_start_dir == NULL)
  	    goto error_return;
  
  #ifdef BACKSLASH_IN_FILENAME
***************
*** 4110,4117 ****
  	 * directory (but not for "//machine/dir").  Only use the drive name. */
  	if ((*path == '/' || *path == '\\')
  		&& path[1] != path[0]
! 		&& ff_search_ctx->ffsc_start_dir[1] == ':')
! 	    ff_search_ctx->ffsc_start_dir[2] = NUL;
  #endif
      }
  
--- 4112,4119 ----
  	 * directory (but not for "//machine/dir").  Only use the drive name. */
  	if ((*path == '/' || *path == '\\')
  		&& path[1] != path[0]
! 		&& search_ctx->ffsc_start_dir[1] == ':')
! 	    search_ctx->ffsc_start_dir[2] = NUL;
  #endif
      }
  
***************
*** 4121,4127 ****
       * If this fails (mem allocation), there is no upward search at all or a
       * stop directory is not recognized -> continue silently.
       * If stopdirs just contains a ";" or is empty,
!      * ff_search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This
       * is handled as unlimited upward search.  See function
       * ff_path_in_stoplist() for details.
       */
--- 4123,4129 ----
       * If this fails (mem allocation), there is no upward search at all or a
       * stop directory is not recognized -> continue silently.
       * If stopdirs just contains a ";" or is empty,
!      * search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This
       * is handled as unlimited upward search.  See function
       * ff_path_in_stoplist() for details.
       */
***************
*** 4134,4143 ****
  	    walker++;
  
  	dircount = 1;
! 	ff_search_ctx->ffsc_stopdirs_v =
! 	    (char_u **)alloc((unsigned)sizeof(char_u *));
  
! 	if (ff_search_ctx->ffsc_stopdirs_v != NULL)
  	{
  	    do
  	    {
--- 4136,4145 ----
  	    walker++;
  
  	dircount = 1;
! 	search_ctx->ffsc_stopdirs_v =
! 				 (char_u **)alloc((unsigned)sizeof(char_u *));
  
! 	if (search_ctx->ffsc_stopdirs_v != NULL)
  	{
  	    do
  	    {
***************
*** 4145,4181 ****
  		void	*ptr;
  
  		helper = walker;
! 		ptr = vim_realloc(ff_search_ctx->ffsc_stopdirs_v,
  					   (dircount + 1) * sizeof(char_u *));
  		if (ptr)
! 		    ff_search_ctx->ffsc_stopdirs_v = ptr;
  		else
  		    /* ignore, keep what we have and continue */
  		    break;
  		walker = vim_strchr(walker, ';');
  		if (walker)
  		{
! 		    ff_search_ctx->ffsc_stopdirs_v[dircount-1] =
! 			vim_strnsave(helper, (int)(walker - helper));
  		    walker++;
  		}
  		else
  		    /* this might be "", which means ascent till top
  		     * of directory tree.
  		     */
! 		    ff_search_ctx->ffsc_stopdirs_v[dircount-1] =
! 			vim_strsave(helper);
  
  		dircount++;
  
  	    } while (walker != NULL);
! 	    ff_search_ctx->ffsc_stopdirs_v[dircount-1] = NULL;
  	}
      }
  #endif
  
  #ifdef FEAT_PATH_EXTRA
!     ff_search_ctx->ffsc_level = level;
  
      /* split into:
       *  -fix path
--- 4147,4183 ----
  		void	*ptr;
  
  		helper = walker;
! 		ptr = vim_realloc(search_ctx->ffsc_stopdirs_v,
  					   (dircount + 1) * sizeof(char_u *));
  		if (ptr)
! 		    search_ctx->ffsc_stopdirs_v = ptr;
  		else
  		    /* ignore, keep what we have and continue */
  		    break;
  		walker = vim_strchr(walker, ';');
  		if (walker)
  		{
! 		    search_ctx->ffsc_stopdirs_v[dircount-1] =
! 				 vim_strnsave(helper, (int)(walker - helper));
  		    walker++;
  		}
  		else
  		    /* this might be "", which means ascent till top
  		     * of directory tree.
  		     */
! 		    search_ctx->ffsc_stopdirs_v[dircount-1] =
! 							  vim_strsave(helper);
  
  		dircount++;
  
  	    } while (walker != NULL);
! 	    search_ctx->ffsc_stopdirs_v[dircount-1] = NULL;
  	}
      }
  #endif
  
  #ifdef FEAT_PATH_EXTRA
!     search_ctx->ffsc_level = level;
  
      /* split into:
       *  -fix path
***************
*** 4189,4196 ****
  	char	*errpt;
  
  	/* save the fix part of the path */
! 	ff_search_ctx->ffsc_fix_path = vim_strnsave(path,
! 						       (int)(wc_part - path));
  
  	/*
  	 * copy wc_path and add restricts to the '**' wildcard.
--- 4191,4197 ----
  	char	*errpt;
  
  	/* save the fix part of the path */
! 	search_ctx->ffsc_fix_path = vim_strnsave(path, (int)(wc_part - path));
  
  	/*
  	 * copy wc_path and add restricts to the '**' wildcard.
***************
*** 4229,4275 ****
  		ff_expand_buffer[len++] = *wc_part++;
  	}
  	ff_expand_buffer[len] = NUL;
! 	ff_search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);
  
! 	if (ff_search_ctx->ffsc_wc_path == NULL)
  	    goto error_return;
      }
      else
  #endif
! 	ff_search_ctx->ffsc_fix_path = vim_strsave(path);
  
!     if (ff_search_ctx->ffsc_start_dir == NULL)
      {
  	/* store the fix part as startdir.
  	 * This is needed if the parameter path is fully qualified.
  	 */
! 	ff_search_ctx->ffsc_start_dir = vim_strsave(ff_search_ctx->ffsc_fix_path);
! 	if (ff_search_ctx->ffsc_start_dir)
! 	    ff_search_ctx->ffsc_fix_path[0] = NUL;
      }
  
      /* create an absolute path */
!     STRCPY(ff_expand_buffer, ff_search_ctx->ffsc_start_dir);
      add_pathsep(ff_expand_buffer);
!     STRCAT(ff_expand_buffer, ff_search_ctx->ffsc_fix_path);
      add_pathsep(ff_expand_buffer);
  
      sptr = ff_create_stack_element(ff_expand_buffer,
  #ifdef FEAT_PATH_EXTRA
! 	    ff_search_ctx->ffsc_wc_path,
  #endif
  	    level, 0);
  
      if (sptr == NULL)
  	goto error_return;
  
!     ff_push(sptr);
  
!     ff_search_ctx->ffsc_file_to_search = vim_strsave(filename);
!     if (ff_search_ctx->ffsc_file_to_search == NULL)
  	goto error_return;
  
!     return ff_search_ctx;
  
  error_return:
      /*
--- 4230,4276 ----
  		ff_expand_buffer[len++] = *wc_part++;
  	}
  	ff_expand_buffer[len] = NUL;
! 	search_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);
  
! 	if (search_ctx->ffsc_wc_path == NULL)
  	    goto error_return;
      }
      else
  #endif
! 	search_ctx->ffsc_fix_path = vim_strsave(path);
  
!     if (search_ctx->ffsc_start_dir == NULL)
      {
  	/* store the fix part as startdir.
  	 * This is needed if the parameter path is fully qualified.
  	 */
! 	search_ctx->ffsc_start_dir = vim_strsave(search_ctx->ffsc_fix_path);
! 	if (search_ctx->ffsc_start_dir)
! 	    search_ctx->ffsc_fix_path[0] = NUL;
      }
  
      /* create an absolute path */
!     STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);
      add_pathsep(ff_expand_buffer);
!     STRCAT(ff_expand_buffer, search_ctx->ffsc_fix_path);
      add_pathsep(ff_expand_buffer);
  
      sptr = ff_create_stack_element(ff_expand_buffer,
  #ifdef FEAT_PATH_EXTRA
! 	    search_ctx->ffsc_wc_path,
  #endif
  	    level, 0);
  
      if (sptr == NULL)
  	goto error_return;
  
!     ff_push(search_ctx, sptr);
  
!     search_ctx->ffsc_file_to_search = vim_strsave(filename);
!     if (search_ctx->ffsc_file_to_search == NULL)
  	goto error_return;
  
!     return search_ctx;
  
  error_return:
      /*
***************
*** 4277,4283 ****
       * Even when the caller gave us a (perhaps valid) context we free it here,
       * as we might have already destroyed it.
       */
!     vim_findfile_cleanup(ff_search_ctx);
      return NULL;
  }
  
--- 4278,4284 ----
       * Even when the caller gave us a (perhaps valid) context we free it here,
       * as we might have already destroyed it.
       */
!     vim_findfile_cleanup(search_ctx);
      return NULL;
  }
  
***************
*** 4314,4320 ****
  }
  #endif
  
! /* Clean up the given search context. Can handle a NULL pointer */
      void
  vim_findfile_cleanup(ctx)
      void	*ctx;
--- 4315,4323 ----
  }
  #endif
  
! /*
!  * Clean up the given search context. Can handle a NULL pointer.
!  */
      void
  vim_findfile_cleanup(ctx)
      void	*ctx;
***************
*** 4322,4333 ****
      if (ctx == NULL)
  	return;
  
-     ff_search_ctx = ctx;
- 
      vim_findfile_free_visited(ctx);
!     ff_clear();
      vim_free(ctx);
-     ff_search_ctx = NULL;
  }
  
  /*
--- 4325,4333 ----
      if (ctx == NULL)
  	return;
  
      vim_findfile_free_visited(ctx);
!     ff_clear(ctx);
      vim_free(ctx);
  }
  
  /*
***************
*** 4343,4357 ****
   * top of the list).
   */
      char_u *
! vim_findfile(search_ctx)
!     void	*search_ctx;
  {
      char_u	*file_path;
  #ifdef FEAT_PATH_EXTRA
      char_u	*rest_of_wildcards;
      char_u	*path_end = NULL;
  #endif
!     ff_stack_T	*ctx;
  #if defined(FEAT_SEARCHPATH) || defined(FEAT_PATH_EXTRA)
      int		len;
  #endif
--- 4343,4357 ----
   * top of the list).
   */
      char_u *
! vim_findfile(search_ctx_arg)
!     void	*search_ctx_arg;
  {
      char_u	*file_path;
  #ifdef FEAT_PATH_EXTRA
      char_u	*rest_of_wildcards;
      char_u	*path_end = NULL;
  #endif
!     ff_stack_T	*stackp;
  #if defined(FEAT_SEARCHPATH) || defined(FEAT_PATH_EXTRA)
      int		len;
  #endif
***************
*** 4360,4370 ****
  #ifdef FEAT_SEARCHPATH
      char_u	*suf;
  #endif
  
!     if (search_ctx == NULL)
  	return NULL;
  
!     ff_search_ctx = (ff_search_ctx_T*)search_ctx;
  
      /*
       * filepath is used as buffer for various actions and as the storage to
--- 4360,4371 ----
  #ifdef FEAT_SEARCHPATH
      char_u	*suf;
  #endif
+     ff_search_ctx_T *search_ctx;
  
!     if (search_ctx_arg == NULL)
  	return NULL;
  
!     search_ctx = (ff_search_ctx_T *)search_ctx_arg;
  
      /*
       * filepath is used as buffer for various actions and as the storage to
***************
*** 4375,4382 ****
  
  #ifdef FEAT_PATH_EXTRA
      /* store the end of the start dir -- needed for upward search */
!     if (ff_search_ctx->ffsc_start_dir != NULL)
! 	path_end = &ff_search_ctx->ffsc_start_dir[STRLEN(ff_search_ctx->ffsc_start_dir)];
  #endif
  
  #ifdef FEAT_PATH_EXTRA
--- 4376,4384 ----
  
  #ifdef FEAT_PATH_EXTRA
      /* store the end of the start dir -- needed for upward search */
!     if (search_ctx->ffsc_start_dir != NULL)
! 	path_end = &search_ctx->ffsc_start_dir[
! 					  STRLEN(search_ctx->ffsc_start_dir)];
  #endif
  
  #ifdef FEAT_PATH_EXTRA
***************
*** 4393,4400 ****
  		break;
  
  	    /* get directory to work on from stack */
! 	    ctx = ff_pop();
! 	    if (ctx == NULL)
  		break;
  
  	    /*
--- 4395,4402 ----
  		break;
  
  	    /* get directory to work on from stack */
! 	    stackp = ff_pop(search_ctx);
! 	    if (stackp == NULL)
  		break;
  
  	    /*
***************
*** 4414,4427 ****
  	     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)
  	     *
  	     * This check is only needed for directories we work on for the
! 	     * first time (hence ctx->ff_filearray == NULL)
  	     */
! 	    if (ctx->ffs_filearray == NULL
! 		    && ff_check_visited(&ff_search_ctx->ffsc_dir_visited_list
  							  ->ffvl_visited_list,
! 			ctx->ffs_fix_path
  #ifdef FEAT_PATH_EXTRA
! 			, ctx->ffs_wc_path
  #endif
  			) == FAIL)
  	    {
--- 4416,4429 ----
  	     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)
  	     *
  	     * This check is only needed for directories we work on for the
! 	     * first time (hence stackp->ff_filearray == NULL)
  	     */
! 	    if (stackp->ffs_filearray == NULL
! 		    && ff_check_visited(&search_ctx->ffsc_dir_visited_list
  							  ->ffvl_visited_list,
! 			stackp->ffs_fix_path
  #ifdef FEAT_PATH_EXTRA
! 			, stackp->ffs_wc_path
  #endif
  			) == FAIL)
  	    {
***************
*** 4430,4442 ****
  		{
  		    verbose_enter_scroll();
  		    smsg((char_u *)"Already Searched: %s (%s)",
! 					   ctx->ffs_fix_path, ctx->ffs_wc_path);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
  		    verbose_leave_scroll();
  		}
  #endif
! 		ff_free_stack_element(ctx);
  		continue;
  	    }
  #ifdef FF_VERBOSE
--- 4432,4444 ----
  		{
  		    verbose_enter_scroll();
  		    smsg((char_u *)"Already Searched: %s (%s)",
! 				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
  		    verbose_leave_scroll();
  		}
  #endif
! 		ff_free_stack_element(stackp);
  		continue;
  	    }
  #ifdef FF_VERBOSE
***************
*** 4444,4450 ****
  	    {
  		verbose_enter_scroll();
  		smsg((char_u *)"Searching: %s (%s)",
! 					 ctx->ffs_fix_path, ctx->ffs_wc_path);
  		/* don't overwrite this either */
  		msg_puts((char_u *)"\n");
  		verbose_leave_scroll();
--- 4446,4452 ----
  	    {
  		verbose_enter_scroll();
  		smsg((char_u *)"Searching: %s (%s)",
! 				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		/* don't overwrite this either */
  		msg_puts((char_u *)"\n");
  		verbose_leave_scroll();
***************
*** 4452,4460 ****
  #endif
  
  	    /* check depth */
! 	    if (ctx->ffs_level <= 0)
  	    {
! 		ff_free_stack_element(ctx);
  		continue;
  	    }
  
--- 4454,4462 ----
  #endif
  
  	    /* check depth */
! 	    if (stackp->ffs_level <= 0)
  	    {
! 		ff_free_stack_element(stackp);
  		continue;
  	    }
  
***************
*** 4466,4472 ****
  	     * and all possible expands are returned in one array. We use this
  	     * to handle the expansion of '**' into an empty string.
  	     */
! 	    if (ctx->ffs_filearray == NULL)
  	    {
  		char_u *dirptrs[2];
  
--- 4468,4474 ----
  	     * and all possible expands are returned in one array. We use this
  	     * to handle the expansion of '**' into an empty string.
  	     */
! 	    if (stackp->ffs_filearray == NULL)
  	    {
  		char_u *dirptrs[2];
  
***************
*** 4477,4495 ****
  		dirptrs[1] = NULL;
  
  		/* if we have a start dir copy it in */
! 		if (!vim_isAbsName(ctx->ffs_fix_path)
! 			&& ff_search_ctx->ffsc_start_dir)
  		{
! 		    STRCPY(file_path, ff_search_ctx->ffsc_start_dir);
  		    add_pathsep(file_path);
  		}
  
  		/* append the fix part of the search path */
! 		STRCAT(file_path, ctx->ffs_fix_path);
  		add_pathsep(file_path);
  
  #ifdef FEAT_PATH_EXTRA
! 		rest_of_wildcards = ctx->ffs_wc_path;
  		if (*rest_of_wildcards != NUL)
  		{
  		    len = (int)STRLEN(file_path);
--- 4479,4497 ----
  		dirptrs[1] = NULL;
  
  		/* if we have a start dir copy it in */
! 		if (!vim_isAbsName(stackp->ffs_fix_path)
! 						&& search_ctx->ffsc_start_dir)
  		{
! 		    STRCPY(file_path, search_ctx->ffsc_start_dir);
  		    add_pathsep(file_path);
  		}
  
  		/* append the fix part of the search path */
! 		STRCAT(file_path, stackp->ffs_fix_path);
  		add_pathsep(file_path);
  
  #ifdef FEAT_PATH_EXTRA
! 		rest_of_wildcards = stackp->ffs_wc_path;
  		if (*rest_of_wildcards != NUL)
  		{
  		    len = (int)STRLEN(file_path);
***************
*** 4516,4526 ****
  			else
  			    rest_of_wildcards += 3;
  
! 			if (ctx->ffs_star_star_empty == 0)
  			{
  			    /* if not done before, expand '**' to empty */
! 			    ctx->ffs_star_star_empty = 1;
! 			    dirptrs[1] = ctx->ffs_fix_path;
  			}
  		    }
  
--- 4518,4528 ----
  			else
  			    rest_of_wildcards += 3;
  
! 			if (stackp->ffs_star_star_empty == 0)
  			{
  			    /* if not done before, expand '**' to empty */
! 			    stackp->ffs_star_star_empty = 1;
! 			    dirptrs[1] = stackp->ffs_fix_path;
  			}
  		    }
  
***************
*** 4547,4576 ****
  		 */
  		if (path_with_url(dirptrs[0]))
  		{
! 		    ctx->ffs_filearray = (char_u **)
  					      alloc((unsigned)sizeof(char *));
! 		    if (ctx->ffs_filearray != NULL
! 			    && (ctx->ffs_filearray[0]
  				= vim_strsave(dirptrs[0])) != NULL)
! 			ctx->ffs_filearray_size = 1;
  		    else
! 			ctx->ffs_filearray_size = 0;
  		}
  		else
  		    expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,
! 			    &ctx->ffs_filearray_size,
! 			    &ctx->ffs_filearray,
  			    EW_DIR|EW_ADDSLASH|EW_SILENT);
  
! 		ctx->ffs_filearray_cur = 0;
! 		ctx->ffs_stage = 0;
  	    }
  #ifdef FEAT_PATH_EXTRA
  	    else
! 		rest_of_wildcards = &ctx->ffs_wc_path[STRLEN(ctx->ffs_wc_path)];
  #endif
  
! 	    if (ctx->ffs_stage == 0)
  	    {
  		/* this is the first time we work on this directory */
  #ifdef FEAT_PATH_EXTRA
--- 4549,4579 ----
  		 */
  		if (path_with_url(dirptrs[0]))
  		{
! 		    stackp->ffs_filearray = (char_u **)
  					      alloc((unsigned)sizeof(char *));
! 		    if (stackp->ffs_filearray != NULL
! 			    && (stackp->ffs_filearray[0]
  				= vim_strsave(dirptrs[0])) != NULL)
! 			stackp->ffs_filearray_size = 1;
  		    else
! 			stackp->ffs_filearray_size = 0;
  		}
  		else
  		    expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,
! 			    &stackp->ffs_filearray_size,
! 			    &stackp->ffs_filearray,
  			    EW_DIR|EW_ADDSLASH|EW_SILENT);
  
! 		stackp->ffs_filearray_cur = 0;
! 		stackp->ffs_stage = 0;
  	    }
  #ifdef FEAT_PATH_EXTRA
  	    else
! 		rest_of_wildcards = &stackp->ffs_wc_path[
! 						 STRLEN(stackp->ffs_wc_path)];
  #endif
  
! 	    if (stackp->ffs_stage == 0)
  	    {
  		/* this is the first time we work on this directory */
  #ifdef FEAT_PATH_EXTRA
***************
*** 4581,4598 ****
  		     * we don't have further wildcards to expand, so we have to
  		     * check for the final file now
  		     */
! 		    for (i = ctx->ffs_filearray_cur;
! 					     i < ctx->ffs_filearray_size; ++i)
  		    {
! 			if (!path_with_url(ctx->ffs_filearray[i])
! 					 && !mch_isdir(ctx->ffs_filearray[i]))
  			    continue;   /* not a directory */
  
  			/* prepare the filename to be checked for existance
  			 * below */
! 			STRCPY(file_path, ctx->ffs_filearray[i]);
  			add_pathsep(file_path);
! 			STRCAT(file_path, ff_search_ctx->ffsc_file_to_search);
  
  			/*
  			 * Try without extra suffix and then with suffixes
--- 4584,4601 ----
  		     * we don't have further wildcards to expand, so we have to
  		     * check for the final file now
  		     */
! 		    for (i = stackp->ffs_filearray_cur;
! 					  i < stackp->ffs_filearray_size; ++i)
  		    {
! 			if (!path_with_url(stackp->ffs_filearray[i])
! 				      && !mch_isdir(stackp->ffs_filearray[i]))
  			    continue;   /* not a directory */
  
  			/* prepare the filename to be checked for existance
  			 * below */
! 			STRCPY(file_path, stackp->ffs_filearray[i]);
  			add_pathsep(file_path);
! 			STRCAT(file_path, search_ctx->ffsc_file_to_search);
  
  			/*
  			 * Try without extra suffix and then with suffixes
***************
*** 4606,4617 ****
  			{
  			    /* if file exists and we didn't already find it */
  			    if ((path_with_url(file_path)
! 					|| (mch_getperm(file_path) >= 0
! 					    && (!ff_search_ctx->ffsc_need_dir
! 						|| mch_isdir(file_path))))
  #ifndef FF_VERBOSE
  				    && (ff_check_visited(
! 					    &ff_search_ctx->ffsc_visited_list->ffvl_visited_list,
  					    file_path
  #ifdef FEAT_PATH_EXTRA
  					    , (char_u *)""
--- 4609,4623 ----
  			{
  			    /* if file exists and we didn't already find it */
  			    if ((path_with_url(file_path)
! 				  || (mch_getperm(file_path) >= 0
! 				      && (search_ctx->ffsc_find_what
! 							      == FINDFILE_BOTH
! 					  || ((search_ctx->ffsc_find_what
! 							      == FINDFILE_DIR)
! 						   == mch_isdir(file_path)))))
  #ifndef FF_VERBOSE
  				    && (ff_check_visited(
! 					    &search_ctx->ffsc_visited_list->ffvl_visited_list,
  					    file_path
  #ifdef FEAT_PATH_EXTRA
  					    , (char_u *)""
***************
*** 4622,4628 ****
  			    {
  #ifdef FF_VERBOSE
  				if (ff_check_visited(
! 					    &ff_search_ctx->ffsc_visited_list->ffvl_visited_list,
  					    file_path
  #ifdef FEAT_PATH_EXTRA
  					    , (char_u *)""
--- 4628,4634 ----
  			    {
  #ifdef FF_VERBOSE
  				if (ff_check_visited(
! 					    &search_ctx->ffsc_visited_list->ffvl_visited_list,
  					    file_path
  #ifdef FEAT_PATH_EXTRA
  					    , (char_u *)""
***************
*** 4643,4650 ****
  #endif
  
  				/* push dir to examine rest of subdirs later */
! 				ctx->ffs_filearray_cur = i + 1;
! 				ff_push(ctx);
  
  				simplify_filename(file_path);
  				if (mch_dirname(ff_expand_buffer, MAXPATHL)
--- 4649,4656 ----
  #endif
  
  				/* push dir to examine rest of subdirs later */
! 				stackp->ffs_filearray_cur = i + 1;
! 				ff_push(search_ctx, stackp);
  
  				simplify_filename(file_path);
  				if (mch_dirname(ff_expand_buffer, MAXPATHL)
***************
*** 4686,4704 ****
  		     * still wildcards left, push the directories for further
  		     * search
  		     */
! 		    for (i = ctx->ffs_filearray_cur;
! 					     i < ctx->ffs_filearray_size; ++i)
  		    {
! 			if (!mch_isdir(ctx->ffs_filearray[i]))
  			    continue;	/* not a directory */
  
! 			ff_push(ff_create_stack_element(ctx->ffs_filearray[i],
! 				      rest_of_wildcards, ctx->ffs_level - 1, 0));
  		    }
  		}
  #endif
! 		ctx->ffs_filearray_cur = 0;
! 		ctx->ffs_stage = 1;
  	    }
  
  #ifdef FEAT_PATH_EXTRA
--- 4692,4713 ----
  		     * still wildcards left, push the directories for further
  		     * search
  		     */
! 		    for (i = stackp->ffs_filearray_cur;
! 					  i < stackp->ffs_filearray_size; ++i)
  		    {
! 			if (!mch_isdir(stackp->ffs_filearray[i]))
  			    continue;	/* not a directory */
  
! 			ff_push(search_ctx,
! 				ff_create_stack_element(
! 						     stackp->ffs_filearray[i],
! 						     rest_of_wildcards,
! 						     stackp->ffs_level - 1, 0));
  		    }
  		}
  #endif
! 		stackp->ffs_filearray_cur = 0;
! 		stackp->ffs_stage = 1;
  	    }
  
  #ifdef FEAT_PATH_EXTRA
***************
*** 4706,4728 ****
  	     * if wildcards contains '**' we have to descent till we reach the
  	     * leaves of the directory tree.
  	     */
! 	    if (STRNCMP(ctx->ffs_wc_path, "**", 2) == 0)
  	    {
! 		for (i = ctx->ffs_filearray_cur;
! 					     i < ctx->ffs_filearray_size; ++i)
  		{
! 		    if (fnamecmp(ctx->ffs_filearray[i], ctx->ffs_fix_path) == 0)
  			continue; /* don't repush same directory */
! 		    if (!mch_isdir(ctx->ffs_filearray[i]))
  			continue;   /* not a directory */
! 		    ff_push(ff_create_stack_element(ctx->ffs_filearray[i],
! 				ctx->ffs_wc_path, ctx->ffs_level - 1, 1));
  		}
  	    }
  #endif
  
  	    /* we are done with the current directory */
! 	    ff_free_stack_element(ctx);
  
  	}
  
--- 4715,4739 ----
  	     * if wildcards contains '**' we have to descent till we reach the
  	     * leaves of the directory tree.
  	     */
! 	    if (STRNCMP(stackp->ffs_wc_path, "**", 2) == 0)
  	    {
! 		for (i = stackp->ffs_filearray_cur;
! 					  i < stackp->ffs_filearray_size; ++i)
  		{
! 		    if (fnamecmp(stackp->ffs_filearray[i],
! 						   stackp->ffs_fix_path) == 0)
  			continue; /* don't repush same directory */
! 		    if (!mch_isdir(stackp->ffs_filearray[i]))
  			continue;   /* not a directory */
! 		    ff_push(search_ctx,
! 			    ff_create_stack_element(stackp->ffs_filearray[i],
! 				stackp->ffs_wc_path, stackp->ffs_level - 1, 1));
  		}
  	    }
  #endif
  
  	    /* we are done with the current directory */
! 	    ff_free_stack_element(stackp);
  
  	}
  
***************
*** 4730,4769 ****
  	/* If we reached this, we didn't find anything downwards.
  	 * Let's check if we should do an upward search.
  	 */
! 	if (ff_search_ctx->ffsc_start_dir
! 		&& ff_search_ctx->ffsc_stopdirs_v != NULL && !got_int)
  	{
  	    ff_stack_T  *sptr;
  
  	    /* is the last starting directory in the stop list? */
! 	    if (ff_path_in_stoplist(ff_search_ctx->ffsc_start_dir,
! 		       (int)(path_end - ff_search_ctx->ffsc_start_dir),
! 		       ff_search_ctx->ffsc_stopdirs_v) == TRUE)
  		break;
  
  	    /* cut of last dir */
! 	    while (path_end > ff_search_ctx->ffsc_start_dir
! 		    && vim_ispathsep(*path_end))
  		path_end--;
! 	    while (path_end > ff_search_ctx->ffsc_start_dir
! 		    && !vim_ispathsep(path_end[-1]))
  		path_end--;
  	    *path_end = 0;
  	    path_end--;
  
! 	    if (*ff_search_ctx->ffsc_start_dir == 0)
  		break;
  
! 	    STRCPY(file_path, ff_search_ctx->ffsc_start_dir);
  	    add_pathsep(file_path);
! 	    STRCAT(file_path, ff_search_ctx->ffsc_fix_path);
  
  	    /* create a new stack entry */
  	    sptr = ff_create_stack_element(file_path,
! 		    ff_search_ctx->ffsc_wc_path, ff_search_ctx->ffsc_level, 0);
  	    if (sptr == NULL)
  		break;
! 	    ff_push(sptr);
  	}
  	else
  	    break;
--- 4741,4780 ----
  	/* If we reached this, we didn't find anything downwards.
  	 * Let's check if we should do an upward search.
  	 */
! 	if (search_ctx->ffsc_start_dir
! 		&& search_ctx->ffsc_stopdirs_v != NULL && !got_int)
  	{
  	    ff_stack_T  *sptr;
  
  	    /* is the last starting directory in the stop list? */
! 	    if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,
! 		       (int)(path_end - search_ctx->ffsc_start_dir),
! 		       search_ctx->ffsc_stopdirs_v) == TRUE)
  		break;
  
  	    /* cut of last dir */
! 	    while (path_end > search_ctx->ffsc_start_dir
! 						  && vim_ispathsep(*path_end))
  		path_end--;
! 	    while (path_end > search_ctx->ffsc_start_dir
! 					      && !vim_ispathsep(path_end[-1]))
  		path_end--;
  	    *path_end = 0;
  	    path_end--;
  
! 	    if (*search_ctx->ffsc_start_dir == 0)
  		break;
  
! 	    STRCPY(file_path, search_ctx->ffsc_start_dir);
  	    add_pathsep(file_path);
! 	    STRCAT(file_path, search_ctx->ffsc_fix_path);
  
  	    /* create a new stack entry */
  	    sptr = ff_create_stack_element(file_path,
! 		    search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);
  	    if (sptr == NULL)
  		break;
! 	    ff_push(search_ctx, sptr);
  	}
  	else
  	    break;
***************
*** 4779,4794 ****
   * Can handle it if the passed search_context is NULL;
   */
      void
! vim_findfile_free_visited(search_ctx)
!     void	*search_ctx;
  {
!     if (search_ctx == NULL)
! 	return;
  
!     ff_search_ctx = (ff_search_ctx_T *)search_ctx;
  
!     vim_findfile_free_visited_list(&ff_search_ctx->ffsc_visited_lists_list);
!     vim_findfile_free_visited_list(&ff_search_ctx->ffsc_dir_visited_lists_list);
  }
  
      static void
--- 4790,4806 ----
   * Can handle it if the passed search_context is NULL;
   */
      void
! vim_findfile_free_visited(search_ctx_arg)
!     void	*search_ctx_arg;
  {
!     ff_search_ctx_T *search_ctx;
  
!     if (search_ctx_arg == NULL)
! 	return;
  
!     search_ctx = (ff_search_ctx_T *)search_ctx_arg;
!     vim_findfile_free_visited_list(&search_ctx->ffsc_visited_lists_list);
!     vim_findfile_free_visited_list(&search_ctx->ffsc_dir_visited_lists_list);
  }
  
      static void
***************
*** 5103,5135 ****
  }
  
  /*
!  * push a dir on the directory stack
   */
      static void
! ff_push(ctx)
!     ff_stack_T *ctx;
  {
      /* check for NULL pointer, not to return an error to the user, but
       * to prevent a crash */
!     if (ctx != NULL)
      {
! 	ctx->ffs_prev   = ff_search_ctx->ffsc_stack_ptr;
! 	ff_search_ctx->ffsc_stack_ptr = ctx;
      }
  }
  
  /*
!  * pop a dir from the directory stack
!  * returns NULL if stack is empty
   */
      static ff_stack_T *
! ff_pop()
  {
      ff_stack_T  *sptr;
  
!     sptr = ff_search_ctx->ffsc_stack_ptr;
!     if (ff_search_ctx->ffsc_stack_ptr != NULL)
! 	ff_search_ctx->ffsc_stack_ptr = ff_search_ctx->ffsc_stack_ptr->ffs_prev;
  
      return sptr;
  }
--- 5115,5149 ----
  }
  
  /*
!  * Push a dir on the directory stack.
   */
      static void
! ff_push(search_ctx, stack_ptr)
!     ff_search_ctx_T *search_ctx;
!     ff_stack_T	    *stack_ptr;
  {
      /* check for NULL pointer, not to return an error to the user, but
       * to prevent a crash */
!     if (stack_ptr != NULL)
      {
! 	stack_ptr->ffs_prev = search_ctx->ffsc_stack_ptr;
! 	search_ctx->ffsc_stack_ptr = stack_ptr;
      }
  }
  
  /*
!  * Pop a dir from the directory stack.
!  * Returns NULL if stack is empty.
   */
      static ff_stack_T *
! ff_pop(search_ctx)
!     ff_search_ctx_T *search_ctx;
  {
      ff_stack_T  *sptr;
  
!     sptr = search_ctx->ffsc_stack_ptr;
!     if (search_ctx->ffsc_stack_ptr != NULL)
! 	search_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;
  
      return sptr;
  }
***************
*** 5138,5199 ****
   * free the given stack element
   */
      static void
! ff_free_stack_element(ctx)
!     ff_stack_T  *ctx;
  {
      /* vim_free handles possible NULL pointers */
!     vim_free(ctx->ffs_fix_path);
  #ifdef FEAT_PATH_EXTRA
!     vim_free(ctx->ffs_wc_path);
  #endif
  
!     if (ctx->ffs_filearray != NULL)
! 	FreeWild(ctx->ffs_filearray_size, ctx->ffs_filearray);
  
!     vim_free(ctx);
  }
  
  /*
!  * clear the search context
   */
      static void
! ff_clear()
  {
      ff_stack_T   *sptr;
  
      /* clear up stack */
!     while ((sptr = ff_pop()) != NULL)
  	ff_free_stack_element(sptr);
  
!     vim_free(ff_search_ctx->ffsc_file_to_search);
!     vim_free(ff_search_ctx->ffsc_start_dir);
!     vim_free(ff_search_ctx->ffsc_fix_path);
  #ifdef FEAT_PATH_EXTRA
!     vim_free(ff_search_ctx->ffsc_wc_path);
  #endif
  
  #ifdef FEAT_PATH_EXTRA
!     if (ff_search_ctx->ffsc_stopdirs_v != NULL)
      {
  	int  i = 0;
  
! 	while (ff_search_ctx->ffsc_stopdirs_v[i] != NULL)
  	{
! 	    vim_free(ff_search_ctx->ffsc_stopdirs_v[i]);
  	    i++;
  	}
! 	vim_free(ff_search_ctx->ffsc_stopdirs_v);
      }
!     ff_search_ctx->ffsc_stopdirs_v = NULL;
  #endif
  
      /* reset everything */
!     ff_search_ctx->ffsc_file_to_search	= NULL;
!     ff_search_ctx->ffsc_start_dir	= NULL;
!     ff_search_ctx->ffsc_fix_path	= NULL;
  #ifdef FEAT_PATH_EXTRA
!     ff_search_ctx->ffsc_wc_path		= NULL;
!     ff_search_ctx->ffsc_level		= 0;
  #endif
  }
  
--- 5152,5214 ----
   * free the given stack element
   */
      static void
! ff_free_stack_element(stack_ptr)
!     ff_stack_T  *stack_ptr;
  {
      /* vim_free handles possible NULL pointers */
!     vim_free(stack_ptr->ffs_fix_path);
  #ifdef FEAT_PATH_EXTRA
!     vim_free(stack_ptr->ffs_wc_path);
  #endif
  
!     if (stack_ptr->ffs_filearray != NULL)
! 	FreeWild(stack_ptr->ffs_filearray_size, stack_ptr->ffs_filearray);
  
!     vim_free(stack_ptr);
  }
  
  /*
!  * Clear the search context, but NOT the visited list.
   */
      static void
! ff_clear(search_ctx)
!     ff_search_ctx_T *search_ctx;
  {
      ff_stack_T   *sptr;
  
      /* clear up stack */
!     while ((sptr = ff_pop(search_ctx)) != NULL)
  	ff_free_stack_element(sptr);
  
!     vim_free(search_ctx->ffsc_file_to_search);
!     vim_free(search_ctx->ffsc_start_dir);
!     vim_free(search_ctx->ffsc_fix_path);
  #ifdef FEAT_PATH_EXTRA
!     vim_free(search_ctx->ffsc_wc_path);
  #endif
  
  #ifdef FEAT_PATH_EXTRA
!     if (search_ctx->ffsc_stopdirs_v != NULL)
      {
  	int  i = 0;
  
! 	while (search_ctx->ffsc_stopdirs_v[i] != NULL)
  	{
! 	    vim_free(search_ctx->ffsc_stopdirs_v[i]);
  	    i++;
  	}
! 	vim_free(search_ctx->ffsc_stopdirs_v);
      }
!     search_ctx->ffsc_stopdirs_v = NULL;
  #endif
  
      /* reset everything */
!     search_ctx->ffsc_file_to_search = NULL;
!     search_ctx->ffsc_start_dir = NULL;
!     search_ctx->ffsc_fix_path = NULL;
  #ifdef FEAT_PATH_EXTRA
!     search_ctx->ffsc_wc_path = NULL;
!     search_ctx->ffsc_level = 0;
  #endif
  }
  
***************
*** 5242,5248 ****
  
  #if defined(FEAT_SEARCHPATH) || defined(PROTO)
  /*
!  * Find the file name "ptr[len]" in the path.
   *
   * On the first call set the parameter 'first' to TRUE to initialize
   * the search.  For repeating calls to FALSE.
--- 5257,5263 ----
  
  #if defined(FEAT_SEARCHPATH) || defined(PROTO)
  /*
!  * Find the file name "ptr[len]" in the path.  Also finds directory names.
   *
   * On the first call set the parameter 'first' to TRUE to initialize
   * the search.  For repeating calls to FALSE.
***************
*** 5276,5282 ****
  {
      return find_file_in_path_option(ptr, len, options, first,
  	    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,
! 	    FALSE, rel_fname, curbuf->b_p_sua);
  }
  
  static char_u	*ff_file_to_find = NULL;
--- 5291,5297 ----
  {
      return find_file_in_path_option(ptr, len, options, first,
  	    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,
! 	    FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);
  }
  
  static char_u	*ff_file_to_find = NULL;
***************
*** 5309,5325 ****
      char_u	*rel_fname;	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,
! 					       TRUE, rel_fname, (char_u *)"");
  }
  
      char_u *
! find_file_in_path_option(ptr, len, options, first, path_option, need_dir, rel_fname, suffixes)
      char_u	*ptr;		/* file name */
      int		len;		/* length of file name */
      int		options;
      int		first;		/* use count'th matching file name */
      char_u	*path_option;	/* p_path or p_cdpath */
!     int		need_dir;	/* looking for directory name */
      char_u	*rel_fname;	/* file name we are looking relative to. */
      char_u	*suffixes;	/* list of suffixes, 'suffixesadd' option */
  {
--- 5324,5340 ----
      char_u	*rel_fname;	/* file name searching relative to */
  {
      return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,
! 				       FINDFILE_DIR, rel_fname, (char_u *)"");
  }
  
      char_u *
! find_file_in_path_option(ptr, len, options, first, path_option, find_what, rel_fname, suffixes)
      char_u	*ptr;		/* file name */
      int		len;		/* length of file name */
      int		options;
      int		first;		/* use count'th matching file name */
      char_u	*path_option;	/* p_path or p_cdpath */
!     int		find_what;	/* FINDFILE_FILE, _DIR or _BOTH */
      char_u	*rel_fname;	/* file name we are looking relative to. */
      char_u	*suffixes;	/* list of suffixes, 'suffixesadd' option */
  {
***************
*** 5421,5432 ****
  #ifdef DJGPP
  			    /* "C:" by itself will fail for mch_getperm(),
  			     * assume it's always valid. */
! 			    (need_dir && NameBuff[0] != NUL
  				  && NameBuff[1] == ':'
  				  && NameBuff[2] == NUL) ||
  #endif
  			    (mch_getperm(NameBuff) >= 0
! 				       && (!need_dir || mch_isdir(NameBuff))))
  		    {
  			file_name = vim_strsave(NameBuff);
  			goto theend;
--- 5436,5449 ----
  #ifdef DJGPP
  			    /* "C:" by itself will fail for mch_getperm(),
  			     * assume it's always valid. */
! 			    (find_what != FINDFILE_FILE && NameBuff[0] != NUL
  				  && NameBuff[1] == ':'
  				  && NameBuff[2] == NUL) ||
  #endif
  			    (mch_getperm(NameBuff) >= 0
! 			     && (find_what == FINDFILE_BOTH
! 				 || ((find_what == FINDFILE_DIR)
! 						    == mch_isdir(NameBuff)))))
  		    {
  			file_name = vim_strsave(NameBuff);
  			goto theend;
***************
*** 5457,5465 ****
  	{
  	    if (did_findfile_init)
  	    {
- 		ff_search_ctx->ffsc_need_dir = need_dir;
  		file_name = vim_findfile(fdip_search_ctx);
- 		ff_search_ctx->ffsc_need_dir = FALSE;
  		if (file_name != NULL)
  		    break;
  
--- 5474,5480 ----
***************
*** 5492,5498 ****
  		r_ptr = NULL;
  #endif
  		fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,
! 					    r_ptr, 100, FALSE, TRUE,
  					   fdip_search_ctx, FALSE, rel_fname);
  		if (fdip_search_ctx != NULL)
  		    did_findfile_init = TRUE;
--- 5507,5513 ----
  		r_ptr = NULL;
  #endif
  		fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,
! 					    r_ptr, 100, FALSE, find_what,
  					   fdip_search_ctx, FALSE, rel_fname);
  		if (fdip_search_ctx != NULL)
  		    did_findfile_init = TRUE;
***************
*** 5504,5510 ****
      {
  	if (first == TRUE)
  	{
! 	    if (need_dir)
  		EMSG2(_("E344: Can't find directory \"%s\" in cdpath"),
  			ff_file_to_find);
  	    else
--- 5519,5525 ----
      {
  	if (first == TRUE)
  	{
! 	    if (find_what == FINDFILE_DIR)
  		EMSG2(_("E344: Can't find directory \"%s\" in cdpath"),
  			ff_file_to_find);
  	    else
***************
*** 5513,5519 ****
  	}
  	else
  	{
! 	    if (need_dir)
  		EMSG2(_("E346: No more directory \"%s\" found in cdpath"),
  			ff_file_to_find);
  	    else
--- 5528,5534 ----
  	}
  	else
  	{
! 	    if (find_what == FINDFILE_DIR)
  		EMSG2(_("E346: No more directory \"%s\" found in cdpath"),
  			ff_file_to_find);
  	    else
*** ../vim-7.1.255/src/vim.h	Sat Jan 19 15:55:51 2008
--- src/vim.h	Tue Jan 22 22:35:16 2008
***************
*** 721,726 ****
--- 721,731 ----
  /* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
   * is used when executing commands and EW_SILENT for interactive expanding. */
  
+ /* Flags for find_file_*() functions. */
+ #define FINDFILE_FILE	0	/* only files */
+ #define FINDFILE_DIR	1	/* only directories */
+ #define FINDFILE_BOTH	2	/* files and directories */
+ 
  #ifdef FEAT_VERTSPLIT
  # define W_WINCOL(wp)	(wp->w_wincol)
  # define W_WIDTH(wp)	(wp->w_width)
*** ../vim-7.1.255/src/tag.c	Sat Jan 19 15:55:51 2008
--- src/tag.c	Wed Feb 13 18:02:32 2008
***************
*** 2669,2676 ****
  
  	    tnp->tn_search_ctx = vim_findfile_init(buf, filename,
  		    r_ptr, 100,
! 		    FALSE, /* don't free visited list */
! 		    FALSE, /* we search for a file */
  		    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);
  	    if (tnp->tn_search_ctx != NULL)
  		tnp->tn_did_filefind_init = TRUE;
--- 2669,2676 ----
  
  	    tnp->tn_search_ctx = vim_findfile_init(buf, filename,
  		    r_ptr, 100,
! 		    FALSE,         /* don't free visited list */
! 		    FINDFILE_FILE, /* we search for a file */
  		    tnp->tn_search_ctx, TRUE, curbuf->b_ffname);
  	    if (tnp->tn_search_ctx != NULL)
  		tnp->tn_did_filefind_init = TRUE;
***************
*** 2691,2696 ****
--- 2691,2697 ----
  {
      vim_free(tnp->tn_tags);
      vim_findfile_cleanup(tnp->tn_search_ctx);
+     tnp->tn_search_ctx = NULL;
      ga_clear_strings(&tag_fnames);
  }
  
*** ../vim-7.1.255/src/version.c	Wed Feb 20 11:27:59 2008
--- src/version.c	Wed Feb 20 12:09:54 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     256,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
38. You wake up at 3 a.m. to go to the bathroom and stop and check your e-mail
    on the way back to bed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.257
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.257
Problem:    Configure can't always find the Tcl header files.
Solution:   Also look in /usr/local/include/tcl$tclver and
	    /usr/include/tcl$tclver (James Vega)
Files:	    src/auto/configure, src/configure.in


*** ../vim-7.1.256/src/auto/configure	Wed Feb 13 10:27:28 2008
--- src/auto/configure	Wed Feb 13 11:20:00 2008
***************
*** 4669,4678 ****
        echo "$as_me:$LINENO: checking for location of Tcl include" >&5
  echo $ECHO_N "checking for location of Tcl include... $ECHO_C" >&6
        if test "x$MACOSX" != "xyes"; then
! 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/include"
        else
  		tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
        fi
        for try in $tclinc; do
  	if test -f "$try/tcl.h"; then
  	  echo "$as_me:$LINENO: result: $try/tcl.h" >&5
--- 4669,4679 ----
        echo "$as_me:$LINENO: checking for location of Tcl include" >&5
  echo $ECHO_N "checking for location of Tcl include... $ECHO_C" >&6
        if test "x$MACOSX" != "xyes"; then
! 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/include /usr/include/tcl$tclver"
        else
  		tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
        fi
+       TCL_INC=
        for try in $tclinc; do
  	if test -f "$try/tcl.h"; then
  	  echo "$as_me:$LINENO: result: $try/tcl.h" >&5
*** ../vim-7.1.256/src/configure.in	Wed Feb 13 10:27:28 2008
--- src/configure.in	Wed Feb 13 11:23:55 2008
***************
*** 794,804 ****
  
        AC_MSG_CHECKING(for location of Tcl include)
        if test "x$MACOSX" != "xyes"; then
! 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/include"
        else
  	dnl For Mac OS X 10.3, use the OS-provided framework location
  	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
        fi
        for try in $tclinc; do
  	if test -f "$try/tcl.h"; then
  	  AC_MSG_RESULT($try/tcl.h)
--- 794,805 ----
  
        AC_MSG_CHECKING(for location of Tcl include)
        if test "x$MACOSX" != "xyes"; then
! 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
        else
  	dnl For Mac OS X 10.3, use the OS-provided framework location
  	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
        fi
+       TCL_INC=
        for try in $tclinc; do
  	if test -f "$try/tcl.h"; then
  	  AC_MSG_RESULT($try/tcl.h)
*** ../vim-7.1.256/src/version.c	Wed Feb 20 12:22:59 2008
--- src/version.c	Wed Feb 20 12:42:17 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     257,
  /**/

-- 
He who laughs last, thinks slowest.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.258
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.258
Problem:    Crash when doing "d/\n/e" and 'virtualedit' is "all". (Andy Wokula)
Solution:   Avoid that the column becomes negative.  Also fixes other problems
	    with the end of a pattern match is in column zero. (A.Politz)
Files:	    src/search.c


*** ../vim-7.1.257/src/search.c	Sat Jan 26 21:15:00 2008
--- src/search.c	Wed Feb 20 13:22:23 2008
***************
*** 624,630 ****
  #ifdef FEAT_EVAL
  		    submatch = first_submatch(&regmatch);
  #endif
! 		    /* Line me be past end of buffer for "\n\zs". */
  		    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)
  			ptr = (char_u *)"";
  		    else
--- 624,630 ----
  #ifdef FEAT_EVAL
  		    submatch = first_submatch(&regmatch);
  #endif
! 		    /* "lnum" may be past end of buffer for "\n\zs". */
  		    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)
  			ptr = (char_u *)"";
  		    else
***************
*** 833,853 ****
  			    continue;
  		    }
  
! 		    if (options & SEARCH_END && !(options & SEARCH_NOOF))
  		    {
  			pos->lnum = lnum + endpos.lnum;
! 			pos->col = endpos.col - 1;
! #ifdef FEAT_MBYTE
! 			if (has_mbyte)
  			{
! 			    /* 'e' offset may put us just below the last line */
! 			    if (pos->lnum > buf->b_ml.ml_line_count)
! 				ptr = (char_u *)"";
! 			    else
! 				ptr = ml_get_buf(buf, pos->lnum, FALSE);
! 			    pos->col -= (*mb_head_off)(ptr, ptr + pos->col);
  			}
  #endif
  		    }
  		    else
  		    {
--- 833,870 ----
  			    continue;
  		    }
  
! 		    /* With the SEARCH_END option move to the last character
! 		     * of the match.  Don't do it for an empty match, end
! 		     * should be same as start then. */
! 		    if (options & SEARCH_END && !(options & SEARCH_NOOF)
! 			    && !(matchpos.lnum == endpos.lnum
! 				&& matchpos.col == endpos.col))
  		    {
+ 			/* For a match in the first column, set the position
+ 			 * on the NUL in the previous line. */
  			pos->lnum = lnum + endpos.lnum;
! 			pos->col = endpos.col;
! 			if (endpos.col == 0)
  			{
! 			    if (pos->lnum > 1)  /* just in case */
! 			    {
! 				--pos->lnum;
! 				pos->col = (colnr_T)STRLEN(ml_get_buf(buf,
! 							   pos->lnum, FALSE));
! 			    }
  			}
+ 			else
+ 			{
+ 			    --pos->col;
+ #ifdef FEAT_MBYTE
+ 			    if (has_mbyte
+ 				    && pos->lnum <= buf->b_ml.ml_line_count)
+ 			    {
+ 				ptr = ml_get_buf(buf, pos->lnum, FALSE);
+ 				pos->col -= (*mb_head_off)(ptr, ptr + pos->col);
+ 			    }
  #endif
+ 			}
  		    }
  		    else
  		    {
*** ../vim-7.1.257/src/version.c	Wed Feb 20 12:43:05 2008
--- src/version.c	Wed Feb 20 13:37:32 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     258,
  /**/

-- 
Micro$oft: where do you want to go today?
    Linux: where do you want to go tomorrow?
  FreeBSD: are you guys coming, or what?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.259
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.259
Problem:    Cursor is in the wrong position when 'rightleft' is set,
	    'encoding' is "utf-8" and on an illegal byte.  (Dominique Pelle)
Solution:   Only put the cursor in the first column when actually on a
	    double-wide character.  (Yukihiro Nakadaira)
Files:	    src/screen.c


*** ../vim-7.1.258/src/screen.c	Wed Feb 13 21:48:24 2008
--- src/screen.c	Wed Feb 20 14:06:26 2008
***************
*** 8045,8053 ****
  	windgoto(W_WINROW(curwin) + curwin->w_wrow,
  		W_WINCOL(curwin) + (
  #ifdef FEAT_RIGHTLEFT
  		curwin->w_p_rl ? ((int)W_WIDTH(curwin) - curwin->w_wcol - (
  # ifdef FEAT_MBYTE
! 			has_mbyte ? (*mb_ptr2cells)(ml_get_cursor()) :
  # endif
  			1)) :
  #endif
--- 8045,8057 ----
  	windgoto(W_WINROW(curwin) + curwin->w_wrow,
  		W_WINCOL(curwin) + (
  #ifdef FEAT_RIGHTLEFT
+ 		/* With 'rightleft' set and the cursor on a double-wide
+ 		 * character, position it on the leftmost column. */
  		curwin->w_p_rl ? ((int)W_WIDTH(curwin) - curwin->w_wcol - (
  # ifdef FEAT_MBYTE
! 			(has_mbyte
! 			   && (*mb_ptr2cells)(ml_get_cursor()) == 2
! 			   && vim_isprintc(gchar_cursor())) ? 2 :
  # endif
  			1)) :
  #endif
*** ../vim-7.1.258/src/version.c	Wed Feb 20 13:41:14 2008
--- src/version.c	Wed Feb 20 14:10:23 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     259,
  /**/

-- 
A day without sunshine is like, well, night.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.260
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.260
Problem:    Cursor positioning problem after ^@ wrapping halfway when
	    'encoding' is utf-8.
Solution:   Only count a position for printable characters.  (partly by
	    Yukihiro Nakadaira)
Files:	    src/charset.c


*** ../vim-7.1.259/src/charset.c	Sun Aug 19 22:42:27 2007
--- src/charset.c	Wed Feb 20 14:39:04 2008
***************
*** 1290,1296 ****
  		    /* If a double-cell char doesn't fit at the end of a line
  		     * it wraps to the next line, it's like this char is three
  		     * cells wide. */
! 		    if (incr == 2 && wp->w_p_wrap && in_win_border(wp, vcol))
  		    {
  			++incr;
  			head = 1;
--- 1290,1297 ----
  		    /* If a double-cell char doesn't fit at the end of a line
  		     * it wraps to the next line, it's like this char is three
  		     * cells wide. */
! 		    if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1
! 			    && in_win_border(wp, vcol))
  		    {
  			++incr;
  			head = 1;
*** ../vim-7.1.259/src/version.c	Wed Feb 20 14:15:45 2008
--- src/version.c	Wed Feb 20 14:57:45 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     260,
  /**/

-- 
The users that I support would double-click on a landmine to find out
what happens.				-- A system administrator

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.261
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.261
Problem:    When a 2 byte BOM is detected Vim uses UCS-2, which doesn't work
	    for UTF-16 text. (Tony Mechelynck)
Solution:   Default to UTF-16.
Files:	    src/fileio.c, src/testdir/test42.ok


*** ../vim-7.1.260/src/fileio.c	Fri Jan  4 16:30:40 2008
--- src/fileio.c	Wed Feb 20 11:22:10 2008
***************
*** 5514,5523 ****
      else if (p[0] == 0xfe && p[1] == 0xff
  	    && (flags == FIO_ALL || flags == FIO_UCS2 || flags == FIO_UTF16))
      {
! 	if (flags == FIO_UTF16)
! 	    name = "utf-16";	/* FE FF */
! 	else
  	    name = "ucs-2";	/* FE FF */
      }
      else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe
  	    && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4))
--- 5523,5533 ----
      else if (p[0] == 0xfe && p[1] == 0xff
  	    && (flags == FIO_ALL || flags == FIO_UCS2 || flags == FIO_UTF16))
      {
! 	/* Default to utf-16, it works also for ucs-2 text. */
! 	if (flags == FIO_UCS2)
  	    name = "ucs-2";	/* FE FF */
+ 	else
+ 	    name = "utf-16";	/* FE FF */
      }
      else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe
  	    && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4))
*** ../vim-7.1.260/src/testdir/test42.ok	Sun Jun 13 21:02:32 2004
--- src/testdir/test42.ok	Wed Feb 20 13:27:37 2008
***************
*** 15,21 ****
  utf-8err
  
  
!   fileencoding=ucs-2
    bomb
  ucs-2
  
--- 15,21 ----
  utf-8err
  
  
!   fileencoding=utf-16
    bomb
  ucs-2
  
*** ../vim-7.1.260/src/version.c	Wed Feb 20 14:58:46 2008
--- src/version.c	Wed Feb 20 18:13:00 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     261,
  /**/

-- 
Seen it all, done it all, can't remember most of it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.262
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.262
Problem:    Can't get the process ID of Vim.
Solution:   Implement getpid().
Files:	    src/eval.c, runtime/doc/eval.txt


*** ../vim-7.1.261/src/eval.c	Wed Feb 20 12:22:59 2008
--- src/eval.c	Wed Feb 20 11:08:21 2008
***************
*** 532,537 ****
--- 532,538 ----
  static void f_getftype __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getline __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getmatches __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_getpid __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getpos __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getqflist __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getreg __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 7132,7137 ****
--- 7133,7139 ----
      {"getline",		1, 2, f_getline},
      {"getloclist",	1, 1, f_getqflist},
      {"getmatches",	0, 0, f_getmatches},
+     {"getpid",		0, 0, f_getpid},
      {"getpos",		1, 1, f_getpos},
      {"getqflist",	0, 0, f_getqflist},
      {"getreg",		0, 2, f_getreg},
***************
*** 10371,10376 ****
--- 10373,10390 ----
  	}
      }
  #endif
+ }
+ 
+ /*
+  * "getpid()" function
+  */
+ /*ARGSUSED*/
+     static void
+ f_getpid(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+     rettv->vval.v_number = mch_get_pid();
  }
  
  /*
*** ../vim-7.1.261/runtime/doc/eval.txt	Wed Feb 13 12:41:30 2008
--- runtime/doc/eval.txt	Wed Feb 20 11:10:17 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Feb 13
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Feb 20
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1638,1643 ****
--- 1638,1644 ----
  getline( {lnum}, {end})		List	lines {lnum} to {end} of current buffer
  getloclist({nr})		List	list of location list items
  getmatches()			List	list of current matches
+ getpid()			Number	process ID of Vim
  getpos( {expr})			List	position of cursor, mark, etc.
  getqflist()			List	list of quickfix items
  getreg( [{regname} [, 1]])	String	contents of register
***************
*** 3833,3838 ****
--- 3837,3846 ----
  		characters.  nr2char(0) is a real NUL and terminates the
  		string, thus results in an empty string.
  
+ 							*getpid()*
+ getpid()	Return a Number which is the process ID of the Vim process.
+ 		On Unix this is a unique number.  On MS-DOS it's always zero.
+ 
  							*getpos()*
  getpos({expr})	Get the position for {expr}.  For possible values of {expr}
  		see |line()|.
*** ../vim-7.1.261/src/version.c	Wed Feb 20 18:14:25 2008
--- src/version.c	Wed Feb 20 20:04:14 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     262,
  /**/

-- 
Those who live by the sword get shot by those who don't.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.263
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.263
Problem:    The filetype can consist of two dot separated names.  This works
	    for syntax and ftplugin, but not for indent. (Brett Stahlman)
Solution:   Use split() and loop over each dot separated name.
Files:	    runtime/indent.vim


*** ../vim-7.1.262/runtime/indent.vim	Mon Mar 28 22:56:55 2005
--- runtime/indent.vim	Fri Feb 22 21:05:39 2008
***************
*** 1,7 ****
  " Vim support file to switch on loading indent files for file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2005 Mar 28
  
  if exists("did_indent_on")
    finish
--- 1,7 ----
  " Vim support file to switch on loading indent files for file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2008 Feb 22
  
  if exists("did_indent_on")
    finish
***************
*** 15,25 ****
        exe b:undo_indent
        unlet! b:undo_indent b:did_indent
      endif
!     if expand("<amatch>") != ""
        if exists("b:did_indent")
  	unlet b:did_indent
        endif
!       runtime! indent/<amatch>.vim
      endif
    endfunc
  augroup END
--- 15,31 ----
        exe b:undo_indent
        unlet! b:undo_indent b:did_indent
      endif
!     let s = expand("<amatch>")
!     if s != ""
        if exists("b:did_indent")
  	unlet b:did_indent
        endif
! 
!       " When there is a dot it is used to separate filetype names.  Thus for
!       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
!       for name in split(s, '\.')
! 	exe 'runtime! indent/' . name . '.vim'
!       endfor
      endif
    endfunc
  augroup END
*** ../vim-7.1.262/src/version.c	Wed Feb 20 20:09:44 2008
--- src/version.c	Mon Feb 25 20:44:04 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     263,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
45. You buy a Captain Kirk chair with a built-in keyboard and mouse.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.264
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.264
Problem:    Crash when indenting lines. (Dominique Pelle)
Solution:   Set the cursor column when changing the cursor line.
Files:	    src/ops.c, src/misc1.c


*** ../vim-7.1.263/src/ops.c	Wed Feb  6 14:43:50 2008
--- src/ops.c	Sun Feb 24 14:56:38 2008
***************
*** 692,697 ****
--- 692,698 ----
  	    }
  	}
  	++curwin->w_cursor.lnum;
+ 	curwin->w_cursor.col = 0;  /* make sure it's valid */
      }
  
      /* put cursor on first non-blank of indented line */
*** ../vim-7.1.263/src/misc1.c	Wed Feb 13 10:57:11 2008
--- src/misc1.c	Sun Feb 24 15:04:27 2008
***************
*** 6894,6899 ****
--- 6894,6900 ----
  			if (trypos != NULL)
  			{
  			    curwin->w_cursor.lnum = trypos->lnum + 1;
+ 			    curwin->w_cursor.col = 0;
  			    continue;
  			}
  
***************
*** 6954,6959 ****
--- 6955,6961 ----
  			    if (trypos != NULL)
  			    {
  				curwin->w_cursor.lnum = trypos->lnum + 1;
+ 				curwin->w_cursor.col = 0;
  				continue;
  			    }
  			}
***************
*** 6991,6996 ****
--- 6993,6999 ----
  		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
+ 		    curwin->w_cursor.col = 0;
  		    continue;
  		}
  
***************
*** 7114,7120 ****
--- 7117,7126 ----
  		{
  		    if (find_last_paren(l, '{', '}') && (trypos =
  				    find_start_brace(ind_maxcomment)) != NULL)
+ 		    {
  			curwin->w_cursor.lnum = trypos->lnum + 1;
+ 			curwin->w_cursor.col = 0;
+ 		    }
  		    continue;
  		}
  
***************
*** 7230,7240 ****
  			 *     case xx:  if ( asdf &&
  			 *			asdf)
  			 */
! 			curwin->w_cursor.lnum = trypos->lnum;
  			l = ml_get_curline();
  			if (cin_iscase(l) || cin_isscopedecl(l))
  			{
  			    ++curwin->w_cursor.lnum;
  			    continue;
  			}
  		    }
--- 7236,7247 ----
  			 *     case xx:  if ( asdf &&
  			 *			asdf)
  			 */
! 			curwin->w_cursor = *trypos;
  			l = ml_get_curline();
  			if (cin_iscase(l) || cin_isscopedecl(l))
  			{
  			    ++curwin->w_cursor.lnum;
+ 			    curwin->w_cursor.col = 0;
  			    continue;
  			}
  		    }
***************
*** 7254,7259 ****
--- 7261,7267 ----
  			    if (*l == NUL || l[STRLEN(l) - 1] != '\\')
  				break;
  			    --curwin->w_cursor.lnum;
+ 			    curwin->w_cursor.col = 0;
  			}
  		    }
  
***************
*** 7587,7597 ****
  			     *	   case xx:  if ( asdf &&
  			     *			    asdf)
  			     */
! 			    curwin->w_cursor.lnum = trypos->lnum;
  			    l = ml_get_curline();
  			    if (cin_iscase(l) || cin_isscopedecl(l))
  			    {
  				++curwin->w_cursor.lnum;
  				continue;
  			    }
  			}
--- 7595,7606 ----
  			     *	   case xx:  if ( asdf &&
  			     *			    asdf)
  			     */
! 			    curwin->w_cursor = *trypos;
  			    l = ml_get_curline();
  			    if (cin_iscase(l) || cin_isscopedecl(l))
  			    {
  				++curwin->w_cursor.lnum;
+ 				curwin->w_cursor.col = 0;
  				continue;
  			    }
  			}
***************
*** 7652,7664 ****
  				&& (trypos = find_start_brace(ind_maxcomment))
  							    != NULL) /* XXX */
  			{
! 			    curwin->w_cursor.lnum = trypos->lnum;
  			    /* if not "else {" check for terminated again */
  			    /* but skip block for "} else {" */
  			    l = cin_skipcomment(ml_get_curline());
  			    if (*l == '}' || !cin_iselse(l))
  				goto term_again;
  			    ++curwin->w_cursor.lnum;
  			}
  		    }
  		}
--- 7661,7674 ----
  				&& (trypos = find_start_brace(ind_maxcomment))
  							    != NULL) /* XXX */
  			{
! 			    curwin->w_cursor = *trypos;
  			    /* if not "else {" check for terminated again */
  			    /* but skip block for "} else {" */
  			    l = cin_skipcomment(ml_get_curline());
  			    if (*l == '}' || !cin_iselse(l))
  				goto term_again;
  			    ++curwin->w_cursor.lnum;
+ 			    curwin->w_cursor.col = 0;
  			}
  		    }
  		}
***************
*** 7727,7732 ****
--- 7737,7743 ----
  		if ((trypos = find_start_comment(ind_maxcomment)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
+ 		    curwin->w_cursor.col = 0;
  		    continue;
  		}
  
***************
*** 7777,7783 ****
  		    if (find_last_paren(l, '(', ')')
  			    && (trypos = find_match_paren(ind_maxparen,
  						     ind_maxcomment)) != NULL)
! 			curwin->w_cursor.lnum = trypos->lnum;
  
  		    /* For a line ending in ',' that is a continuation line go
  		     * back to the first line with a backslash:
--- 7788,7794 ----
  		    if (find_last_paren(l, '(', ')')
  			    && (trypos = find_match_paren(ind_maxparen,
  						     ind_maxcomment)) != NULL)
! 			curwin->w_cursor = *trypos;
  
  		    /* For a line ending in ',' that is a continuation line go
  		     * back to the first line with a backslash:
***************
*** 7791,7796 ****
--- 7802,7808 ----
  			if (*l == NUL || l[STRLEN(l) - 1] != '\\')
  			    break;
  			--curwin->w_cursor.lnum;
+ 			curwin->w_cursor.col = 0;
  		    }
  
  		    amount = get_indent();	    /* XXX */
***************
*** 7864,7870 ****
  
  		if ((trypos = find_match_paren(ind_maxparen,
  						     ind_maxcomment)) != NULL)
! 		    curwin->w_cursor.lnum = trypos->lnum;
  		amount = get_indent();	    /* XXX */
  		break;
  	    }
--- 7876,7882 ----
  
  		if ((trypos = find_match_paren(ind_maxparen,
  						     ind_maxcomment)) != NULL)
! 		    curwin->w_cursor = *trypos;
  		amount = get_indent();	    /* XXX */
  		break;
  	    }
*** ../vim-7.1.263/src/version.c	Mon Feb 25 20:45:46 2008
--- src/version.c	Mon Feb 25 21:51:20 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     264,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
49. You never have to deal with busy signals when calling your ISP...because
    you never log off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.265
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.265
Problem:    When 'isfname' contains a space, cmdline completion can hang.
	    (James Vega)
Solution:   Reset the "len" variable.
Files:	    src/ex_docmd.c


*** ../vim-7.1.264/src/ex_docmd.c	Sat Jan 19 15:55:51 2008
--- src/ex_docmd.c	Sun Feb 24 22:09:52 2008
***************
*** 3346,3351 ****
--- 3346,3352 ----
  #endif
  		    ))
  	    {
+ 		len = 0;  /* avoid getting stuck when space is in 'isfname' */
  		while (*p != NUL)
  		{
  #ifdef FEAT_MBYTE
*** ../vim-7.1.264/src/version.c	Mon Feb 25 21:54:23 2008
--- src/version.c	Tue Feb 26 21:28:25 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     265,
  /**/

-- 
Q: What is a patch 22?
A: A patch you need to include to make it possible to include patches.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.266
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.266
Problem:    When the version string returned by the terminal contains
	    unexpected characters, it is used as typed input. (James Vega)
Solution:   Assume the escape sequence ends in a letter.
Files:	    src/term.c


*** ../vim-7.1.265/src/term.c	Sat Sep 15 14:06:41 2007
--- src/term.c	Mon Feb 25 20:21:53 2008
***************
*** 4050,4064 ****
  	{
  	    /* Check for xterm version string: "<Esc>[>{x};{vers};{y}c".  Also
  	     * eat other possible responses to t_RV, rxvt returns
! 	     * "<Esc>[?1;2c".  Also accept CSI instead of <Esc>[. */
  	    if (*T_CRV != NUL && ((tp[0] == ESC && tp[1] == '[' && len >= 3)
  					       || (tp[0] == CSI && len >= 2)))
  	    {
  		j = 0;
  		extra = 0;
! 		for (i = 2 + (tp[0] != CSI);
! 			i < len && (VIM_ISDIGIT(tp[i])
! 			    || tp[i] == ';' || tp[i] == '.'); ++i)
  		    if (tp[i] == ';' && ++j == 1)
  			extra = atoi((char *)tp + i + 1);
  		if (i == len)
--- 4050,4066 ----
  	{
  	    /* Check for xterm version string: "<Esc>[>{x};{vers};{y}c".  Also
  	     * eat other possible responses to t_RV, rxvt returns
! 	     * "<Esc>[?1;2c".  Also accept CSI instead of <Esc>[.
! 	     * mrxvt has been reported to have "+" in the version. Assume
! 	     * the escape sequence ends with a letter or one of "{|}~". */
  	    if (*T_CRV != NUL && ((tp[0] == ESC && tp[1] == '[' && len >= 3)
  					       || (tp[0] == CSI && len >= 2)))
  	    {
  		j = 0;
  		extra = 0;
! 		for (i = 2 + (tp[0] != CSI); i < len
! 				&& !(tp[i] >= '{' && tp[i] <= '~')
! 				&& !ASCII_ISALPHA(tp[i]); ++i)
  		    if (tp[i] == ';' && ++j == 1)
  			extra = atoi((char *)tp + i + 1);
  		if (i == len)
*** ../vim-7.1.265/src/version.c	Tue Feb 26 21:29:06 2008
--- src/version.c	Wed Feb 27 16:10:59 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     266,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
54. You start tilting your head sideways to smile. :-)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.267
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.267
Problem:    When changing folds cursor may be positioned in the wrong place.
Solution:   Call changed_window_setting_win() instead of
	    changed_window_setting().
Files:	    src/fold.c


*** ../vim-7.1.266/src/fold.c	Sun Jan 13 21:57:25 2008
--- src/fold.c	Wed Mar  5 12:48:43 2008
***************
*** 2307,2313 ****
  
      /* If some fold changed, need to redraw and position cursor. */
      if (fold_changed && wp->w_p_fen)
! 	changed_window_setting();
  
      /* If we updated folds past "bot", need to redraw more lines.  Don't do
       * this in other situations, the changed lines will be redrawn anyway and
--- 2307,2313 ----
  
      /* If some fold changed, need to redraw and position cursor. */
      if (fold_changed && wp->w_p_fen)
! 	changed_window_setting_win(wp);
  
      /* If we updated folds past "bot", need to redraw more lines.  Don't do
       * this in other situations, the changed lines will be redrawn anyway and
*** ../vim-7.1.266/src/version.c	Wed Feb 27 16:13:09 2008
--- src/version.c	Thu Mar  6 22:43:05 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     267,
  /**/

-- 
From "know your smileys":
 %	Bike accident.  A bit far-fetched, I suppose; although...
             o      _     _         _
     _o     /\_   _ \\o  (_)\__/o  (_)
   _< \_   _>(_) (_)/<_    \_| \   _|/' \/
  (_)>(_) (_)        (_)   (_)    (_)'  _\o_

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.268
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.268
Problem:    Always shows "+" at end of screen line with: ":set
	    listchars=eol:$,extends:+ nowrap list cursorline" (Gary Johnson)
Solution:   Check for lcs_eol_one instead of lcs_eol.
Files:	    src/screen.c


*** ../vim-7.1.267/src/screen.c	Wed Feb 20 14:15:45 2008
--- src/screen.c	Sun Mar  9 14:26:14 2008
***************
*** 4527,4533 ****
  #endif
  		    col == W_WIDTH(wp) - 1)
  		&& (*ptr != NUL
! 		    || (wp->w_p_list && lcs_eol != NUL && p_extra != at_end_str)
  		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
  	{
  	    c = lcs_ext;
--- 4527,4533 ----
  #endif
  		    col == W_WIDTH(wp) - 1)
  		&& (*ptr != NUL
! 		    || (wp->w_p_list && lcs_eol_one > 0)
  		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
  	{
  	    c = lcs_ext;
*** ../vim-7.1.267/src/version.c	Thu Mar  6 22:44:45 2008
--- src/version.c	Sun Mar  9 14:24:59 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     268,
  /**/

-- 
From "know your smileys":
 :-*	A big kiss!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.269
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.269
Problem:    The matchparen plugin has an arbitrary limit for the number of
	    lines to look for a match.
Solution:   Rely on the searchpair() timeout.
Files:	    runtime/plugin/matchparen.vim


*** ../vim-7.1.268/runtime/plugin/matchparen.vim	Sun Jan  6 20:05:36 2008
--- runtime/plugin/matchparen.vim	Wed Feb 27 22:39:32 2008
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2008 Jan 06
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2008 Feb 27
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 34,40 ****
    endif
  
    " Avoid that we remove the popup menu.
!   if pumvisible()
      return
    endif
  
--- 34,41 ----
    endif
  
    " Avoid that we remove the popup menu.
!   " Return when there are no colors (looks like the cursor jumps).
!   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
      return
    endif
  
***************
*** 60,98 ****
    endif
  
    " Figure out the arguments for searchpairpos().
-   " Restrict the search to visible lines with "stopline".
-   " And avoid searching very far (e.g., for closed folds and long lines)
-   " The "viewable" variables give a range in which we can scroll while keeping
-   " the cursor at the same position
-   " adjustedScrolloff accounts for very large numbers of scrolloff
-   let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
-   let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
-   let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
-   " one of these stoplines will be adjusted below, but the current values are
-   " minimal boundaries within the current window
-   let stoplinebottom = line('w$')
-   let stoplinetop = line('w0')
    if i % 2 == 0
      let s_flags = 'nW'
      let c2 = plist[i + 1]
-     if has("byte_offset") && has("syntax_items") && &smc > 0
-       let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
-       let stopline = min([bottom_viewable, byte2line(stopbyte)])
-     else
-       let stopline = min([bottom_viewable, c_lnum + 100])
-     endif
-     let stoplinebottom = stopline
    else
      let s_flags = 'nbW'
      let c2 = c
      let c = plist[i - 1]
-     if has("byte_offset") && has("syntax_items") && &smc > 0
-       let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
-       let stopline = max([top_viewable, byte2line(stopbyte)])
-     else
-       let stopline = max([top_viewable, c_lnum - 100])
-     endif
-     let stoplinetop = stopline
    endif
    if c == '['
      let c = '\['
--- 61,73 ----
***************
*** 111,120 ****
  	\ '=~?  "string\\|character\\|singlequote\\|comment"'
    execute 'if' s_skip '| let s_skip = 0 | endif'
  
    try
!     " Limit the search time to 500 msec to avoid a hang on very long lines.
!     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 500)
    catch /E118/
      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    endtry
  
--- 86,132 ----
  	\ '=~?  "string\\|character\\|singlequote\\|comment"'
    execute 'if' s_skip '| let s_skip = 0 | endif'
  
+   " Limit the search to lines visible in the window.
+   let stoplinebottom = line('w$')
+   let stoplinetop = line('w0')
+   if i % 2 == 0
+     let stopline = stoplinebottom
+   else
+     let stopline = stoplinetop
+   endif
+ 
    try
!     " Limit the search time to 300 msec to avoid a hang on very long lines.
!     " This fails when a timeout is not supported.
!     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 300)
    catch /E118/
+     " Can't use the timeout, restrict the stopline a bit more to avoid taking
+     " a long time on closed folds and long lines.
+     " The "viewable" variables give a range in which we can scroll while
+     " keeping the cursor at the same position.
+     " adjustedScrolloff accounts for very large numbers of scrolloff.
+     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
+     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
+     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
+     " one of these stoplines will be adjusted below, but the current values are
+     " minimal boundaries within the current window
+     if i % 2 == 0
+       if has("byte_offset") && has("syntax_items") && &smc > 0
+ 	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
+ 	let stopline = min([bottom_viewable, byte2line(stopbyte)])
+       else
+ 	let stopline = min([bottom_viewable, c_lnum + 100])
+       endif
+       let stoplinebottom = stopline
+     else
+       if has("byte_offset") && has("syntax_items") && &smc > 0
+ 	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
+ 	let stopline = max([top_viewable, byte2line(stopbyte)])
+       else
+ 	let stopline = max([top_viewable, c_lnum - 100])
+       endif
+       let stoplinetop = stopline
+     endif
      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    endtry
  
*** ../vim-7.1.268/src/version.c	Sun Mar  9 14:30:12 2008
--- src/version.c	Sun Mar  9 16:21:00 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     269,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
93. New mail alarm on your palmtop annoys other churchgoers.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.270
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.270
Problem:    ":?foo?" matches in current line since patch 7.1.025. (A.Politz)
Solution:   Remove the SEARCH_START flag.
Files:	    src/ex_docmd.c, src/search.c


*** ../vim-7.1.269/src/ex_docmd.c	Tue Feb 26 21:29:06 2008
--- src/ex_docmd.c	Sun Mar  2 20:50:43 2008
***************
*** 3932,3939 ****
  				curwin->w_cursor.col = 0;
  			    searchcmdlen = 0;
  			    if (!do_search(NULL, c, cmd, 1L,
! 					SEARCH_HIS + SEARCH_MSG + SEARCH_START,
! 					NULL))
  			    {
  				curwin->w_cursor = pos;
  				cmd = NULL;
--- 3932,3938 ----
  				curwin->w_cursor.col = 0;
  			    searchcmdlen = 0;
  			    if (!do_search(NULL, c, cmd, 1L,
! 					       SEARCH_HIS | SEARCH_MSG, NULL))
  			    {
  				curwin->w_cursor = pos;
  				cmd = NULL;
***************
*** 3980,3987 ****
  				pos.col = 0;
  			    if (searchit(curwin, curbuf, &pos,
  					*cmd == '?' ? BACKWARD : FORWARD,
! 					(char_u *)"", 1L,
! 					SEARCH_MSG + SEARCH_START,
  						i, (linenr_T)0, NULL) != FAIL)
  				lnum = pos.lnum;
  			    else
--- 3979,3985 ----
  				pos.col = 0;
  			    if (searchit(curwin, curbuf, &pos,
  					*cmd == '?' ? BACKWARD : FORWARD,
! 					(char_u *)"", 1L, SEARCH_MSG,
  						i, (linenr_T)0, NULL) != FAIL)
  				lnum = pos.lnum;
  			    else
*** ../vim-7.1.269/src/search.c	Wed Feb 20 13:41:14 2008
--- src/search.c	Sun Mar  2 22:00:50 2008
***************
*** 538,544 ****
  	return FAIL;
      }
  
!     if (options & SEARCH_START)
  	extra_col = 0;
  #ifdef FEAT_MBYTE
      /* Watch out for the "col" being MAXCOL - 2, used in a closed fold. */
--- 538,547 ----
  	return FAIL;
      }
  
!     /* When not accepting a match at the start position set "extra_col" to a
!      * non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL +
!      * 1 is zero. */
!     if ((options & SEARCH_START) || pos->col == MAXCOL)
  	extra_col = 0;
  #ifdef FEAT_MBYTE
      /* Watch out for the "col" being MAXCOL - 2, used in a closed fold. */
*** ../vim-7.1.269/src/version.c	Sun Mar  9 16:45:16 2008
--- src/version.c	Mon Mar 10 21:32:07 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     270,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
102. When filling out your driver's license application, you give
     your IP address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.271
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.271
Problem:    In a Vim build without autocommands, checking a file that was
	    changed externally causes the current buffer to be changed
	    unexpectedly.  (Karsten Hopp)
Solution:   Store "curbuf" instead of "buf".
Files:	    src/fileio.c


*** ../vim-7.1.270/src/fileio.c	Wed Feb 20 18:14:25 2008
--- src/fileio.c	Tue Mar 11 21:35:05 2008
***************
*** 9239,9245 ****
      aco_save_T	*aco;		/* structure to save values in */
      buf_T	*buf;		/* new curbuf */
  {
!     aco->save_buf = buf;
      curbuf = buf;
      curwin->w_buffer = buf;
  }
--- 9248,9254 ----
      aco_save_T	*aco;		/* structure to save values in */
      buf_T	*buf;		/* new curbuf */
  {
!     aco->save_buf = curbuf;
      curbuf = buf;
      curwin->w_buffer = buf;
  }
*** ../vim-7.1.270/src/version.c	Mon Mar 10 21:33:52 2008
--- src/version.c	Tue Mar 11 21:57:30 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     271,
  /**/

-- 
In a world without walls and borders, who needs windows and gates?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.272
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.272
Problem:    The special buffer name [Location List] is not used for a buffer
	    displayed in another tab page.
Solution:   Use FOR_ALL_TAB_WINDOWS instead of FOR_ALL_WINDOWS. (Hiroaki
	    Nishihara)
Files:	    src/buffer.c


*** ../vim-7.1.271/src/buffer.c	Wed Oct  3 14:30:54 2007
--- src/buffer.c	Wed Mar  5 21:55:44 2008
***************
*** 4912,4918 ****
      return retval;
  }
  
! #ifdef FEAT_VIMINFO
      int
  read_viminfo_bufferlist(virp, writing)
      vir_T	*virp;
--- 4912,4918 ----
      return retval;
  }
  
! #if defined(FEAT_VIMINFO) || defined(PROTO)
      int
  read_viminfo_bufferlist(virp, writing)
      vir_T	*virp;
***************
*** 5033,5045 ****
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
      {
! 	win_T	*win;
  
  	/*
  	 * For location list window, w_llist_ref points to the location list.
  	 * For quickfix window, w_llist_ref is NULL.
  	 */
! 	FOR_ALL_WINDOWS(win)
  	    if (win->w_buffer == buf)
  		break;
  	if (win != NULL && win->w_llist_ref != NULL)
--- 5033,5046 ----
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
      {
! 	win_T	    *win;
! 	tabpage_T   *tp;
  
  	/*
  	 * For location list window, w_llist_ref points to the location list.
  	 * For quickfix window, w_llist_ref is NULL.
  	 */
! 	FOR_ALL_TAB_WINDOWS(tp, win)
  	    if (win->w_buffer == buf)
  		break;
  	if (win != NULL && win->w_llist_ref != NULL)
*** ../vim-7.1.271/src/version.c	Tue Mar 11 22:01:16 2008
--- src/version.c	Wed Mar 12 12:21:13 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     272,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
113. You are asked about a bus schedule, you wonder if it is 16 or 32 bits.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.273
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.273
Problem:    When profiling on Linux Vim exits early. (Liu Yubao)
Solution:   When profiling don't exit on SIGPROF.
Files:	    src/Makefile, src/os_unix.c


*** ../vim-7.1.272/src/Makefile	Wed Mar 12 12:23:18 2008
--- src/Makefile	Wed Mar 12 13:11:07 2008
***************
*** 545,551 ****
  # For unknown reasons adding "-lc" fixes a linking problem with GCC.  That's
  # probably a bug in the "-pg" implementation.
  # Need to recompile everything after changing this: "make clean" "make".
! #PROFILE_CFLAGS = -pg -g
  #PROFILE_LIBS = -pg
  #PROFILE_LIBS = -pg -lc
  
--- 545,551 ----
  # For unknown reasons adding "-lc" fixes a linking problem with GCC.  That's
  # probably a bug in the "-pg" implementation.
  # Need to recompile everything after changing this: "make clean" "make".
! #PROFILE_CFLAGS = -pg -g -DWE_ARE_PROFILING
  #PROFILE_LIBS = -pg
  #PROFILE_LIBS = -pg -lc
  
*** ../vim-7.1.272/src/os_unix.c	Sun Feb 10 22:25:12 2008
--- src/os_unix.c	Wed Mar  5 22:15:41 2008
***************
*** 269,276 ****
  #ifdef SIGVTALRM
      {SIGVTALRM,	    "VTALRM",	TRUE},
  #endif
! #if defined(SIGPROF) && !defined(FEAT_MZSCHEME)
!     /* MzScheme uses SIGPROF for its own needs */
      {SIGPROF,	    "PROF",	TRUE},
  #endif
  #ifdef SIGXCPU
--- 269,277 ----
  #ifdef SIGVTALRM
      {SIGVTALRM,	    "VTALRM",	TRUE},
  #endif
! #if defined(SIGPROF) && !defined(FEAT_MZSCHEME) && !defined(WE_ARE_PROFILING)
!     /* MzScheme uses SIGPROF for its own needs; On Linux with profiling
!      * this makes Vim exit.  WE_ARE_PROFILING is defined in Makefile.  */
      {SIGPROF,	    "PROF",	TRUE},
  #endif
  #ifdef SIGXCPU
*** ../vim-7.1.272/src/version.c	Wed Mar 12 12:22:56 2008
--- src/version.c	Wed Mar 12 13:08:59 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     273,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
114. You are counting items, you go "0,1,2,3,4,5,6,7,8,9,A,B,C,D...".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.274
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.274 (after 7.1.272)
Problem:    Compiler warning for optimized build.
Solution:   Init win to NULL.
Files:	    src/buffer.c


*** ../vim-7.1.273/src/buffer.c	Wed Mar 12 12:22:56 2008
--- src/buffer.c	Wed Mar 12 13:15:21 2008
***************
*** 5033,5039 ****
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
      {
! 	win_T	    *win;
  	tabpage_T   *tp;
  
  	/*
--- 5033,5039 ----
  #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
      {
! 	win_T	    *win = NULL;
  	tabpage_T   *tp;
  
  	/*
*** ../vim-7.1.273/src/version.c	Wed Mar 12 13:16:37 2008
--- src/version.c	Wed Mar 12 13:45:25 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     274,
  /**/

-- 
FIXME and XXX are two common keywords used to mark broken or incomplete code
not only since XXX as a sex reference would grab everbodys attention but
simply due to the fact that Vim would highlight these words.
					-- Hendrik Scholz

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.275
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.275 (extra)
Problem:    Mac: ATSUI and 'antialias' don't work properly together.
Solution:   Fix this and the input method. (Jjgod Jiang)
Files:	    src/vim.h, src/gui_mac.c


*** ../vim-7.1.274/src/vim.h	Wed Feb 20 12:22:59 2008
--- src/vim.h	Wed Mar 12 13:18:58 2008
***************
*** 461,468 ****
  /*
   * Check input method control.
   */
! #if defined(FEAT_XIM) || \
!     (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME)))
  # define USE_IM_CONTROL
  #endif
  
--- 461,469 ----
  /*
   * Check input method control.
   */
! #if defined(FEAT_XIM) \
!     || (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) \
!     || defined(FEAT_GUI_MAC)
  # define USE_IM_CONTROL
  #endif
  
*** ../vim-7.1.274/src/gui_mac.c	Sat Sep 29 13:15:29 2007
--- src/gui_mac.c	Wed Mar 12 13:40:57 2008
***************
*** 59,65 ****
--- 59,91 ----
  
  #ifdef MACOS_CONVERT
  # define USE_CARBONKEYHANDLER
+ 
+ static int im_is_active = FALSE;
+ #if 0
+ static int im_start_row = 0;
+ static int im_start_col = 0;
+ #endif
+ 
+ #define NR_ELEMS(x)	(sizeof(x) / sizeof(x[0]))
+ 
+ static TSMDocumentID gTSMDocument;
+ 
+ static void im_on_window_switch(int active);
  static EventHandlerUPP keyEventHandlerUPP = NULL;
+ static EventHandlerUPP winEventHandlerUPP = NULL;
+ 
+ static pascal OSStatus gui_mac_handle_window_activate(
+ 	EventHandlerCallRef nextHandler, EventRef theEvent, void *data);
+ 
+ static pascal OSStatus gui_mac_handle_text_input(
+ 	EventHandlerCallRef nextHandler, EventRef theEvent, void *data);
+ 
+ static pascal OSStatus gui_mac_update_input_area(
+ 	EventHandlerCallRef nextHandler, EventRef theEvent);
+ 
+ static pascal OSStatus gui_mac_unicode_key_event(
+ 	EventHandlerCallRef nextHandler, EventRef theEvent);
+ 
  #endif
  
  
***************
*** 137,143 ****
--- 166,176 ----
  
  #ifdef MACOS_CONVERT
  # define USE_ATSUI_DRAWING
+ int	    p_macatsui_last;
  ATSUStyle   gFontStyle;
+ # ifdef FEAT_MBYTE
+ ATSUStyle   gWideFontStyle;
+ # endif
  Boolean	    gIsFontFallbackSet;
  #endif
  
***************
*** 265,270 ****
--- 298,308 ----
  static WindowRef drawer = NULL; // TODO: put into gui.h
  #endif
  
+ #ifdef USE_ATSUI_DRAWING
+ static void gui_mac_set_font_attributes(GuiFont font);
+ static void gui_mac_dispose_atsui_style(void);
+ #endif
+ 
  /*
   * ------------------------------------------------------------
   * Conversion Utility
***************
*** 1935,1946 ****
      /* Dim scrollbars */
      if (whichWindow == gui.VimWindow)
      {
!         ControlRef rootControl;
!         GetRootControl(gui.VimWindow, &rootControl);
!         if ((event->modifiers) & activeFlag)
!             ActivateControl(rootControl);
!         else
!             DeactivateControl(rootControl);
      }
  
      /* Activate */
--- 1973,1984 ----
      /* Dim scrollbars */
      if (whichWindow == gui.VimWindow)
      {
! 	ControlRef rootControl;
! 	GetRootControl(gui.VimWindow, &rootControl);
! 	if ((event->modifiers) & activeFlag)
! 	    ActivateControl(rootControl);
! 	else
! 	    DeactivateControl(rootControl);
      }
  
      /* Activate */
***************
*** 1976,1990 ****
   * Handle the key
   */
  #ifdef USE_CARBONKEYHANDLER
  
! static int dialog_busy = FALSE;	    /* TRUE when gui_mch_dialog() wants the keys */
  
  # define INLINE_KEY_BUFFER_SIZE 80
      static pascal OSStatus
! gui_mac_doKeyEventCarbon(
  	EventHandlerCallRef nextHandler,
! 	EventRef theEvent,
! 	void *data)
  {
      /* Multibyte-friendly key event handler */
      OSStatus	err = -1;
--- 2014,2100 ----
   * Handle the key
   */
  #ifdef USE_CARBONKEYHANDLER
+     static pascal OSStatus
+ gui_mac_handle_window_activate(
+ 	EventHandlerCallRef nextHandler,
+ 	EventRef	    theEvent,
+ 	void		    *data)
+ {
+     UInt32 eventClass = GetEventClass(theEvent);
+     UInt32 eventKind  = GetEventKind(theEvent);
+ 
+     if (eventClass == kEventClassWindow)
+     {
+ 	switch (eventKind)
+ 	{
+ 	    case kEventWindowActivated:
+ #if defined(USE_IM_CONTROL)
+ 		im_on_window_switch(TRUE);
+ #endif
+ 		return noErr;
+ 
+ 	    case kEventWindowDeactivated:
+ #if defined(USE_IM_CONTROL)
+ 		im_on_window_switch(FALSE);
+ #endif
+ 		return noErr;
+ 	}
+     }
+ 
+     return eventNotHandledErr;
+ }
+ 
+     static pascal OSStatus
+ gui_mac_handle_text_input(
+ 	EventHandlerCallRef nextHandler,
+ 	EventRef	    theEvent,
+ 	void		    *data)
+ {
+     UInt32 eventClass = GetEventClass(theEvent);
+     UInt32 eventKind  = GetEventKind(theEvent);
+ 
+     if (eventClass != kEventClassTextInput)
+ 	return eventNotHandledErr;
  
!     if ((kEventTextInputUpdateActiveInputArea != eventKind) &&
! 	(kEventTextInputUnicodeForKeyEvent    != eventKind) &&
! 	(kEventTextInputOffsetToPos	      != eventKind) &&
! 	(kEventTextInputPosToOffset	      != eventKind) &&
! 	(kEventTextInputGetSelectedText       != eventKind))
! 	      return eventNotHandledErr;
! 
!     switch (eventKind)
!     {
!     case kEventTextInputUpdateActiveInputArea:
! 	return gui_mac_update_input_area(nextHandler, theEvent);
!     case kEventTextInputUnicodeForKeyEvent:
! 	return gui_mac_unicode_key_event(nextHandler, theEvent);
! 
!     case kEventTextInputOffsetToPos:
!     case kEventTextInputPosToOffset:
!     case kEventTextInputGetSelectedText:
! 	break;
!     }
! 
!     return eventNotHandledErr;
! }
! 
!     static pascal
! OSStatus gui_mac_update_input_area(
! 	EventHandlerCallRef nextHandler,
! 	EventRef	    theEvent)
! {
!     return eventNotHandledErr;
! }
! 
! static int dialog_busy = FALSE;	    /* TRUE when gui_mch_dialog() wants the
! 				       keys */
  
  # define INLINE_KEY_BUFFER_SIZE 80
      static pascal OSStatus
! gui_mac_unicode_key_event(
  	EventHandlerCallRef nextHandler,
! 	EventRef	    theEvent)
  {
      /* Multibyte-friendly key event handler */
      OSStatus	err = -1;
***************
*** 2000,2006 ****
      char_u	*to = NULL;
      Boolean	isSpecial = FALSE;
      int		i;
!     EventRef keyEvent;
  
      /* Mask the mouse (as per user setting) */
      if (p_mh)
--- 2110,2116 ----
      char_u	*to = NULL;
      Boolean	isSpecial = FALSE;
      int		i;
!     EventRef	keyEvent;
  
      /* Mask the mouse (as per user setting) */
      if (p_mh)
***************
*** 2008,2046 ****
  
      /* Don't use the keys when the dialog wants them. */
      if (dialog_busy)
!         return eventNotHandledErr;
  
      if (noErr != GetEventParameter(theEvent, kEventParamTextInputSendText,
!                 typeUnicodeText, NULL, 0, &actualSize, NULL))
!         return eventNotHandledErr;
  
      text = (UniChar *)alloc(actualSize);
      if (!text)
!         return eventNotHandledErr;
  
      err = GetEventParameter(theEvent, kEventParamTextInputSendText,
!             typeUnicodeText, NULL, actualSize, NULL, text);
      require_noerr(err, done);
  
      err = GetEventParameter(theEvent, kEventParamTextInputSendKeyboardEvent,
!             typeEventRef, NULL, sizeof(EventRef), NULL, &keyEvent);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyModifiers,
!             typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyCode,
!             typeUInt32, NULL, sizeof(UInt32), NULL, &key_sym);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyMacCharCodes,
!             typeChar, NULL, sizeof(char), NULL, &charcode);
      require_noerr(err, done);
  
  #ifndef USE_CMD_KEY
      if (modifiers & cmdKey)
!         goto done;  /* Let system handle Cmd+... */
  #endif
  
      key_char = charcode;
--- 2118,2156 ----
  
      /* Don't use the keys when the dialog wants them. */
      if (dialog_busy)
! 	return eventNotHandledErr;
  
      if (noErr != GetEventParameter(theEvent, kEventParamTextInputSendText,
! 		typeUnicodeText, NULL, 0, &actualSize, NULL))
! 	return eventNotHandledErr;
  
      text = (UniChar *)alloc(actualSize);
      if (!text)
! 	return eventNotHandledErr;
  
      err = GetEventParameter(theEvent, kEventParamTextInputSendText,
! 	    typeUnicodeText, NULL, actualSize, NULL, text);
      require_noerr(err, done);
  
      err = GetEventParameter(theEvent, kEventParamTextInputSendKeyboardEvent,
! 	    typeEventRef, NULL, sizeof(EventRef), NULL, &keyEvent);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyModifiers,
! 	    typeUInt32, NULL, sizeof(UInt32), NULL, &modifiers);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyCode,
! 	    typeUInt32, NULL, sizeof(UInt32), NULL, &key_sym);
      require_noerr(err, done);
  
      err = GetEventParameter(keyEvent, kEventParamKeyMacCharCodes,
! 	    typeChar, NULL, sizeof(char), NULL, &charcode);
      require_noerr(err, done);
  
  #ifndef USE_CMD_KEY
      if (modifiers & cmdKey)
! 	goto done;  /* Let system handle Cmd+... */
  #endif
  
      key_char = charcode;
***************
*** 2048,2131 ****
  
      /* Find the special key (eg., for cursor keys) */
      if (actualSize <= sizeof(UniChar) &&
!             ((text[0] < 0x20) || (text[0] == 0x7f)))
      {
!         for (i = 0; special_keys[i].key_sym != (KeySym)0; ++i)
!             if (special_keys[i].key_sym == key_sym)
!             {
!                 key_char = TO_SPECIAL(special_keys[i].vim_code0,
!                         special_keys[i].vim_code1);
!                 key_char = simplify_key(key_char,
!                         (int *)&vimModifiers);
!                 isSpecial = TRUE;
!                 break;
!             }
      }
  
      /* Intercept CMD-. and CTRL-c */
      if (((modifiers & controlKey) && key_char == 'c') ||
!             ((modifiers & cmdKey) && key_char == '.'))
!         got_int = TRUE;
  
      if (!isSpecial)
      {
!         /* remove SHIFT for keys that are already shifted, e.g.,
!          * '(' and '*' */
!         if (key_char < 0x100 && !isalpha(key_char) && isprint(key_char))
!             vimModifiers &= ~MOD_MASK_SHIFT;
! 
!         /* remove CTRL from keys that already have it */
!         if (key_char < 0x20)
!             vimModifiers &= ~MOD_MASK_CTRL;
! 
!         /* don't process unicode characters here */
!         if (!IS_SPECIAL(key_char))
!         {
!             /* Following code to simplify and consolidate vimModifiers
!              * taken liberally from gui_w48.c */
!             key_char = simplify_key(key_char, (int *)&vimModifiers);
! 
!             /* Interpret META, include SHIFT, etc. */
!             key_char = extract_modifiers(key_char, (int *)&vimModifiers);
!             if (key_char == CSI)
!                 key_char = K_CSI;
! 
!             if (IS_SPECIAL(key_char))
!                 isSpecial = TRUE;
!         }
      }
  
      if (vimModifiers)
      {
!         result[len++] = CSI;
!         result[len++] = KS_MODIFIER;
!         result[len++] = vimModifiers;
      }
  
      if (isSpecial && IS_SPECIAL(key_char))
      {
!         result[len++] = CSI;
!         result[len++] = K_SECOND(key_char);
!         result[len++] = K_THIRD(key_char);
      }
      else
      {
!         encLen = actualSize;
!         to = mac_utf16_to_enc(text, actualSize, &encLen);
!         if (to)
!         {
!             /* This is basically add_to_input_buf_csi() */
!             for (i = 0; i < encLen && len < (INLINE_KEY_BUFFER_SIZE-1); ++i)
!             {
!                 result[len++] = to[i];
!                 if (to[i] == CSI)
!                 {
!                     result[len++] = KS_EXTRA;
!                     result[len++] = (int)KE_CSI;
!                 }
!             }
!             vim_free(to);
!         }
      }
  
      add_to_input_buf(result, len);
--- 2158,2241 ----
  
      /* Find the special key (eg., for cursor keys) */
      if (actualSize <= sizeof(UniChar) &&
! 	    ((text[0] < 0x20) || (text[0] == 0x7f)))
      {
! 	for (i = 0; special_keys[i].key_sym != (KeySym)0; ++i)
! 	    if (special_keys[i].key_sym == key_sym)
! 	    {
! 		key_char = TO_SPECIAL(special_keys[i].vim_code0,
! 			special_keys[i].vim_code1);
! 		key_char = simplify_key(key_char,
! 			(int *)&vimModifiers);
! 		isSpecial = TRUE;
! 		break;
! 	    }
      }
  
      /* Intercept CMD-. and CTRL-c */
      if (((modifiers & controlKey) && key_char == 'c') ||
! 	    ((modifiers & cmdKey) && key_char == '.'))
! 	got_int = TRUE;
  
      if (!isSpecial)
      {
! 	/* remove SHIFT for keys that are already shifted, e.g.,
! 	 * '(' and '*' */
! 	if (key_char < 0x100 && !isalpha(key_char) && isprint(key_char))
! 	    vimModifiers &= ~MOD_MASK_SHIFT;
! 
! 	/* remove CTRL from keys that already have it */
! 	if (key_char < 0x20)
! 	    vimModifiers &= ~MOD_MASK_CTRL;
! 
! 	/* don't process unicode characters here */
! 	if (!IS_SPECIAL(key_char))
! 	{
! 	    /* Following code to simplify and consolidate vimModifiers
! 	     * taken liberally from gui_w48.c */
! 	    key_char = simplify_key(key_char, (int *)&vimModifiers);
! 
! 	    /* Interpret META, include SHIFT, etc. */
! 	    key_char = extract_modifiers(key_char, (int *)&vimModifiers);
! 	    if (key_char == CSI)
! 		key_char = K_CSI;
! 
! 	    if (IS_SPECIAL(key_char))
! 		isSpecial = TRUE;
! 	}
      }
  
      if (vimModifiers)
      {
! 	result[len++] = CSI;
! 	result[len++] = KS_MODIFIER;
! 	result[len++] = vimModifiers;
      }
  
      if (isSpecial && IS_SPECIAL(key_char))
      {
! 	result[len++] = CSI;
! 	result[len++] = K_SECOND(key_char);
! 	result[len++] = K_THIRD(key_char);
      }
      else
      {
! 	encLen = actualSize;
! 	to = mac_utf16_to_enc(text, actualSize, &encLen);
! 	if (to)
! 	{
! 	    /* This is basically add_to_input_buf_csi() */
! 	    for (i = 0; i < encLen && len < (INLINE_KEY_BUFFER_SIZE-1); ++i)
! 	    {
! 		result[len++] = to[i];
! 		if (to[i] == CSI)
! 		{
! 		    result[len++] = KS_EXTRA;
! 		    result[len++] = (int)KE_CSI;
! 		}
! 	    }
! 	    vim_free(to);
! 	}
      }
  
      add_to_input_buf(result, len);
***************
*** 2135,2144 ****
      vim_free(text);
      if (err == noErr)
      {
!         /* Fake event to wake up WNE (required to get
!          * key repeat working */
!         PostEvent(keyUp, 0);
!         return noErr;
      }
  
      return eventNotHandledErr;
--- 2245,2254 ----
      vim_free(text);
      if (err == noErr)
      {
! 	/* Fake event to wake up WNE (required to get
! 	 * key repeat working */
! 	PostEvent(keyUp, 0);
! 	return noErr;
      }
  
      return eventNotHandledErr;
***************
*** 2334,2340 ****
      /* prevent that the vim window size changes if it's activated by a
         click into the tab pane */
      if (whichWindow == drawer)
!         return;
  #endif
  
      switch (thePart)
--- 2444,2450 ----
      /* prevent that the vim window size changes if it's activated by a
         click into the tab pane */
      if (whichWindow == drawer)
! 	return;
  #endif
  
      switch (thePart)
***************
*** 2569,2579 ****
      if (IsShowContextualMenuClick(event))
      {
  # if 0
!         gui_mac_handle_contextual_menu(event);
  # else
!         gui_mac_doMouseDownEvent(event);
  # endif
!         return;
      }
  
      /* Handle normal event */
--- 2679,2689 ----
      if (IsShowContextualMenuClick(event))
      {
  # if 0
! 	gui_mac_handle_contextual_menu(event);
  # else
! 	gui_mac_doMouseDownEvent(event);
  # endif
! 	return;
      }
  
      /* Handle normal event */
***************
*** 2832,2838 ****
  # else
      /* OSErr GetApplicationBundleFSSpec(FSSpecPtr theFSSpecPtr)
       * of TN2015
-      * This technic remove the ../Contents/MacOS/etc part
       */
      (void)GetCurrentProcess(&psn);
      /* if (err != noErr) return err; */
--- 2942,2947 ----
***************
*** 2933,2942 ****
      /* TODO: Move most of this stuff toward gui_mch_init */
      Rect	windRect;
      MenuHandle	pomme;
-     EventTypeSpec   eventTypeSpec;
      EventHandlerRef mouseWheelHandlerRef;
  #ifdef USE_CARBONKEYHANDLER
!     EventHandlerRef keyEventHandlerRef;
  #endif
      ControlRef rootControl;
  
--- 3042,3050 ----
      /* TODO: Move most of this stuff toward gui_mch_init */
      Rect	windRect;
      MenuHandle	pomme;
      EventHandlerRef mouseWheelHandlerRef;
  #ifdef USE_CARBONKEYHANDLER
!     EventTypeSpec   eventTypeSpec;
  #endif
      ControlRef rootControl;
  
***************
*** 3042,3057 ****
      }
  
  #ifdef USE_CARBONKEYHANDLER
!     eventTypeSpec.eventClass = kEventClassTextInput;
!     eventTypeSpec.eventKind = kEventUnicodeForKeyEvent;
!     keyEventHandlerUPP = NewEventHandlerUPP(gui_mac_doKeyEventCarbon);
!     if (noErr != InstallApplicationEventHandler(keyEventHandlerUPP, 1,
! 		&eventTypeSpec, NULL, &keyEventHandlerRef))
      {
- 	keyEventHandlerRef = NULL;
  	DisposeEventHandlerUPP(keyEventHandlerUPP);
  	keyEventHandlerUPP = NULL;
      }
  #endif
  
  /*
--- 3150,3196 ----
      }
  
  #ifdef USE_CARBONKEYHANDLER
!     InterfaceTypeList supportedServices = { kUnicodeDocument };
!     NewTSMDocument(1, supportedServices, &gTSMDocument, 0);
! 
!     /* We don't support inline input yet, use input window by default */
!     UseInputWindow(gTSMDocument, TRUE);
! 
!     /* Should we activate the document by default? */
!     // ActivateTSMDocument(gTSMDocument);
! 
!     EventTypeSpec textEventTypes[] = {
! 	{ kEventClassTextInput, kEventTextInputUpdateActiveInputArea },
! 	{ kEventClassTextInput, kEventTextInputUnicodeForKeyEvent },
! 	{ kEventClassTextInput, kEventTextInputPosToOffset },
! 	{ kEventClassTextInput, kEventTextInputOffsetToPos },
!     };
! 
!     keyEventHandlerUPP = NewEventHandlerUPP(gui_mac_handle_text_input);
!     if (noErr != InstallApplicationEventHandler(keyEventHandlerUPP,
! 						NR_ELEMS(textEventTypes),
! 						textEventTypes, NULL, NULL))
      {
  	DisposeEventHandlerUPP(keyEventHandlerUPP);
  	keyEventHandlerUPP = NULL;
      }
+ 
+     EventTypeSpec windowEventTypes[] = {
+ 	{ kEventClassWindow, kEventWindowActivated },
+ 	{ kEventClassWindow, kEventWindowDeactivated },
+     };
+ 
+     /* Install window event handler to support TSMDocument activate and
+      * deactivate */
+     winEventHandlerUPP = NewEventHandlerUPP(gui_mac_handle_window_activate);
+     if (noErr != InstallWindowEventHandler(gui.VimWindow,
+ 					   winEventHandlerUPP,
+ 					   NR_ELEMS(windowEventTypes),
+ 					   windowEventTypes, NULL, NULL))
+     {
+ 	DisposeEventHandlerUPP(winEventHandlerUPP);
+ 	winEventHandlerUPP = NULL;
+     }
  #endif
  
  /*
***************
*** 3107,3112 ****
--- 3246,3264 ----
      return OK;
  }
  
+ #ifdef USE_ATSUI_DRAWING
+     static void
+ gui_mac_dispose_atsui_style(void)
+ {
+     if (p_macatsui && gFontStyle)
+ 	ATSUDisposeStyle(gFontStyle);
+ #ifdef FEAT_MBYTE
+     if (p_macatsui && gWideFontStyle)
+ 	ATSUDisposeStyle(gWideFontStyle);
+ #endif
+ }
+ #endif
+ 
      void
  gui_mch_exit(int rc)
  {
***************
*** 3122,3129 ****
  	DisposeEventHandlerUPP(mouseWheelHandlerUPP);
  
  #ifdef USE_ATSUI_DRAWING
!     if (p_macatsui && gFontStyle)
! 	ATSUDisposeStyle(gFontStyle);
  #endif
  
      /* Exit to shell? */
--- 3274,3286 ----
  	DisposeEventHandlerUPP(mouseWheelHandlerUPP);
  
  #ifdef USE_ATSUI_DRAWING
!     gui_mac_dispose_atsui_style();
! #endif
! 
! #ifdef USE_CARBONKEYHANDLER
!     FixTSMDocument(gTSMDocument);
!     DeactivateTSMDocument(gTSMDocument);
!     DeleteTSMDocument(gTSMDocument);
  #endif
  
      /* Exit to shell? */
***************
*** 3263,3268 ****
--- 3420,3445 ----
      return selected_font;
  }
  
+ #ifdef USE_ATSUI_DRAWING
+     static void
+ gui_mac_create_atsui_style(void)
+ {
+     if (p_macatsui && gFontStyle == NULL)
+     {
+ 	if (ATSUCreateStyle(&gFontStyle) != noErr)
+ 	    gFontStyle = NULL;
+     }
+ #ifdef FEAT_MBYTE
+     if (p_macatsui && gWideFontStyle == NULL)
+     {
+ 	if (ATSUCreateStyle(&gWideFontStyle) != noErr)
+ 	    gWideFontStyle = NULL;
+     }
+ #endif
+ 
+     p_macatsui_last = p_macatsui;
+ }
+ #endif
  
  /*
   * Initialise vim to use the font with the given name.	Return FAIL if the font
***************
*** 3280,3290 ****
      char_u	used_font_name[512];
  
  #ifdef USE_ATSUI_DRAWING
!     if (p_macatsui && gFontStyle == NULL)
!     {
! 	if (ATSUCreateStyle(&gFontStyle) != noErr)
! 	    gFontStyle = NULL;
!     }
  #endif
  
      if (font_name == NULL)
--- 3457,3463 ----
      char_u	used_font_name[512];
  
  #ifdef USE_ATSUI_DRAWING
!     gui_mac_create_atsui_style();
  #endif
  
      if (font_name == NULL)
***************
*** 3348,3396 ****
      gui.char_height = font_info.ascent + font_info.descent + p_linespace;
  
  #ifdef USE_ATSUI_DRAWING
-     ATSUFontID			fontID;
-     Fixed			fontSize;
-     ATSStyleRenderingOptions	fontOptions;
- 
      if (p_macatsui && gFontStyle)
!     {
! 	fontID = font & 0xFFFF;
! 	fontSize = Long2Fix(font >> 16);
! 
! 	/* No antialiasing by default (do not attempt to touch antialising
! 	 * options on pre-Jaguar) */
! 	fontOptions =
! 	    (gMacSystemVersion >= 0x1020) ?
! 	    kATSStyleNoAntiAliasing :
! 	    kATSStyleNoOptions;
! 
! 	ATSUAttributeTag attribTags[] =
! 	{
! 	    kATSUFontTag, kATSUSizeTag, kATSUStyleRenderingOptionsTag,
! 	    kATSUMaxATSUITagValue+1
! 	};
! 	ByteCount attribSizes[] =
! 	{
! 	    sizeof(ATSUFontID), sizeof(Fixed),
! 	    sizeof(ATSStyleRenderingOptions), sizeof font
! 	};
! 	ATSUAttributeValuePtr attribValues[] =
! 	{
! 	    &fontID, &fontSize, &fontOptions, &font
! 	};
! 
! 	/* Convert font id to ATSUFontID */
! 	if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
! 	{
! 	    if (ATSUSetAttributes(gFontStyle,
! 			(sizeof attribTags)/sizeof(ATSUAttributeTag),
! 			attribTags, attribSizes, attribValues) != noErr)
! 	    {
! 		ATSUDisposeStyle(gFontStyle);
! 		gFontStyle = NULL;
! 	    }
! 	}
!     }
  #endif
  
      return OK;
--- 3521,3528 ----
      gui.char_height = font_info.ascent + font_info.descent + p_linespace;
  
  #ifdef USE_ATSUI_DRAWING
      if (p_macatsui && gFontStyle)
! 	gui_mac_set_font_attributes(font);
  #endif
  
      return OK;
***************
*** 3447,3452 ****
--- 3579,3646 ----
  }
  #endif
  
+ #ifdef USE_ATSUI_DRAWING
+     static void
+ gui_mac_set_font_attributes(GuiFont font)
+ {
+     ATSUFontID	fontID;
+     Fixed	fontSize;
+     Fixed	fontWidth;
+ 
+     fontID    = font & 0xFFFF;
+     fontSize  = Long2Fix(font >> 16);
+     fontWidth = Long2Fix(gui.char_width);
+ 
+     ATSUAttributeTag attribTags[] =
+     {
+ 	kATSUFontTag, kATSUSizeTag, kATSUImposeWidthTag,
+ 	kATSUMaxATSUITagValue + 1
+     };
+ 
+     ByteCount attribSizes[] =
+     {
+ 	sizeof(ATSUFontID), sizeof(Fixed), sizeof(fontWidth),
+ 	sizeof(font)
+     };
+ 
+     ATSUAttributeValuePtr attribValues[] =
+     {
+ 	&fontID, &fontSize, &fontWidth, &font
+     };
+ 
+     if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
+     {
+ 	if (ATSUSetAttributes(gFontStyle,
+ 		    (sizeof attribTags) / sizeof(ATSUAttributeTag),
+ 		    attribTags, attribSizes, attribValues) != noErr)
+ 	{
+ # ifndef NDEBUG
+ 	    fprintf(stderr, "couldn't set font style\n");
+ # endif
+ 	    ATSUDisposeStyle(gFontStyle);
+ 	    gFontStyle = NULL;
+ 	}
+ 
+ #ifdef FEAT_MBYTE
+ 	if (has_mbyte)
+ 	{
+ 	    /* FIXME: we should use a more mbyte sensitive way to support
+ 	     * wide font drawing */
+ 	    fontWidth = Long2Fix(gui.char_width * 2);
+ 
+ 	    if (ATSUSetAttributes(gWideFontStyle,
+ 			(sizeof attribTags) / sizeof(ATSUAttributeTag),
+ 			attribTags, attribSizes, attribValues) != noErr)
+ 	    {
+ 		ATSUDisposeStyle(gWideFontStyle);
+ 		gWideFontStyle = NULL;
+ 	    }
+ 	}
+ #endif
+     }
+ }
+ #endif
+ 
  /*
   * Set the current text font.
   */
***************
*** 3456,3518 ****
  #ifdef USE_ATSUI_DRAWING
      GuiFont			currFont;
      ByteCount			actualFontByteCount;
-     ATSUFontID			fontID;
-     Fixed			fontSize;
-     ATSStyleRenderingOptions	fontOptions;
  
      if (p_macatsui && gFontStyle)
      {
  	/* Avoid setting same font again */
! 	if (ATSUGetAttribute(gFontStyle, kATSUMaxATSUITagValue+1, sizeof font,
! 		    &currFont, &actualFontByteCount) == noErr &&
! 		actualFontByteCount == (sizeof font))
  	{
  	    if (currFont == font)
  		return;
  	}
  
! 	fontID = font & 0xFFFF;
! 	fontSize = Long2Fix(font >> 16);
! 	/* Respect p_antialias setting only for wide font.
! 	 * The reason for doing this at the moment is a bit complicated,
! 	 * but it's mainly because a) latin (non-wide) aliased fonts
! 	 * look bad in OS X 10.3.x and below (due to a bug in ATS), and
! 	 * b) wide multibyte input does not suffer from that problem. */
! 	/*fontOptions =
! 	    (p_antialias && (font == gui.wide_font)) ?
! 	    kATSStyleNoOptions : kATSStyleNoAntiAliasing;
! 	*/
! 	/*fontOptions = kATSStyleAntiAliasing;*/
! 
! 	ATSUAttributeTag attribTags[] =
! 	{
! 	    kATSUFontTag, kATSUSizeTag, kATSUStyleRenderingOptionsTag,
! 	    kATSUMaxATSUITagValue+1
! 	};
! 	ByteCount attribSizes[] =
! 	{
! 	    sizeof(ATSUFontID), sizeof(Fixed),
! 	    sizeof(ATSStyleRenderingOptions), sizeof font
! 	};
! 	ATSUAttributeValuePtr attribValues[] =
! 	{
! 	    &fontID, &fontSize, &fontOptions, &font
! 	};
! 
! 	if (FMGetFontFromFontFamilyInstance(fontID, 0, &fontID, NULL) == noErr)
! 	{
! 	    if (ATSUSetAttributes(gFontStyle,
! 			(sizeof attribTags)/sizeof(ATSUAttributeTag),
! 			attribTags, attribSizes, attribValues) != noErr)
! 	    {
! # ifndef NDEBUG
! 		fprintf(stderr, "couldn't set font style\n");
! # endif
! 		ATSUDisposeStyle(gFontStyle);
! 		gFontStyle = NULL;
! 	    }
! 	}
! 
      }
  
      if (p_macatsui && !gIsFontFallbackSet)
--- 3650,3668 ----
  #ifdef USE_ATSUI_DRAWING
      GuiFont			currFont;
      ByteCount			actualFontByteCount;
  
      if (p_macatsui && gFontStyle)
      {
  	/* Avoid setting same font again */
! 	if (ATSUGetAttribute(gFontStyle, kATSUMaxATSUITagValue + 1,
! 		    sizeof(font), &currFont, &actualFontByteCount) == noErr
! 		&& actualFontByteCount == (sizeof font))
  	{
  	    if (currFont == font)
  		return;
  	}
  
! 	gui_mac_set_font_attributes(font);
      }
  
      if (p_macatsui && !gIsFontFallbackSet)
***************
*** 3536,3542 ****
  			&fallbackFonts,
  			NULL) == noErr)
  	    {
! 		ATSUSetFontFallbacks((sizeof fallbackFonts)/sizeof(ATSUFontID), &fallbackFonts, kATSUSequentialFallbacksPreferred);
  	    }
  /*
  	ATSUAttributeValuePtr fallbackValues[] = { };
--- 3686,3694 ----
  			&fallbackFonts,
  			NULL) == noErr)
  	    {
! 		ATSUSetFontFallbacks((sizeof fallbackFonts)/sizeof(ATSUFontID),
! 				     &fallbackFonts,
! 				     kATSUSequentialFallbacksPreferred);
  	    }
  /*
  	ATSUAttributeValuePtr fallbackValues[] = { };
***************
*** 3921,3927 ****
  
      /* - ATSUI automatically antialiases text (Someone)
       * - for some reason it does not work... (Jussi) */
! 
      /*
       * When antialiasing we're using srcOr mode, we have to clear the block
       * before drawing the text.
--- 4073,4082 ----
  
      /* - ATSUI automatically antialiases text (Someone)
       * - for some reason it does not work... (Jussi) */
! #ifdef MAC_ATSUI_DEBUG
!     fprintf(stderr, "row = %d, col = %d, len = %d: '%c'\n",
! 	    row, col, len, len == 1 ? s[0] : ' ');
! #endif
      /*
       * When antialiasing we're using srcOr mode, we have to clear the block
       * before drawing the text.
***************
*** 3956,3990 ****
      }
  
      {
- 	/* Use old-style, non-antialiased QuickDraw text rendering. */
  	TextMode(srcCopy);
  	TextFace(normal);
  
!     /*  SelectFont(hdc, gui.currFont); */
! 
  	if (flags & DRAW_TRANSP)
  	{
  	    TextMode(srcOr);
  	}
  
  	MoveTo(TEXT_X(col), TEXT_Y(row));
- 	ATSUTextLayout textLayout;
  
! 	if (ATSUCreateTextLayoutWithTextPtr(tofree,
! 		    kATSUFromTextBeginning, kATSUToTextEnd,
! 		    utf16_len,
! 		    (gFontStyle ? 1 : 0), &utf16_len,
! 		    (gFontStyle ? &gFontStyle : NULL),
! 		    &textLayout) == noErr)
  	{
! 	    ATSUSetTransientFontMatching(textLayout, TRUE);
  
! 	    ATSUDrawText(textLayout,
! 		    kATSUFromTextBeginning, kATSUToTextEnd,
! 		    kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
  
  	    ATSUDisposeTextLayout(textLayout);
  	}
      }
  
      if (flags & DRAW_UNDERC)
--- 4111,4232 ----
      }
  
      {
  	TextMode(srcCopy);
  	TextFace(normal);
  
! 	/*  SelectFont(hdc, gui.currFont); */
  	if (flags & DRAW_TRANSP)
  	{
  	    TextMode(srcOr);
  	}
  
  	MoveTo(TEXT_X(col), TEXT_Y(row));
  
! 	if (gFontStyle && flags & DRAW_BOLD)
  	{
! 	    Boolean attValue = true;
! 	    ATSUAttributeTag attribTags[] = { kATSUQDBoldfaceTag };
! 	    ByteCount attribSizes[] = { sizeof(Boolean) };
! 	    ATSUAttributeValuePtr attribValues[] = { &attValue };
  
! 	    ATSUSetAttributes(gFontStyle, 1, attribTags, attribSizes, attribValues);
! 	}
! 
! #ifdef FEAT_MBYTE
! 	if (has_mbyte)
! 	{
! 	    int n, width_in_cell, last_width_in_cell;
! 	    UniCharArrayOffset offset = 0;
! 	    UniCharCount yet_to_draw = 0;
! 	    ATSUTextLayout textLayout;
! 	    ATSUStyle      textStyle;
! 
! 	    last_width_in_cell = 1;
! 	    ATSUCreateTextLayout(&textLayout);
! 	    ATSUSetTextPointerLocation(textLayout, tofree,
! 				       kATSUFromTextBeginning,
! 				       kATSUToTextEnd, utf16_len);
! 	    /*
! 	       ATSUSetRunStyle(textLayout, gFontStyle,
! 	       kATSUFromTextBeginning, kATSUToTextEnd); */
! 
! 	    /* Compute the length in display cells. */
! 	    for (n = 0; n < len; n += MB_BYTE2LEN(s[n]))
! 	    {
! 		width_in_cell = (*mb_ptr2cells)(s + n);
! 
! 		/* probably we are switching from single byte character
! 		 * to multibyte characters (which requires more than one
! 		 * cell to draw) */
! 		if (width_in_cell != last_width_in_cell)
! 		{
! #ifdef MAC_ATSUI_DEBUG
! 		    fprintf(stderr, "\tn = %2d, (%d-%d), offset = %d, yet_to_draw = %d\n",
! 			    n, last_width_in_cell, width_in_cell, offset, yet_to_draw);
! #endif
! 		    textStyle = last_width_in_cell > 1 ? gWideFontStyle
! 								 : gFontStyle;
! 
! 		    ATSUSetRunStyle(textLayout, textStyle, offset, yet_to_draw);
! 		    offset += yet_to_draw;
! 		    yet_to_draw = 0;
! 		    last_width_in_cell = width_in_cell;
! 		}
  
+ 		yet_to_draw++;
+ 	    }
+ 
+ 	    if (yet_to_draw)
+ 	    {
+ #ifdef MAC_ATSUI_DEBUG
+ 		fprintf(stderr, "\tn = %2d, (%d-%d), offset = %d, yet_to_draw = %d\n",
+ 			n, last_width_in_cell, width_in_cell, offset, yet_to_draw);
+ #endif
+ 		/* finish the rest style */
+ 		textStyle = width_in_cell > 1 ? gWideFontStyle : gFontStyle;
+ 		ATSUSetRunStyle(textLayout, textStyle, offset, kATSUToTextEnd);
+ 	    }
+ 
+ 	    ATSUSetTransientFontMatching(textLayout, TRUE);
+ 	    ATSUDrawText(textLayout,
+ 			 kATSUFromTextBeginning, kATSUToTextEnd,
+ 			 kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
  	    ATSUDisposeTextLayout(textLayout);
  	}
+ 	else
+ #endif
+ 	{
+ 	    ATSUTextLayout textLayout;
+ 
+ 	    if (ATSUCreateTextLayoutWithTextPtr(tofree,
+ 			kATSUFromTextBeginning, kATSUToTextEnd,
+ 			utf16_len,
+ 			(gFontStyle ? 1 : 0), &utf16_len,
+ 			(gFontStyle ? &gFontStyle : NULL),
+ 			&textLayout) == noErr)
+ 	    {
+ 		ATSUSetTransientFontMatching(textLayout, TRUE);
+ 
+ 		ATSUDrawText(textLayout,
+ 			kATSUFromTextBeginning, kATSUToTextEnd,
+ 			kATSUUseGrafPortPenLoc, kATSUUseGrafPortPenLoc);
+ 
+ 		ATSUDisposeTextLayout(textLayout);
+ 	    }
+ 	}
+ 
+ 	/* drawing is done, now reset bold to normal */
+ 	if (gFontStyle && flags & DRAW_BOLD)
+ 	{
+ 	    Boolean attValue = false;
+ 
+ 	    ATSUAttributeTag attribTags[] = { kATSUQDBoldfaceTag };
+ 	    ByteCount attribSizes[] = { sizeof(Boolean) };
+ 	    ATSUAttributeValuePtr attribValues[] = { &attValue };
+ 
+ 	    ATSUSetAttributes(gFontStyle, 1, attribTags, attribSizes,
+ 								attribValues);
+ 	}
      }
  
      if (flags & DRAW_UNDERC)
***************
*** 3998,4003 ****
--- 4240,4252 ----
  gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)
  {
  #if defined(USE_ATSUI_DRAWING)
+     if (p_macatsui == 0 && p_macatsui_last != 0)
+ 	/* switch from macatsui to nomacatsui */
+ 	gui_mac_dispose_atsui_style();
+     else if (p_macatsui != 0 && p_macatsui_last == 0)
+ 	/* switch from nomacatsui to macatsui */
+ 	gui_mac_create_atsui_style();
+ 
      if (p_macatsui)
  	draw_string_ATSUI(row, col, s, len, flags);
      else
***************
*** 4228,4239 ****
  	 */
  	/* TODO: reduce wtime accordinly???  */
  	if (wtime > -1)
! 	    sleeppyTick = 60*wtime/1000;
  	else
  	    sleeppyTick = 32767;
  	if (WaitNextEventWrp(mask, &event, sleeppyTick, dragRgn))
  	{
! 		gui_mac_handle_event(&event);
  	    if (input_available())
  	    {
  		allow_scrollbar = FALSE;
--- 4477,4489 ----
  	 */
  	/* TODO: reduce wtime accordinly???  */
  	if (wtime > -1)
! 	    sleeppyTick = 60 * wtime / 1000;
  	else
  	    sleeppyTick = 32767;
+ 
  	if (WaitNextEventWrp(mask, &event, sleeppyTick, dragRgn))
  	{
! 	    gui_mac_handle_event(&event);
  	    if (input_available())
  	    {
  		allow_scrollbar = FALSE;
***************
*** 6031,6037 ****
  #endif
  }
  
! #if defined(USE_IM_CONTROL) || defined(PROTO)
  /*
   * Input Method Control functions.
   */
--- 6346,6352 ----
  #endif
  }
  
! #if (defined(USE_IM_CONTROL) || defined(PROTO)) && defined(USE_CARBONKEYHANDLER)
  /*
   * Input Method Control functions.
   */
***************
*** 6042,6048 ****
--- 6357,6427 ----
      void
  im_set_position(int row, int col)
  {
+ #if 0
      /* TODO: Implement me! */
+     im_start_row = row;
+     im_start_col = col;
+ #endif
+ }
+ 
+ static ScriptLanguageRecord gTSLWindow;
+ static ScriptLanguageRecord gTSLInsert;
+ static ScriptLanguageRecord gTSLDefault = { 0, 0 };
+ 
+ static Component	     gTSCWindow;
+ static Component	     gTSCInsert;
+ static Component	     gTSCDefault;
+ 
+ static int		     im_initialized = 0;
+ 
+     static void
+ im_on_window_switch(int active)
+ {
+     ScriptLanguageRecord *slptr = NULL;
+     OSStatus err;
+ 
+     if (! gui.in_use)
+ 	return;
+ 
+     if (im_initialized == 0)
+     {
+ 	im_initialized = 1;
+ 
+ 	/* save default TSM component (should be U.S.) to default */
+ 	GetDefaultInputMethodOfClass(&gTSCDefault, &gTSLDefault,
+ 				     kKeyboardInputMethodClass);
+     }
+ 
+     if (active == TRUE)
+     {
+ 	im_is_active = TRUE;
+ 	ActivateTSMDocument(gTSMDocument);
+ 	slptr = &gTSLWindow;
+ 
+ 	if (slptr)
+ 	{
+ 	    err = SetDefaultInputMethodOfClass(gTSCWindow, slptr,
+ 					       kKeyboardInputMethodClass);
+ 	    if (err == noErr)
+ 		err = SetTextServiceLanguage(slptr);
+ 
+ 	    if (err == noErr)
+ 		KeyScript(slptr->fScript | smKeyForceKeyScriptMask);
+ 	}
+     }
+     else
+     {
+ 	err = GetTextServiceLanguage(&gTSLWindow);
+ 	if (err == noErr)
+ 	    slptr = &gTSLWindow;
+ 
+ 	if (slptr)
+ 	    GetDefaultInputMethodOfClass(&gTSCWindow, slptr,
+ 					 kKeyboardInputMethodClass);
+ 
+ 	im_is_active = FALSE;
+ 	DeactivateTSMDocument(gTSMDocument);
+     }
  }
  
  /*
***************
*** 6051,6057 ****
      void
  im_set_active(int active)
  {
!     KeyScript(active ? smKeySysScript : smKeyRoman);
  }
  
  /*
--- 6430,6486 ----
      void
  im_set_active(int active)
  {
!     ScriptLanguageRecord *slptr = NULL;
!     OSStatus err;
! 
!     if (! gui.in_use)
! 	return;
! 
!     if (im_initialized == 0)
!     {
! 	im_initialized = 1;
! 
! 	/* save default TSM component (should be U.S.) to default */
! 	GetDefaultInputMethodOfClass(&gTSCDefault, &gTSLDefault,
! 				     kKeyboardInputMethodClass);
!     }
! 
!     if (active == TRUE)
!     {
! 	im_is_active = TRUE;
! 	ActivateTSMDocument(gTSMDocument);
! 	slptr = &gTSLInsert;
! 
! 	if (slptr)
! 	{
! 	    err = SetDefaultInputMethodOfClass(gTSCInsert, slptr,
! 					       kKeyboardInputMethodClass);
! 	    if (err == noErr)
! 		err = SetTextServiceLanguage(slptr);
! 
! 	    if (err == noErr)
! 		KeyScript(slptr->fScript | smKeyForceKeyScriptMask);
! 	}
!     }
!     else
!     {
! 	err = GetTextServiceLanguage(&gTSLInsert);
! 	if (err == noErr)
! 	    slptr = &gTSLInsert;
! 
! 	if (slptr)
! 	    GetDefaultInputMethodOfClass(&gTSCInsert, slptr,
! 					 kKeyboardInputMethodClass);
! 
! 	/* restore to default when switch to normal mode, so than we could
! 	 * enter commands easier */
! 	SetDefaultInputMethodOfClass(gTSCDefault, &gTSLDefault,
! 				     kKeyboardInputMethodClass);
! 	SetTextServiceLanguage(&gTSLDefault);
! 
! 	im_is_active = FALSE;
! 	DeactivateTSMDocument(gTSMDocument);
!     }
  }
  
  /*
***************
*** 6060,6068 ****
      int
  im_get_status(void)
  {
!     SInt32 script = GetScriptManagerVariable(smKeyScript);
!     return (script != smRoman
! 	    && script == GetScriptManagerVariable(smSysScript)) ? 1 : 0;
  }
  
  #endif /* defined(USE_IM_CONTROL) || defined(PROTO) */
--- 6489,6498 ----
      int
  im_get_status(void)
  {
!     if (! gui.in_use)
! 	return 0;
! 
!     return im_is_active;
  }
  
  #endif /* defined(USE_IM_CONTROL) || defined(PROTO) */
***************
*** 6118,6124 ****
      int		numTabs = 0;
  
      for (tp = first_tabpage; tp != NULL; tp = tp->tp_next)
!         ++numTabs;
      return numTabs;
  }
  
--- 6548,6554 ----
      int		numTabs = 0;
  
      for (tp = first_tabpage; tp != NULL; tp = tp->tp_next)
! 	++numTabs;
      return numTabs;
  }
  
***************
*** 6126,6133 ****
      static OSStatus
  dbItemDataCallback(ControlRef browser,
  	DataBrowserItemID itemID,
!         DataBrowserPropertyID property /* column id */,
!         DataBrowserItemDataRef itemData,
  	Boolean changeValue)
  {
      OSStatus status = noErr;
--- 6556,6563 ----
      static OSStatus
  dbItemDataCallback(ControlRef browser,
  	DataBrowserItemID itemID,
! 	DataBrowserPropertyID property /* column id */,
! 	DataBrowserItemDataRef itemData,
  	Boolean changeValue)
  {
      OSStatus status = noErr;
***************
*** 6170,6178 ****
      static void
  dbGetContextualMenuCallback(ControlRef browser,
  	MenuRef *menu,
!         UInt32 *helpType,
  	CFStringRef *helpItemString,
!         AEDesc *selection)
  {
      // on mac os 9: kCMHelpItemNoHelp, but it's not the same
      *helpType = kCMHelpItemRemoveHelp; // OS X only ;-)
--- 6600,6608 ----
      static void
  dbGetContextualMenuCallback(ControlRef browser,
  	MenuRef *menu,
! 	UInt32 *helpType,
  	CFStringRef *helpItemString,
! 	AEDesc *selection)
  {
      // on mac os 9: kCMHelpItemNoHelp, but it's not the same
      *helpType = kCMHelpItemRemoveHelp; // OS X only ;-)
***************
*** 6395,6403 ****
  gui_mch_show_tabline(int showit)
  {
      if (showit == 0)
!         CloseDrawer(drawer, true);
      else
!         OpenDrawer(drawer, kWindowEdgeRight, true);
  }
  
  /*
--- 6825,6833 ----
  gui_mch_show_tabline(int showit)
  {
      if (showit == 0)
! 	CloseDrawer(drawer, true);
      else
! 	OpenDrawer(drawer, kWindowEdgeRight, true);
  }
  
  /*
***************
*** 6425,6435 ****
      // adjust data browser
      if (tabLabels != NULL)
      {
!         int i;
  
!         for (i = 0; i < tabLabelsSize; ++i)
!             CFRelease(tabLabels[i]);
!         free(tabLabels);
      }
      tabLabels = (CFStringRef *)malloc(numTabs * sizeof(CFStringRef));
      tabLabelsSize = numTabs;
--- 6855,6865 ----
      // adjust data browser
      if (tabLabels != NULL)
      {
! 	int i;
  
! 	for (i = 0; i < tabLabelsSize; ++i)
! 	    CFRelease(tabLabels[i]);
! 	free(tabLabels);
      }
      tabLabels = (CFStringRef *)malloc(numTabs * sizeof(CFStringRef));
      tabLabelsSize = numTabs;
***************
*** 6438,6444 ****
      {
  	if (tp == curtab)
  	    curtabidx = nr;
!         tabLabels[nr-1] = getTabLabel(tp);
      }
  
      RemoveDataBrowserItems(dataBrowser, kDataBrowserNoItem, 0, NULL,
--- 6868,6874 ----
      {
  	if (tp == curtab)
  	    curtabidx = nr;
! 	tabLabels[nr-1] = getTabLabel(tp);
      }
  
      RemoveDataBrowserItems(dataBrowser, kDataBrowserNoItem, 0, NULL,
*** ../vim-7.1.274/src/version.c	Wed Mar 12 13:45:34 2008
--- src/version.c	Wed Mar 12 14:31:37 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     275,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
115. You are late picking up your kid from school and try to explain
     to the teacher you were stuck in Web traffic.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.276
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.276
Problem:    "gw" uses 'formatexpr', even though the docs say it doesn't.
Solution:   Don't use 'formatexpr' for "gw".
Files:	    src/vim.h, src/edit.c, src/ops.c, src/proto/ops.pro


*** ../vim-7.1.275/src/vim.h	Wed Mar 12 14:38:51 2008
--- src/vim.h	Wed Mar 12 16:31:44 2008
***************
*** 949,954 ****
--- 952,958 ----
  #define INSCHAR_FORMAT	1	/* force formatting */
  #define INSCHAR_DO_COM	2	/* format comments */
  #define INSCHAR_CTRLV	4	/* char typed just after CTRL-V */
+ #define INSCHAR_NO_FEX	8	/* don't use 'formatexpr' */
  
  /* flags for open_line() */
  #define OPENLINE_DELSPACES  1	/* delete spaces after cursor */
*** ../vim-7.1.275/src/edit.c	Tue Jan 22 17:49:17 2008
--- src/edit.c	Wed Mar 12 16:35:44 2008
***************
*** 5491,5497 ****
  #if defined(FEAT_EVAL)
  	int do_internal = TRUE;
  
! 	if (*curbuf->b_p_fex != NUL)
  	{
  	    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);
  	    /* It may be required to save for undo again, e.g. when setline()
--- 5491,5497 ----
  #if defined(FEAT_EVAL)
  	int do_internal = TRUE;
  
! 	if (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0)
  	{
  	    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);
  	    /* It may be required to save for undo again, e.g. when setline()
***************
*** 6057,6063 ****
       * be adjusted for the text formatting.
       */
      saved_cursor = pos;
!     format_lines((linenr_T)-1);
      curwin->w_cursor = saved_cursor;
      saved_cursor.lnum = 0;
  
--- 6057,6063 ----
       * be adjusted for the text formatting.
       */
      saved_cursor = pos;
!     format_lines((linenr_T)-1, FALSE);
      curwin->w_cursor = saved_cursor;
      saved_cursor.lnum = 0;
  
*** ../vim-7.1.275/src/ops.c	Mon Feb 25 21:54:23 2008
--- src/ops.c	Wed Mar 12 16:37:29 2008
***************
*** 4380,4386 ****
      if (keep_cursor)
  	saved_cursor = oap->cursor_start;
  
!     format_lines(oap->line_count);
  
      /*
       * Leave the cursor at the first non-blank of the last formatted line.
--- 4380,4386 ----
      if (keep_cursor)
  	saved_cursor = oap->cursor_start;
  
!     format_lines(oap->line_count, keep_cursor);
  
      /*
       * Leave the cursor at the first non-blank of the last formatted line.
***************
*** 4495,4502 ****
   * first line.
   */
      void
! format_lines(line_count)
      linenr_T	line_count;
  {
      int		max_len;
      int		is_not_par;		/* current line not part of parag. */
--- 4495,4503 ----
   * first line.
   */
      void
! format_lines(line_count, avoid_fex)
      linenr_T	line_count;
+     int		avoid_fex;		/* don't use 'formatexpr' */
  {
      int		max_len;
      int		is_not_par;		/* current line not part of parag. */
***************
*** 4666,4672 ****
  #ifdef FEAT_COMMENTS
  			+ (do_comments ? INSCHAR_DO_COM : 0)
  #endif
! 			, second_indent);
  		State = old_State;
  		p_smd = smd_save;
  		second_indent = -1;
--- 4667,4673 ----
  #ifdef FEAT_COMMENTS
  			+ (do_comments ? INSCHAR_DO_COM : 0)
  #endif
! 			+ (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);
  		State = old_State;
  		p_smd = smd_save;
  		second_indent = -1;
*** ../vim-7.1.275/src/proto/ops.pro	Wed Jan 16 20:01:14 2008
--- src/proto/ops.pro	Wed Mar 12 16:38:39 2008
***************
*** 41,47 ****
  void op_format __ARGS((oparg_T *oap, int keep_cursor));
  void op_formatexpr __ARGS((oparg_T *oap));
  int fex_format __ARGS((linenr_T lnum, long count, int c));
! void format_lines __ARGS((linenr_T line_count));
  int paragraph_start __ARGS((linenr_T lnum));
  int do_addsub __ARGS((int command, linenr_T Prenum1));
  int read_viminfo_register __ARGS((vir_T *virp, int force));
--- 41,47 ----
  void op_format __ARGS((oparg_T *oap, int keep_cursor));
  void op_formatexpr __ARGS((oparg_T *oap));
  int fex_format __ARGS((linenr_T lnum, long count, int c));
! void format_lines __ARGS((linenr_T line_count, int avoid_fex));
  int paragraph_start __ARGS((linenr_T lnum));
  int do_addsub __ARGS((int command, linenr_T Prenum1));
  int read_viminfo_register __ARGS((vir_T *virp, int force));
*** ../vim-7.1.275/src/version.c	Wed Mar 12 14:38:51 2008
--- src/version.c	Wed Mar 12 17:23:43 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     276,
  /**/

-- 
An actual excerpt from a classified section of a city newspaper:
"Illiterate?  Write today for free help!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.277
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.277
Problem:    Default for 'paragraphs' misses some items (Colin Watson)
Solution:   Add TP, HP, Pp, Lp and It to 'paragraphs'. (James Vega)
Files:	    runtime/doc/options.txt, src/option.c


*** ../vim-7.1.276/runtime/doc/options.txt	Sat Jan 19 15:55:51 2008
--- runtime/doc/options.txt	Wed Mar 12 17:34:32 2008
***************
*** 1,4 ****
! *options.txt*	For Vim version 7.1.  Last change: 2007 Aug 10
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *options.txt*	For Vim version 7.1.  Last change: 2008 Feb 24
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 4878,4884 ****
  	|autocmd-osfiletypes|
  
  						*'paragraphs'* *'para'*
! 'paragraphs' 'para'	string	(default "IPLPPPQPP LIpplpipbp")
  			global
  	Specifies the nroff macros that separate paragraphs.  These are pairs
  	of two letters (see |object-motions|).
--- 4901,4907 ----
  	|autocmd-osfiletypes|
  
  						*'paragraphs'* *'para'*
! 'paragraphs' 'para'	string	(default "IPLPPPQPP TPHPLIPpLpItpplpipbp")
  			global
  	Specifies the nroff macros that separate paragraphs.  These are pairs
  	of two letters (see |object-motions|).
*** ../vim-7.1.276/src/option.c	Wed Feb 13 18:35:23 2008
--- src/option.c	Wed Mar 12 17:34:32 2008
***************
*** 1839,1845 ****
  			    },
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
! 			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
      {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
--- 1839,1846 ----
  			    },
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
! 			    {(char_u *)"IPLPPPQPP TPHPLIPpLpItpplpipbp",
! 				(char_u *)0L}},
      {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
*** ../vim-7.1.276/src/version.c	Wed Mar 12 17:25:50 2008
--- src/version.c	Wed Mar 12 17:35:14 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     277,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
119. You are reading a book and look for the scroll bar to get to
     the next page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.278
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.278 (extra, after 7.1.275)
Problem:    Build failure when USE_CARBONKEYHANDLER is not defined.
Solution:   Remove #ifdef.
Files:	    src/gui_mac.c


*** ../vim-7.1.277/src/gui_mac.c	Wed Mar 12 14:38:51 2008
--- src/gui_mac.c	Wed Mar 12 21:40:54 2008
***************
*** 3037,3049 ****
  gui_mch_init(void)
  {
      /* TODO: Move most of this stuff toward gui_mch_init */
!     Rect	windRect;
!     MenuHandle	pomme;
      EventHandlerRef mouseWheelHandlerRef;
- #ifdef USE_CARBONKEYHANDLER
      EventTypeSpec   eventTypeSpec;
! #endif
!     ControlRef rootControl;
  
      if (Gestalt(gestaltSystemVersion, &gMacSystemVersion) != noErr)
  	gMacSystemVersion = 0x1000; /* TODO: Default to minimum sensible value */
--- 3040,3050 ----
  gui_mch_init(void)
  {
      /* TODO: Move most of this stuff toward gui_mch_init */
!     Rect	    windRect;
!     MenuHandle	    pomme;
      EventHandlerRef mouseWheelHandlerRef;
      EventTypeSpec   eventTypeSpec;
!     ControlRef	    rootControl;
  
      if (Gestalt(gestaltSystemVersion, &gMacSystemVersion) != noErr)
  	gMacSystemVersion = 0x1000; /* TODO: Default to minimum sensible value */
*** ../vim-7.1.277/src/version.c	Wed Mar 12 17:37:53 2008
--- src/version.c	Wed Mar 12 21:43:22 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     278,
  /**/

-- 
Would you care for a drink?   I mean, if it were, like,
disabled and you had to look after it?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.279
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.279
Problem:    When using cscope temporary files are left behind.
Solution:   Send the quit command to cscope and give it two seconds to exit
	    nicely before killing it. (partly by Dominique Pelle)
Files:	    src/if_cscope.c


*** ../vim-7.1.278/src/if_cscope.c	Fri Sep 14 19:56:18 2007
--- src/if_cscope.c	Sat Mar 15 12:38:12 2008
***************
*** 2096,2101 ****
--- 2096,2113 ----
      return CSCOPE_SUCCESS;
  }
  
+ #if defined(UNIX) && defined(SIGALRM)
+ /*
+  * Used to catch and ignore SIGALRM below.
+  */
+ /* ARGSUSED */
+     static RETSIGTYPE
+ sig_handler SIGDEFARG(sigarg)
+ {
+     /* do nothing */
+     SIGRETURN;
+ }
+ #endif
  
  /*
   * PRIVATE: cs_release_csp
***************
*** 2108,2116 ****
      int i;
      int freefnpp;
  {
- #if defined(UNIX)
-     int pstat;
- #else
      /*
       * Trying to exit normally (not sure whether it is fit to UNIX cscope
       */
--- 2120,2125 ----
***************
*** 2119,2124 ****
--- 2128,2179 ----
  	(void)fputs("q\n", csinfo[i].to_fp);
  	(void)fflush(csinfo[i].to_fp);
      }
+ #if defined(UNIX)
+     {
+ 	int pstat;
+ 	pid_t pid;
+ 
+ # if defined(HAVE_SIGACTION)
+ 	struct sigaction sa, old;
+ 
+         /* Use sigaction() to limit the waiting time to two seconds. */
+ 	sa.sa_handler = sig_handler;
+ 	sa.sa_flags = SA_NODEFER;
+ 	sigaction(SIGALRM, &sa, &old);
+ 	alarm(2); /* 2 sec timeout */
+ 
+ 	/* Block until cscope exits or until timer expires */
+ 	pid = waitpid(csinfo[i].pid, &pstat, 0);
+ 
+ 	/* cancel pending alarm if still there and restore signal */
+ 	alarm(0);
+ 	sigaction(SIGALRM, &old, NULL);
+ # else
+ 	int waited;
+ 
+ 	/* Can't use sigaction(), loop for two seconds.  First yield the CPU
+ 	 * to give cscope a chance to exit quickly. */
+ 	sleep(0);
+ 	for (waited = 0; waited < 40; ++waited)
+ 	{
+ 	    pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);
+ 	    if (pid != 0)
+ 		break;  /* break unless the process is still running */
+ 	    mch_delay(50, FALSE); /* sleep 50 ms */
+ 	}
+ # endif
+ 	/*
+ 	 * If the cscope process is still running: kill it.
+ 	 * Safety check: If the PID would be zero here, the entire X session
+ 	 * would be killed.  -1 and 1 are dangerous as well.
+ 	 */
+ 	if (pid < 0 && csinfo[i].pid > 1)
+ 	{
+ 	    kill(csinfo[i].pid, SIGTERM);
+ 	    (void)waitpid(csinfo[i].pid, &pstat, 0);
+ 	}
+     }
+ #else  /* !UNIX */
      if (csinfo[i].hProc != NULL)
      {
  	/* Give cscope a chance to exit normally */
***************
*** 2133,2150 ****
      if (csinfo[i].to_fp != NULL)
  	(void)fclose(csinfo[i].to_fp);
  
-     /*
-      * Safety check: If the PID would be zero here, the entire X session would
-      * be killed.  -1 and 1 are dangerous as well.
-      */
- #if defined(UNIX)
-     if (csinfo[i].pid > 1)
-     {
- 	kill(csinfo[i].pid, SIGTERM);
- 	(void)waitpid(csinfo[i].pid, &pstat, 0);
-     }
- #endif
- 
      if (freefnpp)
      {
  	vim_free(csinfo[i].fname);
--- 2188,2193 ----
*** ../vim-7.1.278/src/version.c	Wed Mar 12 21:47:31 2008
--- src/version.c	Sat Mar 15 12:38:58 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     279,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
130. You can't get out of your desk even if it's time to eat or time
     to go to the bathroom.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.280
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.280  (after 7.1.275)
Problem:    Mac: build problems when not using multibyte feature. (Nicholas
	    Stallard)
Solution:   Don't define USE_IM_CONTROL when not using multibyte.
Files:	    src/vim.h


*** ../vim-7.1.279/src/vim.h	Wed Mar 12 17:25:50 2008
--- src/vim.h	Thu Mar 13 23:39:21 2008
***************
*** 463,469 ****
   */
  #if defined(FEAT_XIM) \
      || (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) \
!     || defined(FEAT_GUI_MAC)
  # define USE_IM_CONTROL
  #endif
  
--- 466,472 ----
   */
  #if defined(FEAT_XIM) \
      || (defined(FEAT_GUI) && (defined(FEAT_MBYTE_IME) || defined(GLOBAL_IME))) \
!     || (defined(FEAT_GUI_MAC) && defined(FEAT_MBYTE))
  # define USE_IM_CONTROL
  #endif
  
*** ../vim-7.1.279/src/version.c	Sat Mar 15 12:40:23 2008
--- src/version.c	Sat Mar 15 13:08:40 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     280,
  /**/

-- 
Why is it called "Windows"?  "Gates" would be more appropriate...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.281
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.281 (after 7.1.279)
Problem:    sa.sa_mask is not initialized.  Cscope may not exit.
Solution:   Use sigemptyset().  Use SIGKILL instead of SIGTERM. (Dominique
	    Pelle)
Files:	    src/if_cscope.c


*** ../vim-7.1.280/src/if_cscope.c	Sat Mar 15 12:40:23 2008
--- src/if_cscope.c	Sun Mar 16 13:05:51 2008
***************
*** 2136,2142 ****
  # if defined(HAVE_SIGACTION)
  	struct sigaction sa, old;
  
!         /* Use sigaction() to limit the waiting time to two seconds. */
  	sa.sa_handler = sig_handler;
  	sa.sa_flags = SA_NODEFER;
  	sigaction(SIGALRM, &sa, &old);
--- 2136,2143 ----
  # if defined(HAVE_SIGACTION)
  	struct sigaction sa, old;
  
! 	/* Use sigaction() to limit the waiting time to two seconds. */
! 	sigemptyset(&sa.sa_mask);
  	sa.sa_handler = sig_handler;
  	sa.sa_flags = SA_NODEFER;
  	sigaction(SIGALRM, &sa, &old);
***************
*** 2169,2175 ****
  	 */
  	if (pid < 0 && csinfo[i].pid > 1)
  	{
! 	    kill(csinfo[i].pid, SIGTERM);
  	    (void)waitpid(csinfo[i].pid, &pstat, 0);
  	}
      }
--- 2170,2176 ----
  	 */
  	if (pid < 0 && csinfo[i].pid > 1)
  	{
! 	    kill(csinfo[i].pid, SIGKILL);
  	    (void)waitpid(csinfo[i].pid, &pstat, 0);
  	}
      }
*** ../vim-7.1.280/src/version.c	Sat Mar 15 13:10:57 2008
--- src/version.c	Sun Mar 16 13:08:08 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     281,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
136. You decide to stay in a low-paying job teaching just for the
     free Internet access.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.282 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.282 (extra)
Problem:    Win64: Edit with Vim context menu isn't installed correctly.
	    Compiler warnings and a few other things.
Solution:   Add [ and ] to entry of class name.  Use UINT_PTR instead of UINT.
	    And a fixes for the other things. (George V.  Reilly)
Files:	    src/GvimExt/Makefile, src/dosinst.c, src/if_ole.cpp, src/if_ole.h,
	    src/if_ole.idl, src/INSTALLpc.txt,  src/Make_mvc.mak,
	    src/os_win32.c,


*** ../vim-7.1.281/src/GvimExt/Makefile	Sat May  5 12:51:46 2007
--- src/GvimExt/Makefile	Tue Jul 10 16:18:18 2007
***************
*** 24,30 ****
  gvimext.obj: gvimext.h
  
  .cpp.obj:
!     $(cc) $(cflags) -DFEAT_GETTEXT $(cvarsdll) $*.cpp
  
  gvimext.res: gvimext.rc
      $(rc) $(rcflags) $(rcvars)  gvimext.rc
--- 24,30 ----
  gvimext.obj: gvimext.h
  
  .cpp.obj:
!     $(cc) $(cflags) -DFEAT_GETTEXT $(cvarsmt) $*.cpp
  
  gvimext.res: gvimext.rc
      $(rc) $(rcflags) $(rcvars)  gvimext.rc
*** ../vim-7.1.281/src/dosinst.c	Thu May 10 20:54:39 2007
--- src/dosinst.c	Tue Jul 10 16:07:16 2007
***************
*** 1365,1371 ****
  
  	    printf("Creating \"Edit with Vim\" popup menu entry\n");
  
! 	    fprintf(fd, "HKEY_CLASSES_ROOT\\CLSID\\%s\n", vim_ext_clsid);
  	    fprintf(fd, "@=\"%s\"\n", vim_ext_name);
  	    fprintf(fd, "[HKEY_CLASSES_ROOT\\CLSID\\%s\\InProcServer32]\n",
  							       vim_ext_clsid);
--- 1365,1371 ----
  
  	    printf("Creating \"Edit with Vim\" popup menu entry\n");
  
! 	    fprintf(fd, "[HKEY_CLASSES_ROOT\\CLSID\\%s]\n", vim_ext_clsid);
  	    fprintf(fd, "@=\"%s\"\n", vim_ext_name);
  	    fprintf(fd, "[HKEY_CLASSES_ROOT\\CLSID\\%s\\InProcServer32]\n",
  							       vim_ext_clsid);
*** ../vim-7.1.281/src/if_ole.cpp	Wed Aug 16 17:34:09 2006
--- src/if_ole.cpp	Tue Sep 25 16:44:44 2007
***************
*** 34,39 ****
--- 34,45 ----
  extern HWND vim_parent_hwnd;
  }
  
+ #if _MSC_VER < 1300
+ /* Work around old versions of basetsd.h which wrongly declares
+  * UINT_PTR as unsigned long */
+ # define UINT_PTR UINT
+ #endif
+ 
  #include "if_ole.h"	// Interface definitions
  #include "iid_ole.c"	// UUID definitions (compile here)
  
***************
*** 107,113 ****
      STDMETHOD(SendKeys)(BSTR keys);
      STDMETHOD(Eval)(BSTR expr, BSTR *result);
      STDMETHOD(SetForeground)(void);
!     STDMETHOD(GetHwnd)(UINT *result);
  
  private:
      // Constructor is private - create using CVim::Create()
--- 113,119 ----
      STDMETHOD(SendKeys)(BSTR keys);
      STDMETHOD(Eval)(BSTR expr, BSTR *result);
      STDMETHOD(SetForeground)(void);
!     STDMETHOD(GetHwnd)(UINT_PTR *result);
  
  private:
      // Constructor is private - create using CVim::Create()
***************
*** 288,296 ****
  }
  
  STDMETHODIMP
! CVim::GetHwnd(UINT *result)
  {
!     *result = (UINT) s_hwnd;
      return S_OK;
  }
  
--- 294,302 ----
  }
  
  STDMETHODIMP
! CVim::GetHwnd(UINT_PTR *result)
  {
!     *result = (UINT_PTR)s_hwnd;
      return S_OK;
  }
  
*** ../vim-7.1.281/src/if_ole.h	Sun Jun 13 17:46:29 2004
--- src/if_ole.h	Tue Jul 10 16:21:18 2007
***************
*** 79,85 ****
  	virtual HRESULT STDMETHODCALLTYPE SetForeground( void) = 0;
  
  	virtual HRESULT STDMETHODCALLTYPE GetHwnd(
! 	    /* [retval][out] */ UINT __RPC_FAR *result) = 0;
  
      };
  
--- 79,85 ----
  	virtual HRESULT STDMETHODCALLTYPE SetForeground( void) = 0;
  
  	virtual HRESULT STDMETHODCALLTYPE GetHwnd(
! 	    /* [retval][out] */ UINT_PTR __RPC_FAR *result) = 0;
  
      };
  
***************
*** 143,149 ****
  
  	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHwnd )(
  	    IVim __RPC_FAR * This,
! 	    /* [retval][out] */ UINT __RPC_FAR *result);
  
  	END_INTERFACE
      } IVimVtbl;
--- 143,149 ----
  
  	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHwnd )(
  	    IVim __RPC_FAR * This,
! 	    /* [retval][out] */ UINT_PTR __RPC_FAR *result);
  
  	END_INTERFACE
      } IVimVtbl;
***************
*** 236,242 ****
  
  HRESULT STDMETHODCALLTYPE IVim_GetHwnd_Proxy(
      IVim __RPC_FAR * This,
!     /* [retval][out] */ UINT __RPC_FAR *result);
  
  
  void __RPC_STUB IVim_GetHwnd_Stub(
--- 236,242 ----
  
  HRESULT STDMETHODCALLTYPE IVim_GetHwnd_Proxy(
      IVim __RPC_FAR * This,
!     /* [retval][out] */ UINT_PTR __RPC_FAR *result);
  
  
  void __RPC_STUB IVim_GetHwnd_Stub(
*** ../vim-7.1.281/src/if_ole.idl	Sun Jun 13 17:22:03 2004
--- src/if_ole.idl	Tue Jul 10 16:21:45 2007
***************
*** 20,26 ****
  	HRESULT SendKeys([in]BSTR keys);
  	HRESULT Eval([in]BSTR expr, [out, retval]BSTR* result);
  	HRESULT SetForeground(void);
! 	HRESULT GetHwnd([out, retval]UINT* result);
  };
  
  // Component and type library definitions
--- 20,26 ----
  	HRESULT SendKeys([in]BSTR keys);
  	HRESULT Eval([in]BSTR expr, [out, retval]BSTR* result);
  	HRESULT SetForeground(void);
! 	HRESULT GetHwnd([out, retval]UINT_PTR* result);
  };
  
  // Component and type library definitions
*** ../vim-7.1.281/src/INSTALLpc.txt	Sun Apr 30 20:29:26 2006
--- src/INSTALLpc.txt	Wed Mar 12 15:01:37 2008
***************
*** 82,90 ****
  |ms-platform-sdk|, |dotnet-1.1-redist|, |dotnet-1.1-sdk|,
  and |windbg-download|.
  
! It's easier to download Visual C++ 2005 Express Edition, |msvc-2005-express|.
! The advantage of the VC 2003 Toolkit is that it will be freely available
! long after VC 2005 Express Edition stops being free in November 2006.
  
  The free Code::Blocks IDE works with the VC2003 Toolkit, as described at
      http://wiki.codeblocks.org/index.php?title=Integrating_Microsoft_Visual_Toolkit_2003_with_Code::Blocks_IDE
--- 82,89 ----
  |ms-platform-sdk|, |dotnet-1.1-redist|, |dotnet-1.1-sdk|,
  and |windbg-download|.
  
! It's easier to download Visual C++ 2008 Express Edition, |msvc-2008-express|,
! which is freely available in perpetuity.
  
  The free Code::Blocks IDE works with the VC2003 Toolkit, as described at
      http://wiki.codeblocks.org/index.php?title=Integrating_Microsoft_Visual_Toolkit_2003_with_Code::Blocks_IDE
***************
*** 152,157 ****
--- 151,164 ----
      http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/default.aspx
  
  
+ Visual C++ 2008 Express Edition       *msvc-2008-express*
+ -------------------------------
+ 
+ Visual C++ 2008 Express Edition can be downloaded for free from:
+     http://msdn2.microsoft.com/en-us/express/default.aspx
+ This includes the IDE and the debugger. You can build Vim with Make_mvc.mak.
+ 
+ 
  2. MinGW
  ========
  
*** ../vim-7.1.281/src/Make_mvc.mak	Wed Oct  3 13:28:40 2007
--- src/Make_mvc.mak	Wed Mar 12 15:09:55 2008
***************
*** 1,6 ****
  # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
  # and Win64, using the Microsoft Visual C++ compilers. Known to work with
! # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), and VC8 (VS2005).
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
--- 1,7 ----
  # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
  # and Win64, using the Microsoft Visual C++ compilers. Known to work with
! # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # and VC9 (VS2008).
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
***************
*** 285,291 ****
  # need shell32.lib for ExtractIcon()
  # gdi32.lib and comdlg32.lib for printing support
  # ole32.lib and uuid.lib are needed for FEAT_SHORTCUT
! CON_LIB = advapi32.lib shell32.lib gdi32.lib comdlg32.lib ole32.lib uuid.lib
  !if "$(DELAYLOAD)" == "yes"
  CON_LIB = $(CON_LIB) /DELAYLOAD:comdlg32.dll /DELAYLOAD:ole32.dll DelayImp.lib
  !endif
--- 286,293 ----
  # need shell32.lib for ExtractIcon()
  # gdi32.lib and comdlg32.lib for printing support
  # ole32.lib and uuid.lib are needed for FEAT_SHORTCUT
! CON_LIB = oldnames.lib kernel32.lib advapi32.lib shell32.lib gdi32.lib \
!           comdlg32.lib ole32.lib uuid.lib /machine:$(CPU) /nodefaultlib
  !if "$(DELAYLOAD)" == "yes"
  CON_LIB = $(CON_LIB) /DELAYLOAD:comdlg32.dll /DELAYLOAD:ole32.dll DelayImp.lib
  !endif
***************
*** 331,336 ****
--- 333,339 ----
  !endif
  !if "$(_NMAKE_VER)" == "6.00.8168.0"
  MSVCVER = 6.0
+ CPU = ix86
  !endif
  !if "$(_NMAKE_VER)" == "7.00.9466"
  MSVCVER = 7.0
***************
*** 344,349 ****
--- 347,355 ----
  !if "$(_NMAKE_VER)" == "8.00.50727.762"
  MSVCVER = 8.0
  !endif
+ !if "$(_NMAKE_VER)" == "9.00.20706.01"
+ MSVCVER = 9.0
+ !endif
  !endif
  
  # Abort bulding VIM if version of VC is unrecognised.
***************
*** 352,364 ****
  !message Cannot determine Visual C version being used.  If you are using the
  !message Windows SDK then you must have the environment variable MSVCVER set to
  !message your version of the VC compiler.  If you are not using the Express
! !message version of Visual C you van either set MSVCVER or update this makefile
! !message to handle the new value for _NMAKE_VER.
  !error Make aborted.
  !endif
  
  # Convert processor ID to MVC-compatible number
! !if "$(MSVCVER)" != "8.0"
  !if "$(CPUNR)" == "i386"
  CPUARG = /G3
  !elseif "$(CPUNR)" == "i486"
--- 358,370 ----
  !message Cannot determine Visual C version being used.  If you are using the
  !message Windows SDK then you must have the environment variable MSVCVER set to
  !message your version of the VC compiler.  If you are not using the Express
! !message version of Visual C, you can either set MSVCVER or update this makefile
! !message to handle the new value for _NMAKE_VER, "$(_NMAKE_VER)".
  !error Make aborted.
  !endif
  
  # Convert processor ID to MVC-compatible number
! !if ("$(MSVCVER)" != "8.0") && ("$(MSVCVER)" != "9.0")
  !if "$(CPUNR)" == "i386"
  CPUARG = /G3
  !elseif "$(CPUNR)" == "i486"
***************
*** 373,379 ****
  CPUARG =
  !endif
  !else
! # VC8 only allows specifying SSE architecture
  !if "$(CPUNR)" == "pentium4"
  CPUARG = /arch:SSE2
  !endif
--- 379,385 ----
  CPUARG =
  !endif
  !else
! # VC8/9 only allows specifying SSE architecture
  !if "$(CPUNR)" == "pentium4"
  CPUARG = /arch:SSE2
  !endif
***************
*** 391,397 ****
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
! !if "$(MSVCVER)" == "8.0"
  # Use link time code generation if not worried about size
  !if "$(OPTIMIZE)" != "SPACE"
  OPTFLAG = $(OPTFLAG) /GL
--- 397,403 ----
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
  # Use link time code generation if not worried about size
  !if "$(OPTIMIZE)" != "SPACE"
  OPTFLAG = $(OPTFLAG) /GL
***************
*** 404,414 ****
  LIBC = msvcrt.lib
  ! else
  LIBC = libcmt.lib
! CFLAGS = $(CFLAGS) /MT
  ! endif
  !else  # DEBUG
  VIM = vimd
! ! if "$(CPU)" == "i386"
  DEBUGINFO = /ZI
  ! endif
  CFLAGS = $(CFLAGS) -D_DEBUG -DDEBUG /Od
--- 410,420 ----
  LIBC = msvcrt.lib
  ! else
  LIBC = libcmt.lib
! CFLAGS = $(CFLAGS) /Zl /MT
  ! endif
  !else  # DEBUG
  VIM = vimd
! ! if ("$(CPU)" == "i386") || ("$(CPU)" == "ix86")
  DEBUGINFO = /ZI
  ! endif
  CFLAGS = $(CFLAGS) -D_DEBUG -DDEBUG /Od
***************
*** 424,430 ****
  LIBC = $(LIBC) msvcrtd.lib
  ! else
  LIBC = $(LIBC) libcmtd.lib
! CFLAGS = $(CFLAGS) /MTd
  ! endif
  !endif # DEBUG
  
--- 430,436 ----
  LIBC = $(LIBC) msvcrtd.lib
  ! else
  LIBC = $(LIBC) libcmtd.lib
! CFLAGS = $(CFLAGS) /Zl /MTd
  ! endif
  !endif # DEBUG
  
***************
*** 534,540 ****
  	$(OUTDIR)\gui_w32.obj \
  	$(OUTDIR)\os_w32exe.obj
  GUI_LIB = \
! 	oldnames.lib kernel32.lib gdi32.lib version.lib $(IME_LIB) \
  	winspool.lib comctl32.lib advapi32.lib shell32.lib \
  	/machine:$(CPU) /nodefaultlib
  !else
--- 540,546 ----
  	$(OUTDIR)\gui_w32.obj \
  	$(OUTDIR)\os_w32exe.obj
  GUI_LIB = \
! 	gdi32.lib version.lib $(IME_LIB) \
  	winspool.lib comctl32.lib advapi32.lib shell32.lib \
  	/machine:$(CPU) /nodefaultlib
  !else
***************
*** 757,763 ****
  
  # Report link time code generation progress if used. 
  !ifdef NODEBUG
! !if "$(MSVCVER)" == "8.0"
  !if "$(OPTIMIZE)" != "SPACE"
  LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
  !endif
--- 763,769 ----
  
  # Report link time code generation progress if used. 
  !ifdef NODEBUG
! !if ("$(MSVCVER)" == "8.0") || ("$(MSVCVER)" == "9.0")
  !if "$(OPTIMIZE)" != "SPACE"
  LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
  !endif
*** ../vim-7.1.281/src/os_win32.c	Tue Nov 20 17:21:28 2007
--- src/os_win32.c	Wed Mar 12 15:24:33 2008
***************
*** 2856,2862 ****
  	windgoto((int)Rows - 1, 0);
  	g_fForceExit = TRUE;
  
! 	sprintf((char *)IObuff, _("Vim: Caught %s event\n"),
  		(dwCtrlType == CTRL_CLOSE_EVENT
  		     ? _("close")
  		     : dwCtrlType == CTRL_LOGOFF_EVENT
--- 2856,2862 ----
  	windgoto((int)Rows - 1, 0);
  	g_fForceExit = TRUE;
  
! 	vim_snprintf((char *)IObuff, IOSIZE, _("Vim: Caught %s event\n"),
  		(dwCtrlType == CTRL_CLOSE_EVENT
  		     ? _("close")
  		     : dwCtrlType == CTRL_LOGOFF_EVENT
***************
*** 3282,3293 ****
      {
  	/* we use "command" or "cmd" to start the shell; slow but easy */
  	char_u *newcmd;
! 
! 	newcmd = lalloc((long_u) (
  #ifdef FEAT_GUI_W32
  		STRLEN(vimrun_path) +
  #endif
! 		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10), TRUE);
  	if (newcmd != NULL)
  	{
  	    char_u *cmdbase = (*cmd == '"' ? cmd + 1 : cmd);
--- 3282,3294 ----
      {
  	/* we use "command" or "cmd" to start the shell; slow but easy */
  	char_u *newcmd;
! 	long_u cmdlen =  (
  #ifdef FEAT_GUI_W32
  		STRLEN(vimrun_path) +
  #endif
! 		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
! 
! 	newcmd = lalloc(cmdlen, TRUE);
  	if (newcmd != NULL)
  	{
  	    char_u *cmdbase = (*cmd == '"' ? cmd + 1 : cmd);
***************
*** 3373,3386 ****
  		if (!s_dont_use_vimrun)
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
! 		    sprintf((char *)newcmd, "%s%s%s %s %s",
  			    vimrun_path,
  			    (msg_silent != 0 || (options & SHELL_DOOUT))
  								 ? "-s " : "",
  			    p_sh, p_shcf, cmd);
  		else
  #endif
! 		    sprintf((char *)newcmd, "%s %s %s", p_sh, p_shcf, cmd);
  		x = mch_system((char *)newcmd, options);
  	    }
  	    vim_free(newcmd);
--- 3374,3388 ----
  		if (!s_dont_use_vimrun)
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
!                     vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
  			    vimrun_path,
  			    (msg_silent != 0 || (options & SHELL_DOOUT))
  								 ? "-s " : "",
  			    p_sh, p_shcf, cmd);
  		else
  #endif
!                     vim_snprintf((char *)newcmd, cmdlen, "%s %s %s",
! 							   p_sh, p_shcf, cmd);
  		x = mch_system((char *)newcmd, options);
  	    }
  	    vim_free(newcmd);
***************
*** 4664,4675 ****
--- 4666,4694 ----
  # endif
         )
      {
+ # if defined(DEBUG) && _MSC_VER > 1200
+ 	/* Work around an annoying assertion in the Microsoft debug CRT
+ 	 * when mode's text/binary setting doesn't match _get_fmode(). */
+ 	char newMode = mode[strlen(mode) - 1];
+ 	int oldMode = 0;
+ 
+ 	_get_fmode(&oldMode);
+ 	if (newMode == 't')
+ 	    _set_fmode(_O_TEXT);
+ 	else if (newMode == 'b')
+ 	    _set_fmode(_O_BINARY);
+ # endif
  	wn = enc_to_ucs2(name, NULL);
  	wm = enc_to_ucs2(mode, NULL);
  	if (wn != NULL && wm != NULL)
  	    f = _wfopen(wn, wm);
  	vim_free(wn);
  	vim_free(wm);
+ 
+ # if defined(DEBUG) && _MSC_VER > 1200
+ 	_set_fmode(oldMode);
+ # endif
+ 
  	if (f != NULL)
  	    return f;
  	/* Retry with non-wide function (for Windows 98). Can't use
*** ../vim-7.1.281/src/version.c	Sun Mar 16 13:09:14 2008
--- src/version.c	Sun Mar 16 14:49:21 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     282,
  /**/

-- 
Amazing but true: If all the salmon caught in Canada in one year were laid
end to end across the Sahara Desert, the smell would be absolutely awful.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.283
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.283
Problem:    Non-extra part for 7.1.282.
Solution:   Various changes.
Files:	    src/ex_docmd.c, src/globals.h, src/if_cscope.c, src/main.c,
	    src/mark.c, src/netbeans.c, src/popupmnu.c, src/vim.h,
	    src/window.c


*** ../vim-7.1.282/src/ex_docmd.c	Mon Mar 10 21:33:52 2008
--- src/ex_docmd.c	Wed Mar 12 14:53:18 2008
***************
*** 3009,3015 ****
  		break;
  	if (!isalpha(p[j]) && j >= cmdmods[i].minlen
  					&& (p == cmd || cmdmods[i].has_count))
! 	    return j + (p - cmd);
      }
      return 0;
  }
--- 3009,3015 ----
  		break;
  	if (!isalpha(p[j]) && j >= cmdmods[i].minlen
  					&& (p == cmd || cmdmods[i].has_count))
! 	    return j + (int)(p - cmd);
      }
      return 0;
  }
*** ../vim-7.1.282/src/globals.h	Tue Jan  1 14:16:42 2008
--- src/globals.h	Wed Mar 12 14:54:00 2008
***************
*** 1263,1269 ****
   * The value of the --windowid argument.
   * For embedding gvim inside another application.
   */
! EXTERN int	win_socket_id INIT(= 0);
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
--- 1263,1269 ----
   * The value of the --windowid argument.
   * For embedding gvim inside another application.
   */
! EXTERN long_u	win_socket_id INIT(= 0);
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
*** ../vim-7.1.282/src/if_cscope.c	Sun Mar 16 13:09:14 2008
--- src/if_cscope.c	Sun Mar 16 13:05:51 2008
***************
*** 1400,1406 ****
  	return NULL;
  
      /* Store length of eap->arg before it gets modified by strtok(). */
!     eap_arg_len = STRLEN(eap->arg);
  
      if ((stok = strtok((char *)(eap->arg), (const char *)" ")) == NULL)
  	return NULL;
--- 1400,1406 ----
  	return NULL;
  
      /* Store length of eap->arg before it gets modified by strtok(). */
!     eap_arg_len = (int)STRLEN(eap->arg);
  
      if ((stok = strtok((char *)(eap->arg), (const char *)" ")) == NULL)
  	return NULL;
*** ../vim-7.1.282/src/main.c	Sun Jan 13 16:17:02 2008
--- src/main.c	Wed Mar 12 15:04:30 2008
***************
*** 1552,1566 ****
  	else if (STRICMP(argv[i], "--socketid") == 0)
  #  endif
  	{
! 	    unsigned int    id;
! 	    int		    count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), "%x", &id);
  	    else
! 		count = sscanf(argv[i+1], "%u", &id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
--- 1552,1566 ----
  	else if (STRICMP(argv[i], "--socketid") == 0)
  #  endif
  	{
! 	    long_u	id;
! 	    int		count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), SCANF_HEX_LONG_U, &id);
  	    else
! 		count = sscanf(argv[i + 1], SCANF_DECIMAL_LONG_U, &id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
*** ../vim-7.1.282/src/mark.c	Wed Feb 13 12:41:30 2008
--- src/mark.c	Wed Mar 12 15:10:14 2008
***************
*** 522,528 ****
  	    int len;
  
  	    expand_env((char_u *)"~/", NameBuff, MAXPATHL);
! 	    len = STRLEN(NameBuff);
  	    vim_strncpy(NameBuff + len, fm->fname + 2, MAXPATHL - len - 1);
  	}
  	else
--- 522,528 ----
  	    int len;
  
  	    expand_env((char_u *)"~/", NameBuff, MAXPATHL);
! 	    len = (int)STRLEN(NameBuff);
  	    vim_strncpy(NameBuff + len, fm->fname + 2, MAXPATHL - len - 1);
  	}
  	else
*** ../vim-7.1.282/src/netbeans.c	Fri Jan 18 11:40:02 2008
--- src/netbeans.c	Wed Mar 12 15:11:42 2008
***************
*** 1216,1222 ****
      int lastbyte = last;
  
      oldtext = ml_get(lnum);
!     oldlen = STRLEN(oldtext);
      if (first >= (colnr_T)oldlen || oldlen == 0)  /* just in case */
  	return;
      if (lastbyte >= oldlen)
--- 1216,1222 ----
      int lastbyte = last;
  
      oldtext = ml_get(lnum);
!     oldlen = (int)STRLEN(oldtext);
      if (first >= (colnr_T)oldlen || oldlen == 0)  /* just in case */
  	return;
      if (lastbyte >= oldlen)
***************
*** 1241,1248 ****
      int len_first, len_other;
      char_u *p;
  
!     len_first = STRLEN(ml_get(first));
!     len_other = STRLEN(ml_get(other));
      p = alloc((unsigned)(len_first + len_other + 1));
      if (p != NULL)
      {
--- 1241,1248 ----
      int len_first, len_other;
      char_u *p;
  
!     len_first = (int)STRLEN(ml_get(first));
!     len_other = (int)STRLEN(ml_get(other));
      p = alloc((unsigned)(len_first + len_other + 1));
      if (p != NULL)
      {
*** ../vim-7.1.282/src/popupmnu.c	Wed Aug  8 22:48:16 2007
--- src/popupmnu.c	Wed Mar 12 15:17:21 2008
***************
*** 337,343 ****
  
  				if (rt != NULL)
  				{
! 				    len = STRLEN(rt);
  				    if (len > pum_width)
  				    {
  					for (j = pum_width; j < len; ++j)
--- 337,343 ----
  
  				if (rt != NULL)
  				{
! 				    len = (int)STRLEN(rt);
  				    if (len > pum_width)
  				    {
  					for (j = pum_width; j < len; ++j)
*** ../vim-7.1.282/src/vim.h	Sat Mar 15 13:10:57 2008
--- src/vim.h	Thu Mar 13 23:39:21 2008
***************
*** 355,370 ****
   * On Win64 longs are 32 bit and pointers 64 bit.
   * For printf() and scanf() we need to take care of long_u specifically. */
  #ifdef _WIN64
! typedef unsigned __int64 long_u;
! typedef		 __int64 long_i;
! # define SCANF_HEX_LONG_U  "%Ix"
! # define PRINTF_HEX_LONG_U "0x%Ix"
! #else
! typedef unsigned long	long_u;
! typedef		 long	long_i;
! # define SCANF_HEX_LONG_U  "%lx"
! # define PRINTF_HEX_LONG_U "0x%lx"
  #endif
  
  /*
   * The characters and attributes cached for the screen.
--- 355,373 ----
   * On Win64 longs are 32 bit and pointers 64 bit.
   * For printf() and scanf() we need to take care of long_u specifically. */
  #ifdef _WIN64
! typedef unsigned __int64        long_u;
! typedef		 __int64        long_i;
! # define SCANF_HEX_LONG_U       "%Ix"
! # define SCANF_DECIMAL_LONG_U   "%Iu"
! # define PRINTF_HEX_LONG_U      "0x%Ix"
! #else
! typedef unsigned long	        long_u;
! typedef		 long	        long_i;
! # define SCANF_HEX_LONG_U       "%lx"
! # define SCANF_DECIMAL_LONG_U   "%lu"
! # define PRINTF_HEX_LONG_U      "0x%lx"
  #endif
+ #define PRINTF_DECIMAL_LONG_U SCANF_DECIMAL_LONG_U
  
  /*
   * The characters and attributes cached for the screen.
*** ../vim-7.1.282/src/window.c	Sat Sep 29 14:15:00 2007
--- src/window.c	Wed Mar 12 15:22:10 2008
***************
*** 6303,6309 ****
  	    cur = cur->next;
  	}
      }
!     if ((hlg_id = syn_namen2id(grp, STRLEN(grp))) == 0)
      {
  	EMSG2(_(e_nogroup), grp);
  	return -1;
--- 6303,6309 ----
  	    cur = cur->next;
  	}
      }
!     if ((hlg_id = syn_namen2id(grp, (int)STRLEN(grp))) == 0)
      {
  	EMSG2(_(e_nogroup), grp);
  	return -1;
*** ../vim-7.1.282/src/version.c	Sun Mar 16 14:52:53 2008
--- src/version.c	Sun Mar 16 16:00:17 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     283,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
139. You down your lunch in five minutes, at your desk, so you can
     spend the rest of the hour surfing the Net.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.284
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.284
Problem:    Compiler warnings for functions without prototype.
Solution:   Add the function prototypes. (Patrick Texier)
Files:	    src/eval.c, src/quickfix.c


*** ../vim-7.1.283/src/eval.c	Wed Feb 20 20:09:44 2008
--- src/eval.c	Sat Mar 15 12:49:14 2008
***************
*** 14662,14667 ****
--- 14662,14669 ----
  	appended_lines_mark(lcount, added);
  }
  
+ static void set_qf_ll_list __ARGS((win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv));
+ 
  /*
   * Used by "setqflist()" and "setloclist()" functions
   */
*** ../vim-7.1.283/src/quickfix.c	Sat Jan 19 15:55:51 2008
--- src/quickfix.c	Sat Mar 15 12:51:05 2008
***************
*** 106,112 ****
--- 106,114 ----
  
  static int	qf_init_ext __ARGS((qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast));
  static void	qf_new_list __ARGS((qf_info_T *qi));
+ static void	ll_free_all __ARGS((qf_info_T **pqi));
  static int	qf_add_entry __ARGS((qf_info_T *qi, qfline_T **prevp, char_u *dir, char_u *fname, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid));
+ static qf_info_T *ll_new_list __ARGS((void));
  static void	qf_msg __ARGS((qf_info_T *qi));
  static void	qf_free __ARGS((qf_info_T *qi, int idx));
  static char_u	*qf_types __ARGS((int, int));
*** ../vim-7.1.283/src/version.c	Sun Mar 16 16:02:47 2008
--- src/version.c	Thu Mar 20 13:21:42 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     284,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
160. You get in the elevator and double-click the button for the floor
     you want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.285 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.285 (extra)
Problem:    Mac: dialog hotkeys don't work.
Solution:   Add hotkey support. (Dan Sandler)
Files:	    src/gui_mac.c


*** ../vim-7.1.284/src/gui_mac.c	Wed Mar 12 21:47:31 2008
--- src/gui_mac.c	Sun Mar 16 15:25:13 2008
***************
*** 153,158 ****
--- 153,161 ----
  /* Keeping track of which scrollbar is being dragged */
  static ControlHandle dragged_sb = NULL;
  
+ /* Vector of char_u --> control index for hotkeys in dialogs */
+ static short *gDialogHotKeys;
+ 
  static struct
  {
      FMFontFamily family;
***************
*** 5519,5524 ****
--- 5522,5570 ----
  	SetDialogItemText(itemHandle, itemName);
  }
  
+ 
+ /* ModalDialog() handler for message dialogs that have hotkey accelerators.
+  * Expects a mapping of hotkey char to control index in gDialogHotKeys;
+  * setting gDialogHotKeys to NULL disables any hotkey handling.
+  */
+     static pascal Boolean
+ DialogHotkeyFilterProc (
+     DialogRef	    theDialog,
+     EventRecord	    *event,
+     DialogItemIndex *itemHit)
+ {
+     char_u keyHit;
+ 
+     if (event->what == keyDown || event->what == autoKey)
+     {
+ 	keyHit = (event->message & charCodeMask);
+ 
+ 	if (gDialogHotKeys && gDialogHotKeys[keyHit])
+ 	{
+ #ifdef DEBUG_MAC_DIALOG_HOTKEYS
+ 	    printf("user pressed hotkey '%c' --> item %d\n", keyHit, gDialogHotKeys[keyHit]);
+ #endif
+ 	    *itemHit = gDialogHotKeys[keyHit];
+ 
+ 	    /* When handing off to StdFilterProc, pretend that the user
+ 	     * clicked the control manually. Note that this is also supposed
+ 	     * to cause the button to hilite briefly (to give some user
+ 	     * feedback), but this seems not to actually work (or it's too
+ 	     * fast to be seen).
+ 	     */
+ 	    event->what = kEventControlSimulateHit;
+ 
+ 	    return true; /* we took care of it */
+ 	}
+ 
+ 	/* Defer to the OS's standard behavior for this event.
+ 	 * This ensures that Enter will still activate the default button. */
+ 	return StdFilterProc(theDialog, event, itemHit);
+     }
+     return false;      /* Let ModalDialog deal with it */
+ }
+ 
+ 
  /* TODO: There have been some crashes with dialogs, check your inbox
   * (Jussi)
   */
***************
*** 5544,5549 ****
--- 5590,5597 ----
      GrafPtr	oldPort;
      short	itemHit;
      char_u	*buttonChar;
+     short	hotKeys[256];		/* map of hotkey -> control ID */
+     char_u	aHotKey;
      Rect	box;
      short	button;
      short	lastButton;
***************
*** 5571,5576 ****
--- 5619,5626 ----
  
      WindowRef	theWindow;
  
+     ModalFilterUPP dialogUPP;
+ 
      /* Check 'v' flag in 'guioptions': vertical button placement. */
      vertical = (vim_strchr(p_go, GO_VERTICAL) != NULL);
  
***************
*** 5610,5615 ****
--- 5660,5668 ----
      buttonChar = buttons;
      button = 0;
  
+     /* initialize the hotkey mapping */
+     memset(hotKeys, 0, sizeof(hotKeys));
+ 
      for (;*buttonChar != 0;)
      {
  	/* Get the name of the button */
***************
*** 5619,5625 ****
--- 5672,5689 ----
  	{
  	    if (*buttonChar != DLG_HOTKEY_CHAR)
  		name[++len] = *buttonChar;
+ 	    else
+ 	    {
+ 		aHotKey = (char_u)*(buttonChar+1);
+ 		if (aHotKey >= 'A' && aHotKey <= 'Z')
+ 		    aHotKey = (char_u)((int)aHotKey + (int)'a' - (int)'A');
+ 		hotKeys[aHotKey] = button;
+ #ifdef DEBUG_MAC_DIALOG_HOTKEYS
+ 		printf("### hotKey for button %d is '%c'\n", button, aHotKey);
+ #endif
+ 	    }
  	}
+ 
  	if (*buttonChar != 0)
  	  buttonChar++;
  	name[0] = len;
***************
*** 5688,5694 ****
--- 5752,5764 ----
  	(void) C2PascalString(textfield, &name);
  	SetDialogItemText(itemHandle, name);
  	inputItm.width = StringWidth(name);
+ 
+ 	/* Hotkeys don't make sense if there's a text field */
+ 	gDialogHotKeys = NULL;
      }
+     else
+ 	/* Install hotkey table */
+ 	gDialogHotKeys = (short *)&hotKeys;
  
      /* Set the <ENTER> and <ESC> button. */
      SetDialogDefaultItem(theDialog, dfltbutton);
***************
*** 5777,5786 ****
      dialog_busy = TRUE;
  #endif
  
      /* Hang until one of the button is hit */
      do
      {
! 	ModalDialog(nil, &itemHit);
      } while ((itemHit < 1) || (itemHit > lastButton));
  
  #ifdef USE_CARBONKEYHANDLER
--- 5847,5859 ----
      dialog_busy = TRUE;
  #endif
  
+     /* Prepare the shortcut-handling filterProc for handing to the dialog */
+     dialogUPP = NewModalFilterUPP(DialogHotkeyFilterProc);
+ 
      /* Hang until one of the button is hit */
      do
      {
! 	ModalDialog(dialogUPP, &itemHit);
      } while ((itemHit < 1) || (itemHit > lastButton));
  
  #ifdef USE_CARBONKEYHANDLER
***************
*** 5803,5808 ****
--- 5876,5884 ----
      /* Restore the original graphical port */
      SetPort(oldPort);
  
+     /* Free the modal filterProc */
+     DisposeRoutineDescriptor(dialogUPP);
+ 
      /* Get ride of th edialog (free memory) */
      DisposeDialog(theDialog);
  
*** ../vim-7.1.284/src/version.c	Thu Mar 20 13:22:47 2008
--- src/version.c	Thu Mar 20 14:38:06 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     285,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
163. You go outside for the fresh air (at -30 degrees) but open the
     window first to hear new mail arrive.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.286
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.286 (after 7.1.103)
Problem:    "w" at the end of the buffer moves the cursor past the end of the
	    line. (Markus Heidelberg)
Solution:   Move the cursor back from the NUL when it was moved forward.
Files:	    src/normal.c


*** ../vim-7.1.285/src/normal.c	Sat Jan 19 15:55:51 2008
--- src/normal.c	Wed Mar 19 20:33:44 2008
***************
*** 8345,8350 ****
--- 8345,8351 ----
      int		n;
      int		word_end;
      int		flag = FALSE;
+     pos_T	startpos = curwin->w_cursor;
  
      /*
       * Set inclusive for the "E" and "e" command.
***************
*** 8405,8412 ****
      else
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
!     /* Don't leave the cursor on the NUL past the end of line. */
!     if (n != FAIL)
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
--- 8406,8414 ----
      else
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
!     /* Don't leave the cursor on the NUL past the end of line. Unless we
!      * didn't move it forward. */
!     if (lt(startpos, curwin->w_cursor))
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
*** ../vim-7.1.285/src/version.c	Thu Mar 20 14:38:58 2008
--- src/version.c	Tue Apr  1 12:04:54 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     286,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
200. You really believe in the concept of a "paperless" office.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.287
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.287
Problem:    Crash when reversing a list after using it. (Andy Wokula)
Solution:   Update the pointer to the last used element. (Dominique Pelle)
Files:	    src/eval.c


*** ../vim-7.1.286/src/eval.c	Thu Mar 20 13:22:47 2008
--- src/eval.c	Tue Apr  1 12:36:41 2008
***************
*** 13954,13959 ****
--- 13954,13960 ----
  	rettv->vval.v_list = l;
  	rettv->v_type = VAR_LIST;
  	++l->lv_refcount;
+ 	l->lv_idx = l->lv_len - l->lv_idx - 1;
      }
  }
  
***************
*** 15202,15208 ****
  	    if (!item_compare_func_err)
  	    {
  		/* Clear the List and append the items in the sorted order. */
! 		l->lv_first = l->lv_last = NULL;
  		l->lv_len = 0;
  		for (i = 0; i < len; ++i)
  		    list_append(l, ptrs[i]);
--- 15203,15209 ----
  	    if (!item_compare_func_err)
  	    {
  		/* Clear the List and append the items in the sorted order. */
! 		l->lv_first = l->lv_last = l->lv_idx_item = NULL;
  		l->lv_len = 0;
  		for (i = 0; i < len; ++i)
  		    list_append(l, ptrs[i]);
*** ../vim-7.1.286/src/version.c	Tue Apr  1 12:05:49 2008
--- src/version.c	Tue Apr  1 13:09:10 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     287,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
203. You're an active member of more than 20 newsgroups.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.288
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.288 (after 7.1.281)
Problem:    Cscope still leaves behind temp files when using gvim.
Solution:   When getting the ECHILD error loop for a while until cscope exits.
	    (Dominique Pelle)
Files:	    if_cscope.c


*** ../vim-7.1.287/src/if_cscope.c	Sun Mar 16 16:02:47 2008
--- src/if_cscope.c	Tue Mar 25 21:34:23 2008
***************
*** 2130,2135 ****
--- 2130,2136 ----
      }
  #if defined(UNIX)
      {
+ 	int waitpid_errno;
  	int pstat;
  	pid_t pid;
  
***************
*** 2145,2150 ****
--- 2146,2152 ----
  
  	/* Block until cscope exits or until timer expires */
  	pid = waitpid(csinfo[i].pid, &pstat, 0);
+ 	waitpid_errno = errno;
  
  	/* cancel pending alarm if still there and restore signal */
  	alarm(0);
***************
*** 2158,2163 ****
--- 2160,2166 ----
  	for (waited = 0; waited < 40; ++waited)
  	{
  	    pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);
+ 	    waitpid_errno = errno;
  	    if (pid != 0)
  		break;  /* break unless the process is still running */
  	    mch_delay(50, FALSE); /* sleep 50 ms */
***************
*** 2170,2177 ****
  	 */
  	if (pid < 0 && csinfo[i].pid > 1)
  	{
! 	    kill(csinfo[i].pid, SIGKILL);
! 	    (void)waitpid(csinfo[i].pid, &pstat, 0);
  	}
      }
  #else  /* !UNIX */
--- 2173,2212 ----
  	 */
  	if (pid < 0 && csinfo[i].pid > 1)
  	{
! # ifdef ECHILD
! 	    int alive = TRUE;
! 
! 	    if (waitpid_errno == ECHILD)
! 	    {
! 		/*
! 		 * When using 'vim -g', vim is forked and cscope process is
! 		 * no longer a child process but a sibling.  So waitpid()
! 		 * fails with errno being ECHILD (No child processes).
! 		 * Don't send SIGKILL to cscope immediately but wait
! 		 * (polling) for it to exit normally as result of sending
! 		 * the "q" command, hence giving it a chance to clean up
! 		 * its temporary files.
! 		 */
! 		int waited;
! 
! 		sleep(0);
! 		for (waited = 0; waited < 40; ++waited)
! 		{
! 		    /* Check whether cscope process is still alive */
! 		    if (kill(csinfo[i].pid, 0) != 0)
! 		    {
! 			alive = FALSE; /* cscope process no longer exists */
! 			break;
! 		    }
! 		    mch_delay(50, FALSE); /* sleep 50ms */
! 		}
! 	    }
! 	    if (alive)
! # endif
! 	    {
! 		kill(csinfo[i].pid, SIGKILL);
! 		(void)waitpid(csinfo[i].pid, &pstat, 0);
! 	    }
  	}
      }
  #else  /* !UNIX */
*** ../vim-7.1.287/src/version.c	Tue Apr  1 13:10:45 2008
--- src/version.c	Tue Apr  1 14:28:42 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     288,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
204. You're being audited because you mailed your tax return to the IRC.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.289
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.289
Problem:    When EXITFREE is defined and 'acd' is set freed memory is used.
	    (Dominique Pelle)
Solution:   Reset p_acd before freeing all buffers.
Files:	    src/misc2.c


*** ../vim-7.1.288/src/misc2.c	Wed Feb 20 12:22:59 2008
--- src/misc2.c	Wed Mar 26 21:02:57 2008
***************
*** 751,757 ****
  #endif
  
  /*
!  * Note: if unsinged is 16 bits we can only allocate up to 64K with alloc().
   * Use lalloc for larger blocks.
   */
      char_u *
--- 752,758 ----
  #endif
  
  /*
!  * Note: if unsigned is 16 bits we can only allocate up to 64K with alloc().
   * Use lalloc for larger blocks.
   */
      char_u *
***************
*** 1082,1088 ****
      win_free_all();
  #endif
  
!     /* Free all buffers. */
      for (buf = firstbuf; buf != NULL; )
      {
  	nextbuf = buf->b_next;
--- 1083,1093 ----
      win_free_all();
  #endif
  
!     /* Free all buffers.  Reset 'autochdir' to avoid accessing things that
!      * were freed already. */
! #ifdef FEAT_AUTOCHDIR
!     p_acd = FALSE;
! #endif
      for (buf = firstbuf; buf != NULL; )
      {
  	nextbuf = buf->b_next;
*** ../vim-7.1.288/src/version.c	Tue Apr  1 14:30:18 2008
--- src/version.c	Tue Apr  1 14:51:06 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     289,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
207. You're given one phone call in prison and you ask them for a laptop.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.290
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.290
Problem:    Reading bytes that were not written when spell checking and a line
	    has a very large indent.
Solution:   Don't copy the start of the next line when it only contains
	    spaces. (Dominique Pelle)
Files:	    src/spell.c


*** ../vim-7.1.289/src/spell.c	Sat Jan 19 15:55:51 2008
--- src/spell.c	Sat Mar 29 13:00:28 2008
***************
*** 2268,2273 ****
--- 2269,2276 ----
  /*
   * For spell checking: concatenate the start of the following line "line" into
   * "buf", blanking-out special characters.  Copy less then "maxlen" bytes.
+  * Keep the blanks at the start of the next line, this is used in win_line()
+  * to skip those bytes if the word was OK.
   */
      void
  spell_cat_line(buf, line, maxlen)
***************
*** 2284,2295 ****
  
      if (*p != NUL)
      {
! 	*buf = ' ';
! 	vim_strncpy(buf + 1, line, maxlen - 2);
! 	n = (int)(p - line);
! 	if (n >= maxlen)
! 	    n = maxlen - 1;
! 	vim_memset(buf + 1, ' ', n);
      }
  }
  
--- 2287,2300 ----
  
      if (*p != NUL)
      {
! 	/* Only worth concatenating if there is something else than spaces to
! 	 * concatenate. */
! 	n = (int)(p - line) + 1;
! 	if (n < maxlen - 1)
! 	{
! 	    vim_memset(buf, ' ', n);
! 	    vim_strncpy(buf +  n, p, maxlen - 1 - n);
! 	}
      }
  }
  
*** ../vim-7.1.289/src/version.c	Tue Apr  1 14:53:02 2008
--- src/version.c	Tue Apr  1 17:05:55 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     290,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
209. Your house stinks because you haven't cleaned it in a week.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.291
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.291 (after 7.1.288)
Problem:    Compiler warning.
Solution:   Change 50 to 50L.
Files:	    src/if_cscope.c


*** ../vim-7.1.290/src/if_cscope.c	Tue Apr  1 14:30:18 2008
--- src/if_cscope.c	Tue Apr  1 20:56:02 2008
***************
*** 2163,2169 ****
  	    waitpid_errno = errno;
  	    if (pid != 0)
  		break;  /* break unless the process is still running */
! 	    mch_delay(50, FALSE); /* sleep 50 ms */
  	}
  # endif
  	/*
--- 2163,2169 ----
  	    waitpid_errno = errno;
  	    if (pid != 0)
  		break;  /* break unless the process is still running */
! 	    mch_delay(50L, FALSE); /* sleep 50 ms */
  	}
  # endif
  	/*
***************
*** 2198,2204 ****
  			alive = FALSE; /* cscope process no longer exists */
  			break;
  		    }
! 		    mch_delay(50, FALSE); /* sleep 50ms */
  		}
  	    }
  	    if (alive)
--- 2198,2204 ----
  			alive = FALSE; /* cscope process no longer exists */
  			break;
  		    }
! 		    mch_delay(50L, FALSE); /* sleep 50ms */
  		}
  	    }
  	    if (alive)
*** ../vim-7.1.290/src/version.c	Tue Apr  1 17:13:54 2008
--- src/version.c	Tue Apr  1 20:58:11 2008
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     291,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
210. When you get a divorce, you don't care about who gets the children,
     but discuss endlessly who can use the email address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.292
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.292
Problem:    When using a pattern with "\@<=" the submatches can be wrong.
	    (Brett Stahlman)
Solution:   Save the submatches when attempting a look-behind match.
Files:	    src/regexp.c


*** ../vim-7.1.291/src/regexp.c	Sat Jan 19 15:55:51 2008
--- src/regexp.c	Tue Apr  1 18:15:47 2008
***************
*** 3039,3044 ****
--- 3039,3053 ----
      } se_u;
  } save_se_T;
  
+ /* used for BEHIND and NOBEHIND matching */
+ typedef struct regbehind_S
+ {
+     regsave_T	save_after;
+     regsave_T	save_behind;
+     save_se_T   save_start[NSUBEXP];
+     save_se_T   save_end[NSUBEXP];
+ } regbehind_T;
+ 
  static char_u	*reg_getline __ARGS((linenr_T lnum));
  static long	vim_regexec_both __ARGS((char_u *line, colnr_T col, proftime_T *tm));
  static long	regtry __ARGS((regprog_T *prog, colnr_T col));
***************
*** 3046,3051 ****
--- 3055,3062 ----
  #ifdef FEAT_SYN_HL
  static void	cleanup_zsubexpr __ARGS((void));
  #endif
+ static void	save_subexpr __ARGS((regbehind_T *bp));
+ static void	restore_subexpr __ARGS((regbehind_T *bp));
  static void	reg_nextline __ARGS((void));
  static void	reg_save __ARGS((regsave_T *save, garray_T *gap));
  static void	reg_restore __ARGS((regsave_T *save, garray_T *gap));
***************
*** 3166,3184 ****
  	save_se_T  sesave;
  	regsave_T  regsave;
      } rs_un;			/* room for saving reginput */
!     short	rs_no;		/* submatch nr */
  } regitem_T;
  
  static regitem_T *regstack_push __ARGS((regstate_T state, char_u *scan));
  static void regstack_pop __ARGS((char_u **scan));
  
- /* used for BEHIND and NOBEHIND matching */
- typedef struct regbehind_S
- {
-     regsave_T	save_after;
-     regsave_T	save_behind;
- } regbehind_T;
- 
  /* used for STAR, PLUS and BRACE_SIMPLE matching */
  typedef struct regstar_S
  {
--- 3177,3188 ----
  	save_se_T  sesave;
  	regsave_T  regsave;
      } rs_un;			/* room for saving reginput */
!     short	rs_no;		/* submatch nr or BEHIND/NOBEHIND */
  } regitem_T;
  
  static regitem_T *regstack_push __ARGS((regstate_T state, char_u *scan));
  static void regstack_pop __ARGS((char_u **scan));
  
  /* used for STAR, PLUS and BRACE_SIMPLE matching */
  typedef struct regstar_S
  {
***************
*** 4888,4893 ****
--- 4892,4901 ----
  		    status = RA_FAIL;
  		else
  		{
+ 		    /* Need to save the subexpr to be able to restore them
+ 		     * when there is a match but we don't use it. */
+ 		    save_subexpr(((regbehind_T *)rp) - 1);
+ 
  		    rp->rs_no = op;
  		    reg_save(&rp->rs_un.regsave, &backpos);
  		    /* First try if what follows matches.  If it does then we
***************
*** 5118,5132 ****
  		    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,
  								    &backpos);
  		else
! 		    /* But we didn't want a match. */
  		    status = RA_NOMATCH;
  		regstack_pop(&scan);
  		regstack.ga_len -= sizeof(regbehind_T);
  	    }
  	    else
  	    {
! 		/* No match: Go back one character.  May go to previous
! 		 * line once. */
  		no = OK;
  		if (REG_MULTI)
  		{
--- 5126,5145 ----
  		    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,
  								    &backpos);
  		else
! 		{
! 		    /* But we didn't want a match.  Need to restore the
! 		     * subexpr, because what follows matched, so they have
! 		     * been set. */
  		    status = RA_NOMATCH;
+ 		    restore_subexpr(((regbehind_T *)rp) - 1);
+ 		}
  		regstack_pop(&scan);
  		regstack.ga_len -= sizeof(regbehind_T);
  	    }
  	    else
  	    {
! 		/* No match or a match that doesn't end where we want it: Go
! 		 * back one character.  May go to previous line once. */
  		no = OK;
  		if (REG_MULTI)
  		{
***************
*** 5160,5165 ****
--- 5173,5185 ----
  		    /* Advanced, prepare for finding match again. */
  		    reg_restore(&rp->rs_un.regsave, &backpos);
  		    scan = OPERAND(rp->rs_scan);
+ 		    if (status == RA_MATCH)
+ 		    {
+ 			/* We did match, so subexpr may have been changed,
+ 			 * need to restore them for the next try. */
+ 			status = RA_NOMATCH;
+ 			restore_subexpr(((regbehind_T *)rp) - 1);
+ 		    }
  		}
  		else
  		{
***************
*** 5172,5178 ****
  			status = RA_MATCH;
  		    }
  		    else
! 			status = RA_NOMATCH;
  		    regstack_pop(&scan);
  		    regstack.ga_len -= sizeof(regbehind_T);
  		}
--- 5192,5207 ----
  			status = RA_MATCH;
  		    }
  		    else
! 		    {
! 			/* We do want a proper match.  Need to restore the
! 			 * subexpr if we had a match, because they may have
! 			 * been set. */
! 			if (status == RA_MATCH)
! 			{
! 			    status = RA_NOMATCH;
! 			    restore_subexpr(((regbehind_T *)rp) - 1);
! 			}
! 		    }
  		    regstack_pop(&scan);
  		    regstack.ga_len -= sizeof(regbehind_T);
  		}
***************
*** 5820,5825 ****
--- 5849,5903 ----
  #endif
  
  /*
+  * Save the current subexpr to "bp", so that they can be restored
+  * later by restore_subexpr().
+  */
+     static void
+ save_subexpr(bp)
+     regbehind_T *bp;
+ {
+     int i;
+ 
+     for (i = 0; i < NSUBEXP; ++i)
+     {
+ 	if (REG_MULTI)
+ 	{
+ 	    bp->save_start[i].se_u.pos = reg_startpos[i];
+ 	    bp->save_end[i].se_u.pos = reg_endpos[i];
+ 	}
+ 	else
+ 	{
+ 	    bp->save_start[i].se_u.ptr = reg_startp[i];
+ 	    bp->save_end[i].se_u.ptr = reg_endp[i];
+ 	}
+     }
+ }
+ 
+ /*
+  * Restore the subexpr from "bp".
+  */
+     static void
+ restore_subexpr(bp)
+     regbehind_T *bp;
+ {
+     int i;
+ 
+     for (i = 0; i < NSUBEXP; ++i)
+     {
+ 	if (REG_MULTI)
+ 	{
+ 	    reg_startpos[i] = bp->save_start[i].se_u.pos;
+ 	    reg_endpos[i] = bp->save_end[i].se_u.pos;
+ 	}
+ 	else
+ 	{
+ 	    reg_startp[i] = bp->save_start[i].se_u.ptr;
+ 	    reg_endp[i] = bp->save_end[i].se_u.ptr;
+ 	}
+     }
+ }
+ 
+ /*
   * Advance reglnum, regline and reginput to the next line.
   */
      static void
*** ../vim-7.1.291/src/version.c	Tue Apr  1 20:58:23 2008
--- src/version.c	Wed Apr  9 12:12:33 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     292,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
259. When you enter your name in the AltaVista search engine, the top ten
     matches do indeed refer to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.293
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.293
Problem:    Spell checking considers super- and subscript characters as word
	    characters.
Solution:   Recognize the Unicode super and subscript characters.
Files:	    src/spell.c


*** ../vim-7.1.292/src/spell.c	Tue Apr  1 17:13:54 2008
--- src/spell.c	Wed Apr  9 15:47:06 2008
***************
*** 753,758 ****
--- 753,759 ----
  static int spell_iswordp __ARGS((char_u *p, buf_T *buf));
  static int spell_iswordp_nmw __ARGS((char_u *p));
  #ifdef FEAT_MBYTE
+ static int spell_mb_isword_class __ARGS((int cl));
  static int spell_iswordp_w __ARGS((int *p, buf_T *buf));
  #endif
  static int write_spell_prefcond __ARGS((FILE *fd, garray_T *gap));
***************
*** 9789,9795 ****
  
  	c = mb_ptr2char(s);
  	if (c > 255)
! 	    return mb_get_class(s) >= 2;
  	return spelltab.st_isw[c];
      }
  #endif
--- 9790,9796 ----
  
  	c = mb_ptr2char(s);
  	if (c > 255)
! 	    return spell_mb_isword_class(mb_get_class(s));
  	return spelltab.st_isw[c];
      }
  #endif
***************
*** 9812,9818 ****
      {
  	c = mb_ptr2char(p);
  	if (c > 255)
! 	    return mb_get_class(p) >= 2;
  	return spelltab.st_isw[c];
      }
  #endif
--- 9813,9819 ----
      {
  	c = mb_ptr2char(p);
  	if (c > 255)
! 	    return spell_mb_isword_class(mb_get_class(p));
  	return spelltab.st_isw[c];
      }
  #endif
***************
*** 9821,9826 ****
--- 9822,9839 ----
  
  #ifdef FEAT_MBYTE
  /*
+  * Return TRUE if word class indicates a word character.
+  * Only for characters above 255.
+  * Unicode subscript and superscript are not considered word characters.
+  */
+     static int
+ spell_mb_isword_class(cl)
+     int cl;
+ {
+     return cl >= 2 && cl != 0x2070 && cl != 0x2080;
+ }
+ 
+ /*
   * Return TRUE if "p" points to a word character.
   * Wide version of spell_iswordp().
   */
***************
*** 9841,9847 ****
      if (*s > 255)
      {
  	if (enc_utf8)
! 	    return utf_class(*s) >= 2;
  	if (enc_dbcs)
  	    return dbcs_class((unsigned)*s >> 8, *s & 0xff) >= 2;
  	return 0;
--- 9854,9860 ----
      if (*s > 255)
      {
  	if (enc_utf8)
! 	    return spell_mb_isword_class(utf_class(*s));
  	if (enc_dbcs)
  	    return dbcs_class((unsigned)*s >> 8, *s & 0xff) >= 2;
  	return 0;
*** ../vim-7.1.292/src/version.c	Wed Apr  9 12:14:44 2008
--- src/version.c	Wed Apr  9 15:45:10 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     293,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
268. You get up in the morning and go online before getting your coffee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.294
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.294
Problem:    Leaking memory when executing a shell command.
Solution:   Free memory when not able to save for undo. (Dominique Pelle)
Files:	    src/ex_cmds.c

*** ../vim-7.1.293/src/ex_cmds.c	Mon Feb 18 19:41:40 2008
--- src/ex_cmds.c	Sun Apr 13 13:20:15 2008
***************
*** 1160,1165 ****
--- 1166,1172 ----
      if (!do_out)
  	msg_putchar('\n');
  
+     /* Create the shell command in allocated memory. */
      cmd_buf = make_filter_cmd(cmd, itmp, otmp);
      if (cmd_buf == NULL)
  	goto filterend;
***************
*** 1180,1186 ****
--- 1187,1196 ----
      if (do_out)
      {
  	if (u_save((linenr_T)(line2), (linenr_T)(line2 + 1)) == FAIL)
+ 	{
+ 	    vim_free(cmd_buf);
  	    goto error;
+ 	}
  	redraw_curbuf_later(VALID);
      }
      read_linecount = curbuf->b_ml.ml_line_count;
***************
*** 4471,4477 ****
  	    /*
  	     * The new text is build up step by step, to avoid too much
  	     * copying.  There are these pieces:
! 	     * sub_firstline	The old text, unmodifed.
  	     * copycol		Column in the old text where we started
  	     *			looking for a match; from here old text still
  	     *			needs to be copied to the new text.
--- 4481,4487 ----
  	    /*
  	     * The new text is build up step by step, to avoid too much
  	     * copying.  There are these pieces:
! 	     * sub_firstline	The old text, unmodified.
  	     * copycol		Column in the old text where we started
  	     *			looking for a match; from here old text still
  	     *			needs to be copied to the new text.
*** ../vim-7.1.293/src/version.c	Wed Apr  9 15:48:08 2008
--- src/version.c	Wed May  7 13:07:48 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     294,
  /**/

-- 
It's not hard to meet expenses, they're everywhere.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.295
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.295
Problem:    Vimtutor only works with vim, not gvim.
Solution:   Add the -g flag to vimtutor. (Dominique Pelle)  Add gvimtutor.
Files:	    src/Makefile, src/gvimtutor, src/vimtutor, runtime/doc/vimtutor.1


*** ../vim-7.1.294/src/Makefile	Wed May  7 13:09:17 2008
--- src/Makefile	Wed May  7 17:34:31 2008
***************
*** 1867,1872 ****
--- 1872,1879 ----
  installtutorbin: $(DEST_VIM)
  	$(INSTALL_DATA) vimtutor $(DEST_BIN)/$(VIMNAME)tutor
  	chmod $(SCRIPTMOD) $(DEST_BIN)/$(VIMNAME)tutor
+ 	$(INSTALL_DATA) gvimtutor $(DEST_BIN)/$(GVIMNAME)tutor
+ 	chmod $(SCRIPTMOD) $(DEST_BIN)/$(GVIMNAME)tutor
  
  installtutor: $(DEST_RT) $(DEST_TUTOR)
  	-$(INSTALL_DATA) $(TUTORSOURCE)/README* $(TUTORSOURCE)/tutor* $(DEST_TUTOR)
***************
*** 2075,2080 ****
--- 2082,2088 ----
  uninstall: uninstall_runtime
  	-rm -f $(DEST_BIN)/$(VIMTARGET)
  	-rm -f $(DEST_BIN)/vimtutor
+ 	-rm -f $(DEST_BIN)/gvimtutor
  	-rm -f $(DEST_BIN)/$(EXTARGET) $(DEST_BIN)/$(VIEWTARGET)
  	-rm -f $(DEST_BIN)/$(GVIMTARGET) $(DEST_BIN)/$(GVIEWTARGET)
  	-rm -f $(DEST_BIN)/$(RVIMTARGET) $(DEST_BIN)/$(RVIEWTARGET)
***************
*** 2171,2177 ****
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[ch] ../*.in ../*.sh ../*.xs ../*.xbm ../toolcheck ../proto ../vimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	cd $(SHADOWDIR); rm -f auto/link.sed
--- 2179,2185 ----
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[ch] ../*.in ../*.sh ../*.xs ../*.xbm ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	cd $(SHADOWDIR); rm -f auto/link.sed
*** ../vim-7.1.294/src/gvimtutor	Wed May  7 17:38:10 2008
--- src/gvimtutor	Wed May  7 17:29:35 2008
***************
*** 0 ****
--- 1,8 ----
+ #!/bin/sh
+ 
+ # Start GUI Vim on a copy of the tutor file.
+ 
+ # Usage: gvimtutor [xx]
+ # See vimtutor for usage.
+ 
+ exec `dirname $0`/vimtutor -g "$@"
*** ../vim-7.1.294/src/vimtutor	Tue Jul 17 14:32:07 2007
--- src/vimtutor	Sat Apr  5 12:21:11 2008
***************
*** 2,12 ****
  
  # Start Vim on a copy of the tutor file.
  
! # Usage: vimtutor [xx], where xx is a language code like "es" or "nl".
  # When an argument is given, it tries loading that tutor.
  # When this fails or no argument was given, it tries using 'v:lang'
  # When that also fails, it uses the English version.
  
  xx=$1
  export xx
  
--- 2,25 ----
  
  # Start Vim on a copy of the tutor file.
  
! # Usage: vimtutor [-g] [xx]
! # Where optional argument -g starts vimtutor in gvim (GUI) instead of vim.
! # and xx is a language code like "es" or "nl".
  # When an argument is given, it tries loading that tutor.
  # When this fails or no argument was given, it tries using 'v:lang'
  # When that also fails, it uses the English version.
  
+ # Vim could be called "vim" or "vi".  Also check for "vimN", for people who
+ # have Vim installed with its version number.
+ # We anticipate up to a future Vim 8 version :-).
+ seq="vim vim8 vim75 vim74 vim73 vim72 vim71 vim70 vim7 vim6 vi"
+ if test "$1" = "-g"; then 
+   # Try to use the GUI version of Vim if possible, it will fall back
+   # on Vim if Gvim is not installed.
+   seq="gvim gvim8 gvim75 gvim74 gvim73 gvim72 gvim71 gvim70 gvim7 gvim6 $seq"
+   shift
+ fi
+ 
  xx=$1
  export xx
  
***************
*** 39,48 ****
  # remove the copy of the tutor on exit
  trap "rm -rf $TODELETE" 0 1 2 3 9 11 13 15
  
- # Vim could be called "vim" or "vi".  Also check for "vimN", for people who
- # have Vim installed with its version number.
- # We anticipate up to a future Vim 8 version :-).
- seq="vim vim8 vim75 vim74 vim73 vim72 vim71 vim70 vim7 vim6 vi"
  for i in $seq; do
  	testvim=`which $i 2>/dev/null`
  	if test -f "$testvim"; then
--- 52,57 ----
***************
*** 59,65 ****
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
  # The script tutor.vim tells Vim which file to copy
! $VIM -u NONE -c 'so $VIMRUNTIME/tutor/tutor.vim'
  
  # Start vim without any .vimrc, set 'nocompatible'
! $VIM -u NONE -c "set nocp" $TUTORCOPY
--- 68,74 ----
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
  # The script tutor.vim tells Vim which file to copy
! $VIM -f -u NONE -c 'so $VIMRUNTIME/tutor/tutor.vim'
  
  # Start vim without any .vimrc, set 'nocompatible'
! $VIM -f -u NONE -c "set nocp" $TUTORCOPY
*** ../vim-7.1.294/runtime/doc/vimtutor.1	Sun Jun 13 18:50:18 2004
--- runtime/doc/vimtutor.1	Sat Apr  5 12:21:11 2008
***************
*** 3,9 ****
  vimtutor \- the Vim tutor
  .SH SYNOPSIS
  .br
! .B vimtutor [language]
  .SH DESCRIPTION
  .B Vimtutor
  starts the
--- 3,9 ----
  vimtutor \- the Vim tutor
  .SH SYNOPSIS
  .br
! .B vimtutor [-g] [language]
  .SH DESCRIPTION
  .B Vimtutor
  starts the
***************
*** 18,23 ****
--- 18,26 ----
  .B Vim
  commands.
  .PP
+ The optional argument -g starts vimtutor with gvim rather than vim, if the
+ GUI version of vim is available, or falls back to Vim if gvim is not found.
+ .PP
  The optional [language] argument is the two-letter name of a language, like
  "it" or "es".
  If the [language] argument is missing, the language of the current locale will
*** ../vim-7.1.294/src/version.c	Wed May  7 13:09:12 2008
--- src/version.c	Wed May  7 17:12:43 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     295,
  /**/

-- 
Time flies like an arrow.
Fruit flies like a banana.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.296
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.296
Problem:    SELinux is not supported.
Solution:   Detect the selinux library and use mch_copy_sec(). (James Vega)
Files:	    src/auto/configure, src/config.h.in, src/configure.in,
	    src/fileio.c, src/memfile.c, src/os_unix.c, src/proto/os_unix.pro


*** ../vim-7.1.295/src/auto/configure	Wed Feb 20 12:43:05 2008
--- src/auto/configure	Wed May  7 18:16:09 2008
***************
*** 845,850 ****
--- 845,851 ----
    --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
    --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
    --disable-darwin        Disable Darwin (Mac OS X) support.
+   --disable-selinux	  Don't check for SELinux support.
    --disable-xsmp          Disable XSMP session management
    --disable-xsmp-interact Disable XSMP interaction
    --enable-mzschemeinterp   Include MzScheme interpreter.
***************
*** 3611,3616 ****
--- 3612,3705 ----
  esac
  fi
  
+ echo "$as_me:$LINENO: checking --disable-selinux argument" >&5
+ echo $ECHO_N "checking --disable-selinux argument... $ECHO_C" >&6
+ # Check whether --enable-selinux or --disable-selinux was given.
+ if test "${enable_selinux+set}" = set; then
+   enableval="$enable_selinux"
+ 
+ else
+   enable_selinux="yes"
+ fi;
+ if test "$enable_selinux" = "yes"; then
+   echo "$as_me:$LINENO: result: no" >&5
+ echo "${ECHO_T}no" >&6
+   echo "$as_me:$LINENO: checking for is_selinux_enabled in -lselinux" >&5
+ echo $ECHO_N "checking for is_selinux_enabled in -lselinux... $ECHO_C" >&6
+ if test "${ac_cv_lib_selinux_is_selinux_enabled+set}" = set; then
+   echo $ECHO_N "(cached) $ECHO_C" >&6
+ else
+   ac_check_lib_save_LIBS=$LIBS
+ LIBS="-lselinux  $LIBS"
+ cat >conftest.$ac_ext <<_ACEOF
+ /* confdefs.h.  */
+ _ACEOF
+ cat confdefs.h >>conftest.$ac_ext
+ cat >>conftest.$ac_ext <<_ACEOF
+ /* end confdefs.h.  */
+ 
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ #ifdef __cplusplus
+ extern "C"
+ #endif
+ /* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+ char is_selinux_enabled ();
+ int
+ main ()
+ {
+ is_selinux_enabled ();
+   ;
+   return 0;
+ }
+ _ACEOF
+ rm -f conftest.$ac_objext conftest$ac_exeext
+ if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+   (eval $ac_link) 2>conftest.er1
+   ac_status=$?
+   grep -v '^ *+' conftest.er1 >conftest.err
+   rm -f conftest.er1
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } &&
+ 	 { ac_try='test -z "$ac_c_werror_flag"
+ 			 || test ! -s conftest.err'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; } &&
+ 	 { ac_try='test -s conftest$ac_exeext'
+   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+   (eval $ac_try) 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); }; }; then
+   ac_cv_lib_selinux_is_selinux_enabled=yes
+ else
+   echo "$as_me: failed program was:" >&5
+ sed 's/^/| /' conftest.$ac_ext >&5
+ 
+ ac_cv_lib_selinux_is_selinux_enabled=no
+ fi
+ rm -f conftest.err conftest.$ac_objext \
+       conftest$ac_exeext conftest.$ac_ext
+ LIBS=$ac_check_lib_save_LIBS
+ fi
+ echo "$as_me:$LINENO: result: $ac_cv_lib_selinux_is_selinux_enabled" >&5
+ echo "${ECHO_T}$ac_cv_lib_selinux_is_selinux_enabled" >&6
+ if test $ac_cv_lib_selinux_is_selinux_enabled = yes; then
+   LIBS="$LIBS -lselinux"
+ 	   cat >>confdefs.h <<\_ACEOF
+ #define HAVE_SELINUX 1
+ _ACEOF
+ 
+ fi
+ 
+ else
+    echo "$as_me:$LINENO: result: yes" >&5
+ echo "${ECHO_T}yes" >&6
+ fi
  
  
  echo "$as_me:$LINENO: checking --with-features argument" >&5
*** ../vim-7.1.295/src/config.h.in	Tue May  1 13:37:23 2007
--- src/config.h.in	Wed May  7 18:10:49 2008
***************
*** 156,161 ****
--- 156,162 ----
  #undef HAVE_READLINK
  #undef HAVE_RENAME
  #undef HAVE_SELECT
+ #undef HAVE_SELINUX
  #undef HAVE_SETENV
  #undef HAVE_SETPGID
  #undef HAVE_SETSID
*** ../vim-7.1.295/src/configure.in	Wed Feb 20 12:43:05 2008
--- src/configure.in	Wed May  7 18:15:40 2008
***************
*** 299,304 ****
--- 299,317 ----
  esac
  fi
  
+ dnl Link with -lselinux for SELinux stuff; if not found
+ AC_MSG_CHECKING(--disable-selinux argument)
+ AC_ARG_ENABLE(selinux,
+ 	[  --disable-selinux	  Don't check for SELinux support.],
+ 	, enable_selinux="yes")
+ if test "$enable_selinux" = "yes"; then
+   AC_MSG_RESULT(no)
+   AC_CHECK_LIB(selinux, is_selinux_enabled,
+ 	  [LIBS="$LIBS -lselinux"
+ 	   AC_DEFINE(HAVE_SELINUX)])
+ else
+    AC_MSG_RESULT(yes)
+ fi
  
  dnl Check user requested features.
  
*** ../vim-7.1.295/src/fileio.c	Tue Mar 11 22:01:16 2008
--- src/fileio.c	Wed May  7 18:17:45 2008
***************
*** 3651,3656 ****
--- 3660,3668 ----
  						)
  			    mch_setperm(backup,
  					  (perm & 0707) | ((perm & 07) << 3));
+ # ifdef HAVE_SELINUX
+ 			mch_copy_sec(fname, backup);
+ # endif
  #endif
  
  			/*
***************
*** 3687,3692 ****
--- 3699,3707 ----
  #ifdef HAVE_ACL
  			mch_set_acl(backup, acl);
  #endif
+ #ifdef HAVE_SELINUX
+ 			mch_copy_sec(fname, backup);
+ #endif
  			break;
  		    }
  		}
***************
*** 4309,4314 ****
--- 4324,4335 ----
      }
  #endif
  
+ #ifdef HAVE_SELINUX
+     /* Probably need to set the security context. */
+     if (!backup_copy)
+ 	mch_copy_sec(backup, wfname);
+ #endif
+ 
  #ifdef UNIX
      /* When creating a new file, set its owner/group to that of the original
       * file.  Get the new device and inode number. */
*** ../vim-7.1.295/src/memfile.c	Fri May 11 20:15:45 2007
--- src/memfile.c	Wed May  7 18:10:49 2008
***************
*** 1346,1350 ****
--- 1346,1355 ----
  	mfp->mf_ffname = NULL;
      }
      else
+     {
+ #ifdef HAVE_SELINUX
+ 	mch_copy_sec(fname, mfp->mf_fname);
+ #endif
  	mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
+     }
  }
*** ../vim-7.1.295/src/os_unix.c	Wed Mar 12 13:16:37 2008
--- src/os_unix.c	Wed May  7 18:24:46 2008
***************
*** 45,50 ****
--- 45,55 ----
  # include <X11/SM/SMlib.h>
  #endif
  
+ #ifdef HAVE_SELINUX
+ # include <selinux/selinux.h>
+ static int selinux_enabled = -1;
+ #endif
+ 
  /*
   * Use this prototype for select, some include files have a wrong prototype
   */
***************
*** 2557,2562 ****
--- 2562,2623 ----
  } vim_acl_solaris_T;
  # endif
  
+ #if defined(HAVE_SELINUX) || defined(PROTO)
+ /*
+  * Copy security info from "from_file" to "to_file".
+  */
+     void
+ mch_copy_sec(from_file, to_file)
+     char_u	*from_file;
+     char_u	*to_file;
+ {
+     if (from_file == NULL)
+ 	return;
+ 
+     if (selinux_enabled == -1)
+ 	selinux_enabled = is_selinux_enabled();
+ 
+     if (selinux_enabled > 0)
+     {
+ 	security_context_t from_context = NULL;
+ 	security_context_t to_context = NULL;
+ 
+ 	if (getfilecon((char *)from_file, &from_context) < 0)
+ 	{
+ 	    /* If the filesystem doesn't support extended attributes,
+ 	       the original had no special security context and the
+ 	       target cannot have one either.  */
+ 	    if (errno == EOPNOTSUPP)
+ 		return;
+ 
+ 	    MSG_PUTS(_("\nCould not get security context for "));
+ 	    msg_outtrans(from_file);
+ 	    msg_putchar('\n');
+ 	    return;
+ 	}
+ 	if (getfilecon((char *)to_file, &to_context) < 0)
+ 	{
+ 	    MSG_PUTS(_("\nCould not get security context for "));
+ 	    msg_outtrans(to_file);
+ 	    msg_putchar('\n');
+ 	    freecon (from_context);
+ 	    return ;
+ 	}
+ 	if (strcmp(from_context, to_context) != 0)
+ 	{
+ 	    if (setfilecon((char *)to_file, from_context) < 0)
+ 	    {
+ 		MSG_PUTS(_("\nCould not set security context for "));
+ 		msg_outtrans(to_file);
+ 		msg_putchar('\n');
+ 	    }
+ 	}
+ 	freecon(to_context);
+ 	freecon(from_context);
+     }
+ }
+ #endif /* HAVE_SELINUX */
+ 
  /*
   * Return a pointer to the ACL of file "fname" in allocated memory.
   * Return NULL if the ACL is not available for whatever reason.
*** ../vim-7.1.295/src/proto/os_unix.pro	Sat May  5 20:23:37 2007
--- src/proto/os_unix.pro	Wed May  7 18:25:14 2008
***************
*** 34,39 ****
--- 34,40 ----
  void fname_case __ARGS((char_u *name, int len));
  long mch_getperm __ARGS((char_u *name));
  int mch_setperm __ARGS((char_u *name, long perm));
+ void mch_copy_sec __ARGS((char_u *from_file, char_u *to_file));
  vim_acl_T mch_get_acl __ARGS((char_u *fname));
  void mch_set_acl __ARGS((char_u *fname, vim_acl_T aclent));
  void mch_free_acl __ARGS((vim_acl_T aclent));
*** ../vim-7.1.295/src/version.c	Wed May  7 17:39:17 2008
--- src/version.c	Wed May  7 18:50:01 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     296,
  /**/

-- 
Michael: There is no such thing as a dump question.
Bernard: Sure there is.  For example "what is a core dump?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.297
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.297
Problem:    When using the search/replace dialog the parenmatch highlighting
	    can be wrong. (Tim Duncan)
Solution:   In the GUI redraw function invoke the CursorMoved autocmd.
Files:	    src/gui.c


*** ../vim-7.1.296/src/gui.c	Wed Feb  6 17:33:19 2008
--- src/gui.c	Wed May  7 21:36:58 2008
***************
*** 4855,4860 ****
--- 4855,4869 ----
  {
      update_topline();
      validate_cursor();
+ #ifdef FEAT_AUTOCMD
+     /* Trigger CursorMoved if the cursor moved. */
+     if (!finish_op && has_cursormoved()
+ 	    && !equalpos(last_cursormoved, curwin->w_cursor))
+     {
+ 	apply_autocmds(EVENT_CURSORMOVED, NULL, NULL, FALSE, curbuf);
+ 	last_cursormoved = curwin->w_cursor;
+     }
+ #endif
      update_screen(0);	/* may need to update the screen */
      setcursor();
      out_flush();		/* make sure output has been written */
*** ../vim-7.1.296/src/version.c	Wed May  7 19:05:55 2008
--- src/version.c	Wed May  7 21:44:28 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     297,
  /**/

-- 
ARTHUR: Did you say shrubberies?
ROGER:  Yes.  Shrubberies are my trade.  I am a shrubber.  My name is Roger
        the Shrubber.  I arrange, design, and sell shrubberies.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.298
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.298 (after 7.1.295)
Problem:    src/gvimtutor is not distributed.
Solution:   Add it to the list of distributed files.
Files:	    Filelist


*** ../vim-7.1.297/Filelist	Thu May 10 20:35:01 2007
--- Filelist	Sat May 10 21:35:50 2008
***************
*** 193,198 ****
--- 193,199 ----
  		src/vim_icon.xbm \
  		src/vim_mask.xbm \
  		src/vimtutor \
+ 		src/gvimtutor \
  		src/which.sh \
  		src/workshop.c \
  		src/workshop.h \
*** ../vim-7.1.297/src/version.c	Wed May  7 21:45:35 2008
--- src/version.c	Sat May 10 21:37:01 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     298,
  /**/

-- 
ARTHUR: Charge!
   [They all charge with swords drawn towards the RABBIT.  A tremendous twenty
   second fight with Peckinpahish shots and borrowing heavily also on the
   Kung Fu and karate-type films ensues, in which some four KNIGHTS are
   comprehensively killed.]
ARTHUR: Run away!  Run away!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.299
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.299
Problem:    Filetype detection doesn't work properly for file names ending in
	    a part that is ignored and contain a space or other special
	    characters.
Solution:   Escape the special characters using the new fnameescape function.
Files:	    runtime/doc/eval.txt, runtime/filetype.vim, src/eval.c,
	    src/ex_getln.c, src/proto/ex_getln.pro, src/vim.h


*** ../vim-7.1.298/runtime/doc/eval.txt	Wed Feb 20 20:09:44 2008
--- runtime/doc/eval.txt	Wed May 28 16:42:42 2008
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2008 Feb 20
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2008 May 28
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1609,1614 ****
--- 1652,1658 ----
  				String	find directory {name} in {path}
  findfile( {name}[, {path}[, {count}]])
  				String	find file {name} in {path}
+ fnameescape( {fname})		String	escape special characters in {fname}
  fnamemodify( {fname}, {mods})	String	modify file name
  foldclosed( {lnum})		Number	first line of fold at {lnum} if closed
  foldclosedend( {lnum})		Number	last line of fold at {lnum} if closed
***************
*** 2620,2625 ****
--- 2669,2687 ----
  <		Searches from the directory of the current file upwards until
  		it finds the file "tags.vim".
  
+ fnameescape({string})					*fnameescape()*
+ 		Escape {string} for use as file name command argument.  All
+ 		characters that have a special meaning, such as '%' and '|'
+ 		are escaped with a backslash.
+ 		For most systems the characters escaped are "".  For systems
+ 		where a backslash appears in a filename, it depends on the
+ 		value of 'isfname'.
+ 		Example: >
+ 			:let fname = 'some str%nge|name'
+ 			:exe "edit " . fnameescape(fname)
+ <		results in executing: >
+ 			edit some\ str\%nge\|name
+ 
  fnamemodify({fname}, {mods})				*fnamemodify()*
  		Modify file name {fname} according to {mods}.  {mods} is a
  		string of characters like it is used for file names on the
*** ../vim-7.1.298/runtime/filetype.vim	Tue May 15 09:14:33 2007
--- runtime/filetype.vim	Wed May 28 16:39:09 2008
***************
*** 16,35 ****
  augroup filetypedetect
  
  " Ignored extensions
  au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.rpmsave,?\+.rpmnew
! 	\ exe "doau filetypedetect BufRead " . expand("<afile>:r")
  au BufNewFile,BufRead *~
  	\ let s:name = expand("<afile>") |
  	\ let s:short = substitute(s:name, '\~$', '', '') |
  	\ if s:name != s:short && s:short != "" |
! 	\   exe "doau filetypedetect BufRead " . s:short |
  	\ endif |
! 	\ unlet s:name |
! 	\ unlet s:short
  au BufNewFile,BufRead ?\+.in
  	\ if expand("<afile>:t") != "configure.in" |
! 	\   exe "doau filetypedetect BufRead " . expand("<afile>:r") |
  	\ endif
  
  " Pattern used to match file names which should not be inspected.
  " Currently finds compressed files.
--- 16,38 ----
  augroup filetypedetect
  
  " Ignored extensions
+ if exists("*fnameescape")
  au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.rpmsave,?\+.rpmnew
! 	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
  au BufNewFile,BufRead *~
  	\ let s:name = expand("<afile>") |
  	\ let s:short = substitute(s:name, '\~$', '', '') |
  	\ if s:name != s:short && s:short != "" |
! 	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
  	\ endif |
! 	\ unlet s:name s:short
  au BufNewFile,BufRead ?\+.in
  	\ if expand("<afile>:t") != "configure.in" |
! 	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
  	\ endif
+ elseif &verbose > 0
+   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
+ endif
  
  " Pattern used to match file names which should not be inspected.
  " Currently finds compressed files.
*** ../vim-7.1.298/src/eval.c	Tue Apr  1 13:10:45 2008
--- src/eval.c	Wed May 28 16:35:51 2008
***************
*** 507,512 ****
--- 516,522 ----
  static void f_filter __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_finddir __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_findfile __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_fnameescape __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_fnamemodify __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_foldclosed __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_foldclosedend __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 7107,7112 ****
--- 7437,7443 ----
      {"filter",		2, 2, f_filter},
      {"finddir",		1, 3, f_finddir},
      {"findfile",	1, 3, f_findfile},
+     {"fnameescape",	1, 1, f_fnameescape},
      {"fnamemodify",	2, 2, f_fnamemodify},
      {"foldclosed",	1, 1, f_foldclosed},
      {"foldclosedend",	1, 1, f_foldclosedend},
***************
*** 9465,9470 ****
--- 9804,9822 ----
  }
  
  /*
+  * "fnameescape({string})" function
+  */
+     static void
+ f_fnameescape(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+     rettv->vval.v_string = vim_strsave_fnameescape(
+ 					   get_tv_string(&argvars[0]), FALSE);
+     rettv->v_type = VAR_STRING;
+ }
+ 
+ /*
   * "fnamemodify({fname}, {mods})" function
   */
      static void
*** ../vim-7.1.298/src/ex_getln.c	Tue Jan 22 12:44:03 2008
--- src/ex_getln.c	Mon May 26 22:14:51 2008
***************
*** 3656,3677 ****
  #endif
  		    }
  		}
! #ifdef BACKSLASH_IN_FILENAME
! 		{
! 		    char_u	buf[20];
! 		    int		j = 0;
! 
! 		    /* Don't escape '[' and '{' if they are in 'isfname'. */
! 		    for (p = PATH_ESC_CHARS; *p != NUL; ++p)
! 			if ((*p != '[' && *p != '{') || !vim_isfilec(*p))
! 			    buf[j++] = *p;
! 		    buf[j] = NUL;
! 		    p = vim_strsave_escaped(files[i], buf);
! 		}
! #else
! 		p = vim_strsave_escaped(files[i],
! 			     xp->xp_shell ? SHELL_ESC_CHARS : PATH_ESC_CHARS);
! #endif
  		if (p != NULL)
  		{
  		    vim_free(files[i]);
--- 3656,3662 ----
  #endif
  		    }
  		}
! 		p = vim_strsave_fnameescape(files[i], xp->xp_shell);
  		if (p != NULL)
  		{
  		    vim_free(files[i]);
***************
*** 3710,3715 ****
--- 3695,3725 ----
  }
  
  /*
+  * Escape special characters in "fname" for when used as a file name argument
+  * after a Vim command, or, when "shell" is non-zero, a shell command.
+  * Returns the result in allocated memory.
+  */
+     char_u *
+ vim_strsave_fnameescape(fname, shell)
+     char_u *fname;
+     int    shell;
+ {
+ #ifdef BACKSLASH_IN_FILENAME
+     char_u	buf[20];
+     int		j = 0;
+ 
+     /* Don't escape '[' and '{' if they are in 'isfname'. */
+     for (p = PATH_ESC_CHARS; *p != NUL; ++p)
+ 	if ((*p != '[' && *p != '{') || !vim_isfilec(*p))
+ 	    buf[j++] = *p;
+     buf[j] = NUL;
+     return vim_strsave_escaped(fname, buf);
+ #else
+     return vim_strsave_escaped(fname, shell ? SHELL_ESC_CHARS : PATH_ESC_CHARS);
+ #endif
+ }
+ 
+ /*
   * Put a backslash before the file name in "pp", which is in allocated memory.
   */
      static void
*** ../vim-7.1.298/src/proto/ex_getln.pro	Sat May  5 19:24:48 2007
--- src/proto/ex_getln.pro	Mon May 26 22:14:41 2008
***************
*** 24,29 ****
--- 24,30 ----
  void ExpandInit __ARGS((expand_T *xp));
  void ExpandCleanup __ARGS((expand_T *xp));
  void ExpandEscape __ARGS((expand_T *xp, char_u *str, int numfiles, char_u **files, int options));
+ char_u *vim_strsave_fnameescape __ARGS((char_u *fname, int shell));
  void tilde_replace __ARGS((char_u *orig_pat, int num_files, char_u **files));
  char_u *sm_gettail __ARGS((char_u *s));
  char_u *addstar __ARGS((char_u *fname, int len, int context));
*** ../vim-7.1.298/src/vim.h	Sun Mar 16 16:02:47 2008
--- src/vim.h	Wed May 28 16:37:50 2008
***************
*** 336,345 ****
  # endif
  #endif
  #ifdef BACKSLASH_IN_FILENAME
! # define PATH_ESC_CHARS ((char_u *)" \t*?[{`%#")
  #else
! # define PATH_ESC_CHARS ((char_u *)" \t*?[{`$\\%#'\"|")
! # define SHELL_ESC_CHARS ((char_u *)" \t*?[{`$\\%#'\"|<>();&!")
  #endif
  
  #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
--- 336,345 ----
  # endif
  #endif
  #ifdef BACKSLASH_IN_FILENAME
! # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`%#'\"|!<")
  #else
! # define PATH_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<")
! # define SHELL_ESC_CHARS ((char_u *)" \t\n*?[{`$\\%#'\"|!<>();&")
  #endif
  
  #define NUMBUFLEN 30	    /* length of a buffer to store a number in ASCII */
*** ../vim-7.1.298/src/version.c	Sat May 10 21:37:56 2008
--- src/version.c	Wed May 28 16:40:11 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     299,
  /**/

-- 
FIRST SOLDIER:  So they wouldn't be able to bring a coconut back anyway.
SECOND SOLDIER: Wait a minute! Suppose two swallows carried it together?
FIRST SOLDIER:  No, they'd have to have it on a line.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.300
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.300
Problem:    Value of asmsyntax argument isn't checked for valid characters.
Solution:   Only accepts letters and digits.
Files:	    runtime/filetype.vim


*** ../vim-7.1.299/runtime/filetype.vim	Wed May 28 16:48:00 2008
--- runtime/filetype.vim	Wed May 28 17:11:37 2008
***************
*** 190,196 ****
    let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
  	\" ".getline(5)." "
    if head =~ '\sasmsyntax=\S\+\s'
!     let b:asmsyntax = substitute(head, '.*\sasmsyntax=\(\S\+\)\s.*','\1', "")
    elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
      let b:asmsyntax = "vmasm"
    endif
--- 190,196 ----
    let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
  	\" ".getline(5)." "
    if head =~ '\sasmsyntax=\S\+\s'
!     let b:asmsyntax = substitute(head, '.*\sasmsyntax=\([a-zA-Z0-9]\+\)\s.*','\1', "")
    elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
      let b:asmsyntax = "vmasm"
    endif
*** ../vim-7.1.299/src/version.c	Wed May 28 16:48:01 2008
--- src/version.c	Wed May 28 17:28:05 2008
***************
*** 668,669 ****
--- 673,676 ----
  {   /* Add new patch number below this line */
+ /**/
+     300,
  /**/

-- 
If you don't get everything you want, think of
everything you didn't get and don't want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
